import 'colors';
import { Resource } from '../Resource';
import { Unit } from '../Unit';
import { City, CityTile } from './city';
import { GameMap } from '../GameMap';
import { Cart, Worker } from '../Unit';
import { LuxMatchConfigs, SerializedState } from '../types';
import { MatchEngine, Match } from 'dimensions-ai';
import { Action, MoveAction } from '../Actions';
import { Replay } from '../Replay';
import { Position } from '../GameMap/position';
declare class ResourceRequest {
    readonly fromPos: Position;
    readonly amount: number;
    readonly worker?: Worker;
    readonly city?: City;
    constructor(fromPos: Position, amount: number, worker?: Worker, city?: City);
    equals(other: ResourceRequest): boolean;
}
/**
 * Holds basically all game data, including the map.
 *
 * Has the main functions for manipulating game state e.g. moving units, spawning units
 *
 * All entities that require light are any Units or Cities
 */
export declare class Game {
    /**
     * The actual map
     */
    map: GameMap;
    replay: Replay;
    globalCityIDCount: number;
    globalUnitIDCount: number;
    /**
     * Map a internal city id to the array of cells that are city tiles part of the same city
     */
    cities: Map<string, City>;
    stats: Game.Stats;
    state: Game.State;
    configs: Readonly<LuxMatchConfigs>;
    /**
     * Initialize a game, with all its state and stats
     * @param configs
     */
    constructor(configs?: Readonly<Partial<LuxMatchConfigs>>);
    _genInitialAccumulatedActionStats(): _AccumulatedActionStats;
    /**
     * Returns an Action object if validated. If invalid, throws MatchWarn
     */
    validateCommand(cmd: MatchEngine.Command, accumulatedActionStats?: _AccumulatedActionStats): Action;
    workerUnitCapReached(team: Unit.TEAM, offset?: number): boolean;
    cartUnitCapReached(team: Unit.TEAM, offset?: number): boolean;
    spawnWorker(team: Unit.TEAM, x: number, y: number, unitid?: string): Worker;
    spawnCart(team: Unit.TEAM, x: number, y: number, unitid?: string): Cart;
    /**
     * Spawn city tile for a team at (x, y). Can pass cityid to use an existing city id
     */
    spawnCityTile(team: Unit.TEAM, x: number, y: number, cityid?: string): CityTile;
    runCooldowns(): void;
    /**
     * Move specified unit in specified direction
     */
    moveUnit(team: Unit.TEAM, unitid: string, direction: Game.DIRECTIONS): void;
    distributeAllResources(): void;
    resourceMiningRate(type: Resource.Types): number;
    resourceConversionRate(type: Resource.Types): number;
    /**
     * For each unit, check current and orthoganally adjancent cells for that resource
     * type. If found, request as much as we can carry from these cells. In the case of un-even
     * amounts, the unit will request an equal amount from all tiles to fill their cargo, then
     * discard the rest. (for example on 3 wood tiles with 60 wood it would request 17 to each
     * wood tile and discard/waste the extra 1 wood mined).
     *
     * If the unit is on a city tile, only one request will be made (even if there are
     * multiple workers on the tile )and the resources will be deposited into the city as fuel.
     *
     * Once all units have requested resources, distrubte the resources, reducing requests
     * requests if it would exceed the current value. In this case the remaining
     * will be distributed evenly, with the leftovers discarded.
     *
     * @param resourceType - the type of the resource
     */
    handleResourceTypeRelease(resourceType: Resource.Types): void;
    createResourceRequests(resourceType: Resource.Types): Map<string, ResourceRequest[]>;
    resolveResourceRequests(resourceType: Resource.Types, requests: Map<string, ResourceRequest[]>): void;
    /**
     * Auto deposit resources of unit to tile it is on
     */
    handleResourceDeposit(unit: Unit): void;
    getTeamsUnits(team: Unit.TEAM): Map<string, Unit>;
    getUnit(team: Unit.TEAM, unitid: string): Unit;
    /**
     * Transfer resouces on a given team between 2 units. This does not check adjacency requirement, but its expected
     * that the 2 units are adjacent. This allows for simultaneous movement of 1 unit and transfer of another
     */
    transferResources(team: Unit.TEAM, srcID: string, destID: string, resourceType: Resource.Types, amount: number): void;
    /** destroys the city with this id and remove all city tiles */
    destroyCity(cityID: string): void;
    /** destroys the unit with this id and team and removes from tile */
    destroyUnit(team: Unit.TEAM, unitid: string): void;
    /**
     * regenerates trees on map according to the following formula
     * let max_wood_amount be base and the current amount be curr
     *
     * then at the end of each turn after all moves and all resource collection is finished,
     * the wood at a wood tile grows to ceil(min(curr * 1.03, base))
     */
    regenerateTrees(): void;
    /**
     * Process given move actions and returns a pruned array of actions that can all be executed with no collisions
     */
    handleMovementActions(actions: Array<MoveAction>, match: Match): Array<MoveAction>;
    isNight(): boolean;
    toStateObject(): SerializedState;
}
export declare namespace Game {
    interface Configs {
        width: number;
        height: number;
        parameters: LuxMatchConfigs;
    }
    interface Stats {
        teamStats: {
            [x in Unit.TEAM]: TeamStats;
        };
    }
    interface TeamStats {
        fuelGenerated: number;
        resourcesCollected: {
            [x in Resource.Types]: number;
        };
        cityTilesBuilt: number;
        workersBuilt: number;
        cartsBuilt: number;
        roadsBuilt: number;
        roadsPillaged: number;
    }
    interface State {
        turn: number;
        teamStates: {
            [x in Unit.TEAM]: TeamState;
        };
    }
    interface TeamState {
        researchPoints: number;
        units: Map<string, Unit>;
        researched: {
            [x in Resource.Types]: boolean;
        };
    }
    /**
     * All the available agent actions with specifications as to what they do and restrictions.
     */
    enum ACTIONS {
        /**
         * Formatted as `m unitid direction`. unitid should be valid and should have empty space in that direction. moves
         * unit with id unitid in the direction
         */
        MOVE = "m",
        /**
         * Formatted as `r x y`. (x,y) should be an owned city tile, the city tile is commanded to research for
         * the next X turns
         */
        RESEARCH = "r",
        /** Formatted as `bw x y`. (x,y) should be an owned city tile, where worker is to be built */
        BUILD_WORKER = "bw",
        /** Formatted as `bc x y`. (x,y) should be an owned city tile, where the cart is to be built */
        BUILD_CART = "bc",
        /**
         * Formatted as `bcity unitid`. builds city at unitid's pos, unitid should be
         * friendly owned unit that is a worker
         */
        BUILD_CITY = "bcity",
        /**
         * Formatted as `t source_unitid destination_unitid resource_type amount`. Both units in transfer should be
         * adjacent. If command valid, it will transfer as much as possible with a max of the amount specified
         */
        TRANSFER = "t",
        /** formatted as `p unitid`. Unit with the given unitid must be owned and pillages the tile they are on */
        PILLAGE = "p",
        /** formatted as dc <x> <y> */
        DEBUG_ANNOTATE_CIRCLE = "dc",
        /** formatted as dx <x> <y> */
        DEBUG_ANNOTATE_X = "dx",
        /** formatted as dl <x1> <y1> <x2> <y2> */
        DEBUG_ANNOTATE_LINE = "dl",
        /** formatted as dt <x> <y> <message> <fontsize> */
        DEBUG_ANNOTATE_TEXT = "dt",
        /** formatted as dst <message> */
        DEBUG_ANNOTATE_SIDETEXT = "dst"
    }
    enum DIRECTIONS {
        NORTH = "n",
        EAST = "e",
        SOUTH = "s",
        WEST = "w",
        CENTER = "c"
    }
    const ALL_DIRECTIONS: DIRECTIONS[];
}
/**
 * internal use only
 */
declare type _AccumulatedActionStats = {
    [x in Unit.TEAM]: {
        workersBuilt: number;
        cartsBuilt: number;
        actionsPlaced: Set<string>;
    };
};
export {};
