"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __spreadArray = (this && this.__spreadArray) || function (to, from) {
    for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)
        to[j] = from[i];
    return to;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.LuxDesignLogic = void 0;
var defaults_1 = require("./defaults");
var gen_1 = require("./Game/gen");
var Game_1 = require("./Game");
var Unit_1 = require("./Unit");
var seedrandom_1 = __importDefault(require("seedrandom"));
var utils_1 = require("./utils");
var Replay_1 = require("./Replay");
var GameMap_1 = require("./GameMap");
var parseKaggleObs_1 = require("./Replay/parseKaggleObs");
var LuxDesignLogic = /** @class */ (function () {
    function LuxDesignLogic() {
    }
    // Initialization step of each match
    LuxDesignLogic.initialize = function (match) {
        return __awaiter(this, void 0, void 0, function () {
            var randseed, state, forcedWidth, forcedHeight, game, i, agentID;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        randseed = Math.floor(Math.random() * 1e9);
                        state = {
                            configs: utils_1.deepCopy(defaults_1.DEFAULT_CONFIGS),
                            game: null,
                            rng: seedrandom_1.default("" + randseed),
                            profile: null,
                        };
                        state.configs = utils_1.deepMerge(state.configs, match.configs);
                        if (state.configs.runProfiler) {
                            state.profile = {
                                updateStage: [],
                                dataTransfer: [],
                            };
                        }
                        if (state.configs.seed !== undefined) {
                            state.rng = seedrandom_1.default("" + state.configs.seed);
                        }
                        else {
                            state.configs.seed = randseed;
                        }
                        forcedWidth = state.configs.width;
                        forcedHeight = state.configs.height;
                        game = gen_1.generateGame(state.configs);
                        state.game = game;
                        game.replay = new Replay_1.Replay(match, state.configs.compressReplay, state.configs.statefulReplay, state.configs.out);
                        game.replay.data.seed = state.configs.seed;
                        game.replay.data.width = forcedWidth;
                        game.replay.data.height = forcedHeight;
                        game.replay.data.mapType = state.configs.mapType;
                        match.log.detail(state.configs);
                        // store the state into the match so it can be used again in `update` and `getResults`
                        match.state = state;
                        game.map.sortResourcesDeterministically();
                        if (game.replay) {
                            game.replay.writeTeams(match.agents);
                            if (game.replay.statefulReplay) {
                                game.replay.writeState(game);
                            }
                        }
                        i = 0;
                        _a.label = 1;
                    case 1:
                        if (!(i < match.agents.length)) return [3 /*break*/, 4];
                        agentID = match.agents[i].id;
                        return [4 /*yield*/, match.send("" + agentID, agentID)];
                    case 2:
                        _a.sent();
                        _a.label = 3;
                    case 3:
                        i++;
                        return [3 /*break*/, 1];
                    case 4: 
                    // send all agents the current map width and height
                    // `width height` - width and height of the map
                    return [4 /*yield*/, match.sendAll(state.game.map.width + " " + state.game.map.height)];
                    case 5:
                        // send all agents the current map width and height
                        // `width height` - width and height of the map
                        _a.sent();
                        return [4 /*yield*/, this.sendAllAgentsGameInformation(match)];
                    case 6:
                        _a.sent();
                        return [4 /*yield*/, match.sendAll('D_DONE')];
                    case 7:
                        _a.sent();
                        return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Sends map information formatted as so
     *
     * `rp t points` - the number of research points team `t` has
     *
     * `r resource_type x y amount` - the amount of resource of that type at `(x, y)`
     * ...
     *
     * `u unit_type t unit_id x y cd w c u` - the unit on team `t` with id unit_id of type unit_type at `(x, y)` with cooldown `cd`,
     * and `w` `c` `u` units of wood, coal, uranium
     * ...
     *
     * `c t city_id f lk` - citeam `t`'s city with id city_id and fuel `f` and light upkeep `lk`
     * ...
     *
     * `ct t city_id x y cd` - team `t`'s city tile part of city with id city_id at `(x, y)` with cooldown `cd`
     * ...
     *
     *
     * `ccd x y cd` - road level of cell at (x, y)
     *
     */
    LuxDesignLogic.sendAllAgentsGameInformation = function (match) {
        return __awaiter(this, void 0, void 0, function () {
            var stime, state, game, map, promises, teams, _loop_1, y, etime;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        state = match.state;
                        game = state.game;
                        if (game.configs.runProfiler) {
                            stime = new Date().valueOf();
                        }
                        map = game.map;
                        promises = [];
                        teams = [Unit_1.Unit.TEAM.A, Unit_1.Unit.TEAM.B];
                        // send research points
                        teams.forEach(function (team) {
                            var pts = game.state.teamStates[team].researchPoints;
                            match.agents.forEach(function (agent) {
                                if (!agent.isTerminated()) {
                                    promises.push(match.send("rp " + team + " " + pts, agent));
                                }
                            });
                        });
                        // send resource information
                        // only send if agents not terminated
                        map.resources.forEach(function (cell) {
                            match.agents.forEach(function (agent) {
                                if (!agent.isTerminated()) {
                                    promises.push(match.send("r " + cell.resource.type + " " + cell.pos.x + " " + cell.pos.y + " " + cell.resource.amount, agent));
                                }
                            });
                        });
                        // send unit information
                        teams.forEach(function (team) {
                            var units = game.getTeamsUnits(team);
                            units.forEach(function (unit) {
                                match.agents.forEach(function (agent) {
                                    if (!agent.isTerminated()) {
                                        promises.push(match.send("u " + unit.type + " " + team + " " + unit.id + " " + unit.pos.x + " " + unit.pos.y + " " + unit.cooldown + " " + unit.cargo.wood + " " + unit.cargo.coal + " " + unit.cargo.uranium, agent));
                                    }
                                });
                            });
                        });
                        // send city information
                        game.cities.forEach(function (city) {
                            match.agents.forEach(function (agent) {
                                if (!agent.isTerminated()) {
                                    promises.push(match.send("c " + city.team + " " + city.id + " " + city.fuel + " " + city.getLightUpkeep(), agent));
                                }
                            });
                        });
                        game.cities.forEach(function (city) {
                            city.citycells.forEach(function (cell) {
                                match.agents.forEach(function (agent) {
                                    if (!agent.isTerminated()) {
                                        promises.push(match.send("ct " + city.team + " " + city.id + " " + cell.pos.x + " " + cell.pos.y + " " + cell.citytile.cooldown, agent));
                                    }
                                });
                            });
                        });
                        _loop_1 = function (y) {
                            var _loop_2 = function (x) {
                                var cd = game.map.getCell(x, y).getRoad();
                                // ignore cooldowns of 0
                                if (cd !== 0) {
                                    match.agents.forEach(function (agent) {
                                        if (!agent.isTerminated()) {
                                            promises.push(match.send("ccd " + x + " " + y + " " + cd, agent));
                                        }
                                    });
                                }
                            };
                            for (var x = 0; x < game.map.width; x++) {
                                _loop_2(x);
                            }
                        };
                        // send road info in the form of cooldown discounts of cells
                        for (y = 0; y < game.map.height; y++) {
                            _loop_1(y);
                        }
                        return [4 /*yield*/, Promise.all(promises)];
                    case 1:
                        _a.sent();
                        if (game.configs.runProfiler) {
                            etime = new Date().valueOf();
                            state.profile.dataTransfer.push(etime - stime);
                        }
                        return [2 /*return*/];
                }
            });
        });
    };
    // Update step of each match, called whenever the match moves forward by a single unit in time (1 timeStep)
    LuxDesignLogic.update = function (match, commands) {
        return __awaiter(this, void 0, void 0, function () {
            var state, game, stime, actionsMap, accumulatedActionStats, i, action, newactionArray, prunedMoveActions, teams, _i, teams_1, team, _a, teams_2, team, newResourcesMap, i, cell, matchOver, donemsgs, etime;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        state = match.state;
                        game = state.game;
                        if (game.configs.runProfiler) {
                            stime = new Date().valueOf();
                        }
                        match.log.detail('Processing turn ' + game.state.turn);
                        if (!game.configs.debugAnnotations) {
                            // filter out all debug commands
                            commands = commands.filter(function (cmd) {
                                var strs = cmd.command.split(' ');
                                var action = strs[0];
                                if (action[0] === 'd') {
                                    return false;
                                }
                                return true;
                            });
                        }
                        if (game.replay) {
                            game.replay.data.allCommands.push(commands);
                        }
                        actionsMap = new Map();
                        Object.values(Game_1.Game.ACTIONS).forEach(function (val) {
                            actionsMap.set(val, []);
                        });
                        accumulatedActionStats = game._genInitialAccumulatedActionStats();
                        for (i = 0; i < commands.length; i++) {
                            // get the command and the agent that issued it and handle appropriately
                            try {
                                action = game.validateCommand(commands[i], accumulatedActionStats);
                                if (action != null) {
                                    newactionArray = __spreadArray(__spreadArray([], actionsMap.get(action.action)), [action]);
                                    actionsMap.set(action.action, newactionArray);
                                }
                            }
                            catch (err) {
                                match.log.warn("" + err.message);
                            }
                        }
                        // give units and city tiles their validated actions to use
                        actionsMap
                            .get(Game_1.Game.ACTIONS.BUILD_CITY)
                            .forEach(function (action) {
                            game.getUnit(action.team, action.unitid).giveAction(action);
                        });
                        actionsMap
                            .get(Game_1.Game.ACTIONS.BUILD_WORKER)
                            .forEach(function (action) {
                            var citytile = game.map.getCell(action.x, action.y).citytile;
                            citytile.giveAction(action);
                        });
                        actionsMap
                            .get(Game_1.Game.ACTIONS.BUILD_CART)
                            .forEach(function (action) {
                            var citytile = game.map.getCell(action.x, action.y).citytile;
                            citytile.giveAction(action);
                        });
                        actionsMap.get(Game_1.Game.ACTIONS.PILLAGE).forEach(function (action) {
                            game.getUnit(action.team, action.unitid).giveAction(action);
                        });
                        actionsMap.get(Game_1.Game.ACTIONS.RESEARCH).forEach(function (action) {
                            var citytile = game.map.getCell(action.x, action.y).citytile;
                            citytile.giveAction(action);
                        });
                        actionsMap.get(Game_1.Game.ACTIONS.TRANSFER).forEach(function (action) {
                            game.getUnit(action.team, action.srcID).giveAction(action);
                        });
                        prunedMoveActions = game.handleMovementActions(actionsMap.get(Game_1.Game.ACTIONS.MOVE), match);
                        prunedMoveActions.forEach(function (action) {
                            // if direction is center, ignore it
                            if (action.direction !== Game_1.Game.DIRECTIONS.CENTER) {
                                game.getUnit(action.team, action.unitid).giveAction(action);
                            }
                        });
                        // now we go through every actionable entity and execute actions
                        game.cities.forEach(function (city) {
                            city.citycells.forEach(function (cellWithCityTile) {
                                try {
                                    cellWithCityTile.citytile.handleTurn(game);
                                }
                                catch (err) {
                                    match.throw(cellWithCityTile.citytile.team, err);
                                }
                            });
                        });
                        teams = [Unit_1.Unit.TEAM.A, Unit_1.Unit.TEAM.B];
                        for (_i = 0, teams_1 = teams; _i < teams_1.length; _i++) {
                            team = teams_1[_i];
                            game.state.teamStates[team].units.forEach(function (unit) {
                                try {
                                    unit.handleTurn(game);
                                }
                                catch (err) {
                                    match.log.warn("" + err.message);
                                }
                            });
                        }
                        // distribute all resources in order of decreasing fuel efficiency
                        game.distributeAllResources();
                        // now we make all units with cargo drop all resources on the city they are standing on
                        for (_a = 0, teams_2 = teams; _a < teams_2.length; _a++) {
                            team = teams_2[_a];
                            game.state.teamStates[team].units.forEach(function (unit) {
                                game.handleResourceDeposit(unit);
                            });
                        }
                        if (game.isNight()) {
                            this.handleNight(state);
                        }
                        newResourcesMap = [];
                        for (i = 0; i < game.map.resources.length; i++) {
                            cell = game.map.resources[i];
                            if (cell.resource.amount > 0) {
                                newResourcesMap.push(cell);
                            }
                        }
                        game.map.resources = newResourcesMap;
                        // regenerate forests
                        game.regenerateTrees();
                        if (!state.configs.debug) return [3 /*break*/, 2];
                        return [4 /*yield*/, this.debugViewer(game)];
                    case 1:
                        _b.sent();
                        _b.label = 2;
                    case 2:
                        matchOver = this.matchOver(match);
                        game.state.turn++;
                        // store state
                        if (game.replay.statefulReplay) {
                            game.replay.writeState(game);
                        }
                        game.runCooldowns();
                        /** Agent Update Section */
                        return [4 /*yield*/, this.sendAllAgentsGameInformation(match)];
                    case 3:
                        /** Agent Update Section */
                        _b.sent();
                        donemsgs = [];
                        match.agents.forEach(function (agent) {
                            if (!agent.isTerminated()) {
                                donemsgs.push(match.send('D_DONE', agent));
                            }
                        });
                        return [4 /*yield*/, Promise.all(donemsgs)];
                    case 4:
                        _b.sent();
                        if (matchOver) {
                            if (game.replay) {
                                game.replay.writeOut(this.getResults(match));
                            }
                            return [2 /*return*/, 'finished'];
                        }
                        if (game.configs.runProfiler) {
                            etime = new Date().valueOf();
                            state.profile.updateStage.push(etime - stime);
                        }
                        match.log.detail('Beginning turn ' + game.state.turn);
                        return [2 /*return*/];
                }
            });
        });
    };
    LuxDesignLogic.debugViewer = function (game) {
        return __awaiter(this, void 0, void 0, function () {
            var teams, _i, teams_3, team, teamstate, msg;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        console.clear();
                        console.log(game.map.getMapString());
                        console.log("Turn: " + game.state.turn);
                        teams = [Unit_1.Unit.TEAM.A, Unit_1.Unit.TEAM.B];
                        for (_i = 0, teams_3 = teams; _i < teams_3.length; _i++) {
                            team = teams_3[_i];
                            teamstate = game.state.teamStates[team];
                            msg = "RP: " + teamstate.researchPoints + " | Units: " + teamstate.units.size;
                            // teamstate.units.forEach((unit) => {
                            //   msg += `| ${unit.id} (${unit.pos.x}, ${
                            //     unit.pos.y
                            //   }) cargo space: ${unit.getCargoSpaceLeft()}`;
                            // });
                            if (team === Unit_1.Unit.TEAM.A) {
                                console.log(msg.cyan);
                            }
                            else {
                                console.log(msg.red);
                            }
                        }
                        game.cities.forEach(function (city) {
                            var iden = ("City " + city.id).red;
                            if (city.team === 0) {
                                iden = ("City " + city.id).cyan;
                            }
                            console.log(iden + " light: " + city.fuel + " - size: " + city.citycells.length);
                        });
                        return [4 /*yield*/, utils_1.sleep(game.configs.debugDelay)];
                    case 1:
                        _a.sent();
                        return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Determine if match is over or not
     * @param state
     */
    LuxDesignLogic.matchOver = function (match) {
        var state = match.state;
        var game = state.game;
        if (game.state.turn === state.configs.parameters.MAX_DAYS - 1) {
            return true;
        }
        // over if at least one team has no units left or city tiles
        var teams = [Unit_1.Unit.TEAM.A, Unit_1.Unit.TEAM.B];
        var cityCount = [0, 0];
        game.cities.forEach(function (city) {
            cityCount[city.team] += 1;
        });
        for (var _i = 0, teams_4 = teams; _i < teams_4.length; _i++) {
            var team = teams_4[_i];
            if (game.getTeamsUnits(team).size + cityCount[team] === 0) {
                return true;
            }
        }
    };
    /**
     * Handle nightfall and update state accordingly
     * @param state
     */
    LuxDesignLogic.handleNight = function (state) {
        var game = state.game;
        game.cities.forEach(function (city) {
            // if city does not have enough fuel, destroy it
            // TODO, probably add this event to replay
            if (city.fuel < city.getLightUpkeep()) {
                game.destroyCity(city.id);
            }
            else {
                city.fuel -= city.getLightUpkeep();
            }
        });
        [Unit_1.Unit.TEAM.A, Unit_1.Unit.TEAM.B].forEach(function (team) {
            game.state.teamStates[team].units.forEach(function (unit) {
                // TODO: add condition for different light upkeep for units stacked on a city.
                if (!game.map.getCellByPos(unit.pos).isCityTile()) {
                    if (!unit.spendFuelToSurvive()) {
                        // delete unit
                        game.destroyUnit(unit.team, unit.id);
                    }
                }
            });
        });
    };
    LuxDesignLogic.getResults = function (match) {
        // calculate results
        var state = match.state;
        var game = state.game;
        var winningTeam = Unit_1.Unit.TEAM.A;
        var losingTeam = Unit_1.Unit.TEAM.B;
        figureresults: {
            // count city tiles
            var cityTileCount_1 = [0, 0];
            game.cities.forEach(function (city) {
                cityTileCount_1[city.team] += city.citycells.length;
            });
            if (cityTileCount_1[Unit_1.Unit.TEAM.A] > cityTileCount_1[Unit_1.Unit.TEAM.B]) {
                break figureresults;
            }
            else if (cityTileCount_1[Unit_1.Unit.TEAM.A] < cityTileCount_1[Unit_1.Unit.TEAM.B]) {
                winningTeam = Unit_1.Unit.TEAM.B;
                losingTeam = Unit_1.Unit.TEAM.A;
                break figureresults;
            }
            // if tied, count by units
            var unitCount = [
                game.getTeamsUnits(Unit_1.Unit.TEAM.A),
                game.getTeamsUnits(Unit_1.Unit.TEAM.B),
            ];
            if (unitCount[Unit_1.Unit.TEAM.A].size > unitCount[Unit_1.Unit.TEAM.B].size) {
                break figureresults;
            }
            else if (unitCount[Unit_1.Unit.TEAM.A].size < unitCount[Unit_1.Unit.TEAM.B].size) {
                winningTeam = Unit_1.Unit.TEAM.B;
                losingTeam = Unit_1.Unit.TEAM.A;
                break figureresults;
            }
            // if tied still, return a tie
            var results_1 = {
                ranks: [
                    { rank: 1, agentID: winningTeam },
                    { rank: 1, agentID: losingTeam },
                ],
                replayFile: null,
            };
            if (game.configs.storeReplay) {
                results_1.replayFile = game.replay.replayFilePath;
            }
            return results_1;
            // // if tied still, count by fuel generation
            // if (
            //   game.stats.teamStats[Unit.TEAM.A].fuelGenerated >
            //   game.stats.teamStats[Unit.TEAM.B].fuelGenerated
            // ) {
            //   break figureresults;
            // } else if (
            //   game.stats.teamStats[Unit.TEAM.A].fuelGenerated <
            //   game.stats.teamStats[Unit.TEAM.B].fuelGenerated
            // ) {
            //   winningTeam = Unit.TEAM.B;
            //   losingTeam = Unit.TEAM.A;
            //   break figureresults;
            // }
            // // if still undecided, for now, go by random choice
            // if (state.rng() > 0.5) {
            //   winningTeam = Unit.TEAM.B;
            //   losingTeam = Unit.TEAM.A;
            // }
        }
        var results = {
            ranks: [
                { rank: 1, agentID: winningTeam },
                { rank: 2, agentID: losingTeam },
            ],
            replayFile: null,
        };
        if (game.configs.storeReplay) {
            results.replayFile = game.replay.replayFilePath;
        }
        return results;
    };
    /**
     * Reset the match to a starting state and continue from there
     * @param serializedState
     *
     * DOES NOT change constants at all
     */
    LuxDesignLogic.reset = function (match, serializedState) {
        /**
         * For this to work correctly, spawn all entities in first, then update any stats / global related things as
         * some spawning functions updates the stats or globals e.g. global ids
         */
        var state = match.state;
        var game = state.game;
        function isKaggleObs(obs) {
            return obs.updates !== undefined;
        }
        if (isKaggleObs(serializedState)) {
            // handle reduced states (e.g. kaggle outputs)
            serializedState = parseKaggleObs_1.parseKaggleObs(serializedState);
        }
        // update map first
        var height = serializedState.map.length;
        var width = serializedState.map[0].length;
        var configs = __assign({}, game.configs);
        configs.width = width;
        configs.height = height;
        game.map = new GameMap_1.GameMap(configs);
        for (var y = 0; y < height; y++) {
            for (var x = 0; x < width; x++) {
                var cellinfo = serializedState.map[y][x];
                if (cellinfo.resource) {
                    game.map.addResource(x, y, cellinfo.resource.type, cellinfo.resource.amount);
                }
                var cell = game.map.getCell(x, y);
                cell.road = cellinfo.road;
            }
        }
        // spawn in cities
        game.cities = new Map();
        var _loop_3 = function (cityid) {
            var cityinfo = serializedState.cities[cityid];
            cityinfo.cityCells.forEach(function (ct) {
                var tile = game.spawnCityTile(cityinfo.team, ct.x, ct.y, cityinfo.id);
                tile.cooldown = ct.cooldown;
            });
            var city = game.cities.get(cityinfo.id);
            city.fuel = cityinfo.fuel;
        };
        for (var _i = 0, _a = Object.keys(serializedState.cities); _i < _a.length; _i++) {
            var cityid = _a[_i];
            _loop_3(cityid);
        }
        var teams = [Unit_1.Unit.TEAM.A, Unit_1.Unit.TEAM.B];
        for (var _b = 0, teams_5 = teams; _b < teams_5.length; _b++) {
            var team = teams_5[_b];
            game.state.teamStates[team].researchPoints =
                serializedState.teamStates[team].researchPoints;
            game.state.teamStates[team].researched = utils_1.deepCopy(serializedState.teamStates[team].researched);
            game.state.teamStates[team].units.clear();
            for (var _c = 0, _d = Object.keys(serializedState.teamStates[team].units); _c < _d.length; _c++) {
                var unitid = _d[_c];
                var unitinfo = serializedState.teamStates[team].units[unitid];
                var unit = void 0;
                if (unitinfo.type === Unit_1.Unit.Type.WORKER) {
                    unit = game.spawnWorker(team, unitinfo.x, unitinfo.y, unitid);
                }
                else {
                    unit = game.spawnCart(team, unitinfo.x, unitinfo.y, unitid);
                }
                unit.cargo = utils_1.deepCopy(unitinfo.cargo);
                unit.cooldown = utils_1.deepCopy(unitinfo.cooldown);
            }
        }
        // update globals
        game.state.turn = serializedState.turn;
        game.globalCityIDCount = serializedState.globalCityIDCount;
        game.globalUnitIDCount = serializedState.globalUnitIDCount;
        // game.stats = deepCopy(serializedState.stats);
        // without this, causes some bugs
        game.map.sortResourcesDeterministically();
    };
    return LuxDesignLogic;
}());
exports.LuxDesignLogic = LuxDesignLogic;
//# sourceMappingURL=logic.js.map