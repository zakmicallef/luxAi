"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.parseKaggleObs = exports.INPUT_CONSTANTS = void 0;
var Unit_1 = require("../Unit");
var parsed_1 = require("./parsed");
var game_constants_json_1 = __importDefault(require("../game_constants.json"));
/** all constants related to any input from match engine */
exports.INPUT_CONSTANTS = {
    DONE: 'D_DONE',
    RESEARCH_POINTS: 'rp',
    RESOURCES: 'r',
    UNITS: 'u',
    CITY: 'c',
    CITY_TILES: 'ct',
    ROADS: 'ccd'
};
var parseKaggleObs = function (obs) {
    var _a;
    var parse = new parsed_1.Parser(' ');
    var turn = obs.turn; // find this in observation json
    var researchPoints = [0, 0];
    var map = [];
    for (var y = 0; y < obs.height; y++) {
        map.push([]);
        for (var x = 0; x < obs.width; x++) {
            map[y].push({
                road: 0,
            });
        }
    }
    var teamUnits = [{}, {}];
    var cities = {};
    // NOTE, globalCityIDCount and globalUnitIDCount are not in the observations, but not required to work
    // Just means unit ids and city ids won't match up if you replay from a certain step
    for (var _i = 0, _b = obs.updates; _i < _b.length; _i++) {
        var _update = _b[_i];
        var update = parse.parse(_update);
        if (update.str === exports.INPUT_CONSTANTS.DONE) {
            break;
        }
        var inputIdentifier = update.nextStr();
        switch (inputIdentifier) {
            case exports.INPUT_CONSTANTS.RESEARCH_POINTS: {
                var team = update.nextInt();
                researchPoints[team] = update.nextInt();
                break;
            }
            case exports.INPUT_CONSTANTS.RESOURCES: {
                var type = update.nextStr();
                var x = update.nextInt();
                var y = update.nextInt();
                var amt = update.nextInt();
                // this.gameState.map._setResource(type, x, y, amt);
                map[y][x].resource = { type: type, amount: amt };
                break;
            }
            case exports.INPUT_CONSTANTS.UNITS: {
                var unittype = update.nextInt();
                var team = update.nextInt();
                var unitid = update.nextStr();
                var x = update.nextInt();
                var y = update.nextInt();
                var cooldown = update.nextFloat();
                var wood = update.nextInt();
                var coal = update.nextInt();
                var uranium = update.nextInt();
                teamUnits[team][unitid] = {
                    cargo: {
                        wood: wood,
                        coal: coal,
                        uranium: uranium,
                    },
                    x: x,
                    y: y,
                    cooldown: cooldown,
                    type: unittype
                };
                break;
            }
            case exports.INPUT_CONSTANTS.CITY: {
                var team = update.nextInt();
                var cityid = update.nextStr();
                var fuel = update.nextFloat();
                var lightupkeep = update.nextFloat();
                // this.gameState.players[team].cities.set(cityid, new City(team, cityid, fuel, lightUpkeep));
                cities[cityid] = {
                    team: team,
                    fuel: fuel,
                    cityCells: [],
                    id: cityid,
                    lightupkeep: lightupkeep,
                };
                break;
            }
            case exports.INPUT_CONSTANTS.CITY_TILES: {
                var team = update.nextInt();
                var cityid = update.nextStr();
                var x = update.nextInt();
                var y = update.nextInt();
                var cooldown = update.nextFloat();
                var city = cities[cityid]; //this.gameState.players[team].cities.get(cityid);
                // const citytile = city.addCityTile(x, y, cooldown);
                // this.gameState.map.getCell(x, y).citytile = citytile;
                // this.gameState.players[team].cityTileCount += 1;
                city.cityCells.push({ x: x, y: y, cooldown: cooldown });
                break;
            }
            case exports.INPUT_CONSTANTS.ROADS: {
                var x = update.nextInt();
                var y = update.nextInt();
                var road = update.nextFloat();
                // this.gameState.map.getCell(x, y).road = road;
                map[y][x].road = road;
                break;
            }
        }
    }
    return {
        map: map,
        cities: cities,
        globalCityIDCount: obs.globalCityIDCount,
        globalUnitIDCount: obs.globalUnitIDCount,
        turn: turn,
        teamStates: (_a = {},
            _a[Unit_1.Unit.TEAM.A] = {
                researchPoints: researchPoints[0],
                units: teamUnits[0],
                researched: {
                    "wood": true,
                    "coal": researchPoints[0] >= game_constants_json_1.default["PARAMETERS"]["RESEARCH_REQUIREMENTS"]["COAL"],
                    "uranium": researchPoints[0] >= game_constants_json_1.default["PARAMETERS"]["RESEARCH_REQUIREMENTS"]["URANIUM"]
                }
            },
            _a[Unit_1.Unit.TEAM.B] = {
                researchPoints: researchPoints[1],
                units: teamUnits[1],
                researched: {
                    "wood": true,
                    "coal": researchPoints[1] >= game_constants_json_1.default["PARAMETERS"]["RESEARCH_REQUIREMENTS"]["COAL"],
                    "uranium": researchPoints[1] >= game_constants_json_1.default["PARAMETERS"]["RESEARCH_REQUIREMENTS"]["URANIUM"]
                }
            },
            _a)
    };
};
exports.parseKaggleObs = parseKaggleObs;
//# sourceMappingURL=parseKaggleObs.js.map