"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __spreadArray = (this && this.__spreadArray) || function (to, from) {
    for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)
        to[j] = from[i];
    return to;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Game = void 0;
require("colors");
var Resource_1 = require("../Resource");
var Unit_1 = require("../Unit");
var city_1 = require("./city");
var GameMap_1 = require("../GameMap");
var Unit_2 = require("../Unit");
var defaults_1 = require("../defaults");
var DimensionError_1 = require("dimensions-ai/lib/main/DimensionError");
var Actions_1 = require("../Actions");
var utils_1 = require("../utils");
var position_1 = require("../GameMap/position");
var ResourceRequest = /** @class */ (function () {
    function ResourceRequest(fromPos, amount, worker, city) {
        this.fromPos = fromPos;
        this.amount = amount;
        this.worker = worker;
        this.city = city;
    }
    ResourceRequest.prototype.equals = function (other) {
        var _a, _b, _c, _d;
        return this.fromPos.equals(other.fromPos) && ((_a = this.worker) === null || _a === void 0 ? void 0 : _a.id) === ((_b = other.worker) === null || _b === void 0 ? void 0 : _b.id) &&
            this.amount === other.amount && ((_c = this.city) === null || _c === void 0 ? void 0 : _c.id) === ((_d = other.city) === null || _d === void 0 ? void 0 : _d.id);
    };
    return ResourceRequest;
}());
/**
 * Holds basically all game data, including the map.
 *
 * Has the main functions for manipulating game state e.g. moving units, spawning units
 *
 * All entities that require light are any Units or Cities
 */
var Game = /** @class */ (function () {
    /**
     * Initialize a game, with all its state and stats
     * @param configs
     */
    function Game(configs) {
        var _a, _b;
        if (configs === void 0) { configs = {}; }
        this.globalCityIDCount = 0;
        this.globalUnitIDCount = 0;
        /**
         * Map a internal city id to the array of cells that are city tiles part of the same city
         */
        this.cities = new Map();
        // TODO: remove in future. this is not really used anywhere
        this.stats = {
            teamStats: (_a = {},
                _a[Unit_1.Unit.TEAM.A] = {
                    fuelGenerated: 0,
                    resourcesCollected: {
                        wood: 0,
                        coal: 0,
                        uranium: 0,
                    },
                    cityTilesBuilt: 0,
                    workersBuilt: 0,
                    cartsBuilt: 0,
                    roadsBuilt: 0,
                    roadsPillaged: 0,
                },
                _a[Unit_1.Unit.TEAM.B] = {
                    fuelGenerated: 0,
                    resourcesCollected: {
                        wood: 0,
                        coal: 0,
                        uranium: 0,
                    },
                    cityTilesBuilt: 0,
                    workersBuilt: 0,
                    cartsBuilt: 0,
                    roadsBuilt: 0,
                    roadsPillaged: 0,
                },
                _a),
        };
        this.state = {
            turn: 0,
            teamStates: (_b = {},
                _b[Unit_1.Unit.TEAM.A] = {
                    researchPoints: 0,
                    units: new Map(),
                    researched: {
                        wood: true,
                        coal: false,
                        uranium: false,
                    },
                },
                _b[Unit_1.Unit.TEAM.B] = {
                    researchPoints: 0,
                    units: new Map(),
                    researched: {
                        wood: true,
                        coal: false,
                        uranium: false,
                    },
                },
                _b),
        };
        this.configs = __assign({}, defaults_1.DEFAULT_CONFIGS);
        this.configs = __assign(__assign({}, this.configs), configs);
        this.map = new GameMap_1.GameMap(this.configs);
    }
    Game.prototype._genInitialAccumulatedActionStats = function () {
        var _a;
        return _a = {},
            _a[Unit_1.Unit.TEAM.A] = {
                workersBuilt: 0,
                cartsBuilt: 0,
                actionsPlaced: new Set(),
            },
            _a[Unit_1.Unit.TEAM.B] = {
                workersBuilt: 0,
                cartsBuilt: 0,
                actionsPlaced: new Set(),
            },
            _a;
    };
    /**
     * Returns an Action object if validated. If invalid, throws MatchWarn
     */
    Game.prototype.validateCommand = function (cmd, accumulatedActionStats) {
        var _this = this;
        if (accumulatedActionStats === void 0) { accumulatedActionStats = this._genInitialAccumulatedActionStats(); }
        // checks for an error condition, and throws a warning if true
        var check = function (condition, errormsg, trace) {
            if (trace === void 0) { trace = true; }
            if (condition) {
                throw new DimensionError_1.MatchWarn(errormsg +
                    (trace ? "; turn " + _this.state.turn + "; cmd: " + cmd.command : ''));
            }
        };
        var invalidMsg = "Agent " + cmd.agentID + " sent invalid command";
        var malformedMsg = "Agent " + cmd.agentID + " sent malformed command: " + cmd.command;
        var _a = cmd.command.split(' '), action = _a[0], args = _a.slice(1);
        check(action === undefined, invalidMsg, false);
        var team = cmd.agentID;
        var teamState = this.state.teamStates[team];
        var acc = accumulatedActionStats[team];
        switch (action) {
            case Game.ACTIONS.DEBUG_ANNOTATE_CIRCLE:
            case Game.ACTIONS.DEBUG_ANNOTATE_LINE:
            case Game.ACTIONS.DEBUG_ANNOTATE_X:
            case Game.ACTIONS.DEBUG_ANNOTATE_TEXT:
            case Game.ACTIONS.DEBUG_ANNOTATE_SIDETEXT:
                // these actions go directly into the replay file if debugAnnotations is on
                return null;
            case Game.ACTIONS.PILLAGE: {
                check(args.length !== 1, malformedMsg, false);
                var uid = args[0];
                var unit = this.getUnit(team, uid);
                check(!unit, "Agent " + cmd.agentID + " tried to pillage tile with invalid/unowned unit id: " + uid);
                check(!unit.canAct(), "Agent " + cmd.agentID + " tried to pillage tile with cooldown: " + unit.cooldown);
                check(acc.actionsPlaced.has(uid), "Agent " + cmd.agentID + " sent an extra command. Unit can perform only one action at a time");
                acc.actionsPlaced.add(uid);
                return new Actions_1.PillageAction(action, team, uid);
            }
            case Game.ACTIONS.BUILD_CITY: {
                check(args.length !== 1, malformedMsg, false);
                var uid = args[0];
                var unit = this.getUnit(team, uid);
                check(!unit, "Agent " + cmd.agentID + " tried to build CityTile with invalid/unowned unit id: " + uid);
                var cell = this.map.getCellByPos(unit.pos);
                check(cell.isCityTile(), "Agent " + cmd.agentID + " tried to build CityTile on existing CityTile");
                check(cell.hasResource(), "Agent " + cmd.agentID + " tried to build CityTile on non-empty resource tile");
                check(!unit.canAct(), "Agent " + cmd.agentID + " tried to build CityTile with cooldown: " + unit.cooldown);
                var cargoTotal = unit.cargo.wood + unit.cargo.coal + unit.cargo.uranium;
                check(cargoTotal < this.configs.parameters.CITY_BUILD_COST, "Agent " + cmd.agentID + " tried to build CityTile with insufficient materials wood + coal + uranium: " + cargoTotal);
                check(acc.actionsPlaced.has(uid), "Agent " + cmd.agentID + " sent an extra command. Unit can perform only one action at a time");
                acc.actionsPlaced.add(uid);
                return new Actions_1.SpawnCityAction(action, team, uid);
            }
            case Game.ACTIONS.BUILD_CART:
            case Game.ACTIONS.BUILD_WORKER: {
                check(args.length !== 2, malformedMsg, false);
                var x = parseInt(args[0]);
                var y = parseInt(args[1]);
                check(isNaN(x) || isNaN(y) || !this.map.inMap(new position_1.Position(x, y)), "Agent " + cmd.agentID + " tried to build unit with invalid coordinates");
                // check if being built on owned city tile
                var cell = this.map.getCell(x, y);
                // invalid if not a city or not owned
                check(!cell.isCityTile() || cell.citytile.team !== team, "Agent " + cmd.agentID + " tried to build unit on tile (" + x + ", " + y + ") that it does not own");
                var citytile = cell.citytile;
                check(acc.actionsPlaced.has(citytile.getTileID()), "Agent " + cmd.agentID + " sent an extra command. CityTile can perform only one action at a time");
                check(!citytile.canBuildUnit(), "Agent " + cmd.agentID + " tried to build unit on tile (" + x + ", " + y + ") but CityTile still with cooldown of " + citytile.cooldown);
                if (action === Game.ACTIONS.BUILD_CART) {
                    check(this.cartUnitCapReached(team, acc.cartsBuilt + acc.workersBuilt), "Agent " + cmd.agentID + " tried to build unit on tile (" + x + ", " + y + ") but unit cap reached. Build more CityTiles!");
                }
                else {
                    check(this.workerUnitCapReached(team, acc.cartsBuilt + acc.workersBuilt), "Agent " + cmd.agentID + " tried to build unit on tile (" + x + ", " + y + ") but unit cap reached. Build more CityTiles!");
                }
                acc.actionsPlaced.add(citytile.getTileID());
                if (action === Game.ACTIONS.BUILD_CART) {
                    acc.cartsBuilt += 1;
                    return new Actions_1.SpawnCartAction(action, team, x, y);
                }
                acc.workersBuilt += 1;
                return new Actions_1.SpawnWorkerAction(action, team, x, y);
            }
            case Game.ACTIONS.MOVE: {
                check(args.length !== 2, malformedMsg, false);
                var uid = args[0];
                var direction = args[1];
                check(!teamState.units.has(uid), "Agent " + cmd.agentID + " tried to move unit " + uid + " that it does not own");
                var unit = teamState.units.get(uid);
                check(!unit.canMove(), "Agent " + cmd.agentID + " tried to move unit " + uid + " with cooldown: " + unit.cooldown);
                check(acc.actionsPlaced.has(uid), "Agent " + cmd.agentID + " sent an extra command. Unit can perform only one action at a time");
                check(!Object.values(Game.DIRECTIONS).includes(direction), "Agent " + cmd.agentID + " tried to move unit " + uid + " in invalid direction " + direction);
                if (direction !== Game.DIRECTIONS.CENTER) {
                    var newpos = unit.pos.translate(direction, 1);
                    check(!this.map.inMap(newpos), "Agent " + cmd.agentID + " tried to move unit " + uid + " off map");
                    check(this.map.getCellByPos(newpos).isCityTile() &&
                        this.map.getCellByPos(newpos).citytile.team !== team, "Agent " + cmd.agentID + " tried to move unit " + uid + " onto opponent CityTile");
                }
                acc.actionsPlaced.add(uid);
                return new Actions_1.MoveAction(action, team, uid, direction, this.map.getCellByPos(unit.pos.translate(direction, 1)));
            }
            case Game.ACTIONS.RESEARCH: {
                check(args.length !== 2, malformedMsg, false);
                var x = parseInt(args[0]);
                var y = parseInt(args[1]);
                check(isNaN(x) || isNaN(y) || !this.map.inMap(new position_1.Position(x, y)), "Agent " + cmd.agentID + " tried to run research at invalid coordinates");
                // check if being researched on owned city tile
                var cell = this.map.getCell(x, y);
                // invalid if not a city or not owned
                check(!cell.isCityTile() || cell.citytile.team !== team, "Agent " + cmd.agentID + " tried to run research at CityTile (" + x + ", " + y + ") that it does not own");
                var citytile = cell.citytile;
                check(!citytile.canResearch(), "Agent " + cmd.agentID + " tried to run research at CityTile (" + x + ", " + y + ") but CityTile still on cooldown " + citytile.cooldown, true);
                check(acc.actionsPlaced.has(citytile.getTileID()), "Agent " + cmd.agentID + " sent an extra command. CityTile can perform only one action at a time");
                acc.actionsPlaced.add(citytile.getTileID());
                return new Actions_1.ResearchAction(action, team, x, y);
            }
            case Game.ACTIONS.TRANSFER: {
                check(args.length !== 4, malformedMsg, false);
                var srcID = args[0];
                var destID = args[1];
                var resourceType = args[2];
                var amount = parseInt(args[3]);
                check(!teamState.units.has(srcID), "Agent " + cmd.agentID + " does not own source unit: " + srcID + " for transfer");
                check(!teamState.units.has(destID), "Agent " + cmd.agentID + " does not own destination unit: " + destID + " for transfer");
                check(!teamState.units.get(srcID).canAct(), "Agent " + cmd.agentID + " tried to transfer resources with cooldown: " + teamState.units.get(srcID).cooldown);
                check(acc.actionsPlaced.has(srcID), "Agent " + cmd.agentID + " sent an extra command. Unit can perform only one action at a time");
                var srcUnit = teamState.units.get(srcID);
                var destUnit = teamState.units.get(destID);
                check(srcID === destID, "Agent " + cmd.agentID + " tried to transfer between the same unit " + srcID);
                check(!srcUnit.pos.isAdjacent(destUnit.pos), "Agent " + cmd.agentID + " tried to transfer between non-adjacent units: " + srcID + ", " + destID);
                check(isNaN(amount) || amount < 0, "Agent " + cmd.agentID + " tried to transfer invalid amount: " + amount);
                check(!Object.values(Resource_1.Resource.Types).includes(resourceType), //needs TS syntax check
                "Agent " + cmd.agentID + " tried to transfer invalid resource: " + resourceType);
                acc.actionsPlaced.add(srcID);
                return new Actions_1.TransferAction(action, team, srcID, destID, resourceType, amount);
            }
        }
        check(true, malformedMsg, false);
    };
    Game.prototype.workerUnitCapReached = function (team, offset) {
        if (offset === void 0) { offset = 0; }
        var teamCityTilesCount = 0;
        this.cities.forEach(function (city) {
            if (city.team === team) {
                teamCityTilesCount += city.citycells.length;
            }
        });
        return (this.state.teamStates[team].units.size + offset >= teamCityTilesCount);
    };
    Game.prototype.cartUnitCapReached = function (team, offset) {
        if (offset === void 0) { offset = 0; }
        var teamCityTilesCount = 0;
        this.cities.forEach(function (city) {
            if (city.team === team) {
                teamCityTilesCount += city.citycells.length;
            }
        });
        return (this.state.teamStates[team].units.size + offset >= teamCityTilesCount);
    };
    Game.prototype.spawnWorker = function (team, x, y, unitid) {
        var cell = this.map.getCell(x, y);
        var unit = new Unit_2.Worker(x, y, team, this.configs, this.globalUnitIDCount + 1);
        if (unitid) {
            unit.id = unitid;
        }
        else
            this.globalUnitIDCount++;
        cell.units.set(unit.id, unit);
        this.state.teamStates[team].units.set(unit.id, unit);
        this.stats.teamStats[team].workersBuilt += 1;
        return unit;
    };
    Game.prototype.spawnCart = function (team, x, y, unitid) {
        var cell = this.map.getCell(x, y);
        var unit = new Unit_2.Cart(x, y, team, this.configs, this.globalUnitIDCount + 1);
        if (unitid) {
            unit.id = unitid;
        }
        else
            this.globalUnitIDCount++;
        cell.units.set(unit.id, unit);
        this.state.teamStates[team].units.set(unit.id, unit);
        this.stats.teamStats[team].cartsBuilt += 1;
        return unit;
    };
    /**
     * Spawn city tile for a team at (x, y). Can pass cityid to use an existing city id
     */
    Game.prototype.spawnCityTile = function (team, x, y, cityid) {
        var _this = this;
        var cell = this.map.getCell(x, y);
        // now update the cities field accordingly
        var adjCells = this.map.getAdjacentCells(cell);
        var cityIdsFound = new Set();
        var adjSameTeamCityTiles = adjCells.filter(function (cell) {
            if (cell.isCityTile() && cell.citytile.team === team) {
                cityIdsFound.add(cell.citytile.cityid);
                return true;
            }
            return false;
        });
        // if no adjacent city cells of same team, generate new city
        if (adjSameTeamCityTiles.length === 0) {
            var city = new city_1.City(team, this.configs, this.globalCityIDCount + 1);
            if (cityid) {
                city.id = cityid;
            }
            else {
                this.globalCityIDCount++;
            }
            cell.setCityTile(team, city.id);
            city.addCityTile(cell);
            this.cities.set(city.id, city);
            return cell.citytile;
        }
        // otherwise add tile to city
        else {
            var cityid_1 = adjSameTeamCityTiles[0].citytile.cityid;
            var city_2 = this.cities.get(cityid_1);
            cell.setCityTile(team, cityid_1);
            // update adjacency counts for bonuses
            cell.citytile.adjacentCityTiles = adjSameTeamCityTiles.length;
            adjSameTeamCityTiles.forEach(function (adjCell) {
                adjCell.citytile.adjacentCityTiles += 1;
            });
            city_2.addCityTile(cell);
            // update all merged cities' cells with merged cityid, move to merged city and delete old city
            cityIdsFound.forEach(function (id) {
                if (id !== cityid_1) {
                    var oldcity = _this.cities.get(id);
                    oldcity.citycells.forEach(function (cell) {
                        cell.citytile.cityid = cityid_1;
                        city_2.addCityTile(cell);
                    });
                    city_2.fuel += oldcity.fuel;
                    _this.cities.delete(oldcity.id);
                }
            });
            return cell.citytile;
        }
    };
    Game.prototype.runCooldowns = function () {
        var _this = this;
        [Unit_1.Unit.TEAM.A, Unit_1.Unit.TEAM.B].forEach(function (team) {
            var units = _this.getTeamsUnits(team);
            units.forEach(function (unit) {
                unit.cooldown -= _this.map.getCellByPos(unit.pos).getRoad();
                unit.cooldown = Math.max(unit.cooldown - 1, 0);
            });
        });
    };
    /**
     * Move specified unit in specified direction
     */
    Game.prototype.moveUnit = function (team, unitid, direction) {
        var unit = this.getUnit(team, unitid);
        // remove unit from old cell and move to new one and update unit pos
        this.map.getCellByPos(unit.pos).units.delete(unit.id);
        unit.pos = unit.pos.translate(direction, 1);
        this.map.getCellByPos(unit.pos).units.set(unit.id, unit);
    };
    Game.prototype.distributeAllResources = function () {
        var miningOrder = [
            Resource_1.Resource.Types.URANIUM,
            Resource_1.Resource.Types.COAL,
            Resource_1.Resource.Types.WOOD,
        ];
        for (var _i = 0, miningOrder_1 = miningOrder; _i < miningOrder_1.length; _i++) {
            var curType = miningOrder_1[_i];
            this.handleResourceTypeRelease(curType);
        }
    };
    Game.prototype.resourceMiningRate = function (type) {
        switch (type) {
            case Resource_1.Resource.Types.WOOD:
                return this.configs.parameters.WORKER_COLLECTION_RATE.WOOD;
            case Resource_1.Resource.Types.COAL:
                return this.configs.parameters.WORKER_COLLECTION_RATE.COAL;
            case Resource_1.Resource.Types.URANIUM:
                return this.configs.parameters.WORKER_COLLECTION_RATE.URANIUM;
        }
    };
    Game.prototype.resourceConversionRate = function (type) {
        switch (type) {
            case Resource_1.Resource.Types.WOOD:
                return this.configs.parameters.RESOURCE_TO_FUEL_RATE.WOOD;
            case Resource_1.Resource.Types.COAL:
                return this.configs.parameters.RESOURCE_TO_FUEL_RATE.COAL;
            case Resource_1.Resource.Types.URANIUM:
                return this.configs.parameters.RESOURCE_TO_FUEL_RATE.URANIUM;
        }
    };
    /**
     * For each unit, check current and orthoganally adjancent cells for that resource
     * type. If found, request as much as we can carry from these cells. In the case of un-even
     * amounts, the unit will request an equal amount from all tiles to fill their cargo, then
     * discard the rest. (for example on 3 wood tiles with 60 wood it would request 17 to each
     * wood tile and discard/waste the extra 1 wood mined).
     *
     * If the unit is on a city tile, only one request will be made (even if there are
     * multiple workers on the tile )and the resources will be deposited into the city as fuel.
     *
     * Once all units have requested resources, distrubte the resources, reducing requests
     * requests if it would exceed the current value. In this case the remaining
     * will be distributed evenly, with the leftovers discarded.
     *
     * @param resourceType - the type of the resource
     */
    Game.prototype.handleResourceTypeRelease = function (resourceType) {
        // build up the resource requests
        var requests = this.createResourceRequests(resourceType);
        // resolve resource requests
        this.resolveResourceRequests(resourceType, requests);
    };
    Game.prototype.createResourceRequests = function (resourceType) {
        var _this = this;
        var miningRate = this.resourceMiningRate(resourceType);
        var reqs = new Map();
        [Unit_1.Unit.TEAM.A, Unit_1.Unit.TEAM.B].forEach(function (team) {
            var units = _this.getTeamsUnits(team);
            if (!_this.state.teamStates[team].researched[resourceType]) {
                return;
            }
            units.forEach(function (unit) {
                if (unit.type !== Unit_1.Unit.Type.WORKER) {
                    return;
                }
                var minable = Game.ALL_DIRECTIONS.map(function (dir) { return unit.pos.translate(dir); }).filter(function (pos) {
                    var _a;
                    if (!_this.map.inMap(pos))
                        return false;
                    var cell = _this.map.getCellByPos(pos);
                    if (!cell.hasResource())
                        return false;
                    return ((_a = cell.resource) === null || _a === void 0 ? void 0 : _a.type) === resourceType && cell.resource.amount > 0;
                }).map((function (pos) { return _this.map.getCellByPos(pos); }));
                var mineAmount = Math.min(Math.ceil(unit.getCargoSpaceLeft() / minable.length), miningRate);
                minable.forEach(function (cell) {
                    if (!reqs.has(cell.pos.toString())) {
                        reqs.set(cell.pos.toString(), []);
                    }
                    var unitCell = _this.map.getCellByPos(unit.pos);
                    var req = new ResourceRequest(unit.pos, mineAmount, unitCell.isCityTile() ? undefined : unit, // should be city tile
                    unitCell.isCityTile() ? _this.cities.get(unitCell.citytile.cityid) : undefined);
                    var hasReq = reqs.get(cell.pos.toString()).some(function (r) { return r.equals(req); });
                    if (!hasReq) {
                        reqs.get(cell.pos.toString()).push(req);
                    }
                });
            });
        });
        return reqs;
    };
    Game.prototype.resolveResourceRequests = function (resourceType, requests) {
        var _this = this;
        requests.forEach(function (reqs, posStr) {
            var position = position_1.Position.fromString(posStr);
            var amountLeft = _this.map.getCell(position.x, position.y).resource.amount;
            var amountsReqs = reqs.map(function (r) { return [r.amount, r]; });
            var _loop_1 = function () {
                // calculate the smallest amount we should fill
                // should be equal to the lowest request, or the amount that 
                // mines out the tile
                // ie if you have three requests [10, 20, 20] fill 10 first
                var toFill = Math.min(Math.min.apply(Math, (amountsReqs.map(function (e) { return e[0]; }))), Math.floor(amountLeft / amountsReqs.length));
                amountsReqs.map(function (e) { return e[1]; }).forEach(function (r) {
                    if (r.city) {
                        _this.stats.teamStats[r.city.team].resourcesCollected[resourceType] += toFill;
                        r.city.fuel += toFill * _this.resourceConversionRate(resourceType);
                    }
                    else {
                        var toGive = Math.min(r.worker.getCargoSpaceLeft(), toFill);
                        _this.stats.teamStats[r.worker.team].resourcesCollected[resourceType] += (toGive);
                        r.worker.cargo[resourceType] += toGive;
                    }
                });
                amountsReqs = amountsReqs.map(function (_a) {
                    var amount = _a[0], req = _a[1];
                    return [amount - toFill, req];
                });
                amountLeft -= toFill * amountsReqs.length;
                if (amountLeft < amountsReqs.length) {
                    amountLeft = 0;
                }
                amountsReqs = amountsReqs.filter(function (_a) {
                    var amount = _a[0], _ = _a[1];
                    return amount > 0;
                });
            };
            while (amountsReqs.length > 0 && amountsReqs.map(function (e) { return e[0]; }).reduce(function (a, b) { return a + b; }) > 0 && amountLeft > 0) {
                _loop_1();
            }
            // set the remaining amount to be the new cell total
            var cell = _this.map.getCellByPos(position);
            cell.resource.amount = amountLeft;
        });
    };
    /**
     * Auto deposit resources of unit to tile it is on
     */
    Game.prototype.handleResourceDeposit = function (unit) {
        var cell = this.map.getCellByPos(unit.pos);
        if (cell.isCityTile() && cell.citytile.team === unit.team) {
            var city = this.cities.get(cell.citytile.cityid);
            var fuelGained = 0;
            fuelGained +=
                unit.cargo.wood * this.configs.parameters.RESOURCE_TO_FUEL_RATE.WOOD;
            fuelGained +=
                unit.cargo.coal * this.configs.parameters.RESOURCE_TO_FUEL_RATE.COAL;
            fuelGained +=
                unit.cargo.uranium *
                    this.configs.parameters.RESOURCE_TO_FUEL_RATE.URANIUM;
            city.fuel += fuelGained;
            this.stats.teamStats[unit.team].fuelGenerated += fuelGained;
            unit.cargo = {
                wood: 0,
                uranium: 0,
                coal: 0,
            };
        }
    };
    Game.prototype.getTeamsUnits = function (team) {
        return this.state.teamStates[team].units;
    };
    Game.prototype.getUnit = function (team, unitid) {
        return this.state.teamStates[team].units.get(unitid);
    };
    /**
     * Transfer resouces on a given team between 2 units. This does not check adjacency requirement, but its expected
     * that the 2 units are adjacent. This allows for simultaneous movement of 1 unit and transfer of another
     */
    Game.prototype.transferResources = function (team, srcID, destID, resourceType, amount) {
        var srcunit = this.getUnit(team, srcID);
        var destunit = this.getUnit(team, destID);
        // the amount to actually transfer is the minimum of:
        var transferAmount = Math.min(
        // the amount requested
        amount, 
        // and all that we have if that's less than requested
        srcunit.cargo[resourceType], 
        // and no more than destination-unit's remaining cargo-space
        destunit.getCargoSpaceLeft());
        srcunit.cargo[resourceType] -= transferAmount;
        destunit.cargo[resourceType] += transferAmount;
    };
    /** destroys the city with this id and remove all city tiles */
    Game.prototype.destroyCity = function (cityID) {
        var _this = this;
        var city = this.cities.get(cityID);
        this.cities.delete(cityID);
        city.citycells.forEach(function (cell) {
            cell.citytile = null;
            cell.road = _this.configs.parameters.MIN_ROAD;
        });
    };
    /** destroys the unit with this id and team and removes from tile */
    Game.prototype.destroyUnit = function (team, unitid) {
        var unit = this.getUnit(team, unitid);
        this.map.getCellByPos(unit.pos).units.delete(unitid);
        this.state.teamStates[team].units.delete(unitid);
    };
    /**
     * regenerates trees on map according to the following formula
     * let max_wood_amount be base and the current amount be curr
     *
     * then at the end of each turn after all moves and all resource collection is finished,
     * the wood at a wood tile grows to ceil(min(curr * 1.03, base))
     */
    Game.prototype.regenerateTrees = function () {
        var _this = this;
        this.map.resources
            .filter(function (cell) { return cell.resource.type === 'wood'; })
            .forEach(function (cell) {
            // add this condition so we let forests near a city start large (but not regrow until below a max)
            if (cell.resource.amount < _this.configs.parameters.MAX_WOOD_AMOUNT) {
                cell.resource.amount = Math.ceil(Math.min(cell.resource.amount * _this.configs.parameters.WOOD_GROWTH_RATE, _this.configs.parameters.MAX_WOOD_AMOUNT));
            }
        });
    };
    /**
     * Process given move actions and returns a pruned array of actions that can all be executed with no collisions
     */
    Game.prototype.handleMovementActions = function (actions, match) {
        var _this = this;
        /**
         * Algo:
         *
         * iterate through all moves and store a mapping from cell to the actions that will cause a unit to move there
         *
         * for each cell that has multiple mapped to actions, we remove all actions as that cell is a "bump" cell
         * where no units can get there because they all bumped into each other
         *
         * for all removed actions for that particular cell, find the cell the unit that wants to execute the action is
         * currently at, labeled `origcell`. Revert these removed actions by first getting all the actions mapped from
         * `origcell` and then deleting that mapping, and then recursively reverting the actions mapped from `origcell`
         *
         */
        var cellsToActionsToThere = new Map();
        var movingUnits = new Set();
        actions.forEach(function (action) {
            var newcell = action.newcell;
            var currActions = cellsToActionsToThere.get(newcell);
            if (currActions === undefined) {
                cellsToActionsToThere.set(newcell, [action]);
            }
            else {
                cellsToActionsToThere.set(newcell, __spreadArray(__spreadArray([], currActions), [action]));
            }
            movingUnits.add(action.unitid);
        });
        // reverts a given action such that cellsToActionsToThere has no collisions due to action and all related actions
        var revertAction = function (action) {
            if (match) {
                match.log.warn("" + ("turn " + _this.state.turn + "; Unit " + action.unitid + " collided when trying to move " + action.direction + " to (" + action.newcell.pos.x + ", " + action.newcell.pos.y + ")"));
            }
            var origcell = _this.map.getCellByPos(_this.getUnit(action.team, action.unitid).pos);
            // get the colliding actions caused by a revert of the given action and then delete them from the mapped origcell provided it is not a city tile
            var collidingActions = cellsToActionsToThere.get(origcell);
            if (!origcell.isCityTile()) {
                cellsToActionsToThere.delete(origcell);
                if (collidingActions) {
                    // for each colliding action, revert it.
                    collidingActions.forEach(function (collidingAction) {
                        revertAction(collidingAction);
                    });
                }
            }
        };
        var actionedCells = Array.from(cellsToActionsToThere.keys());
        var _loop_2 = function (cell) {
            var currActions = cellsToActionsToThere.get(cell);
            var actionsToRevert = [];
            if (currActions !== undefined) {
                if (currActions.length > 1) {
                    // only revert actions that are going to the same tile that is not a city
                    // if going to the same city tile, we know those actions are from same team units, and is allowed
                    if (!cell.isCityTile()) {
                        currActions.forEach(function (action) {
                            actionsToRevert.push(action);
                        });
                    }
                }
                else if (currActions.length === 1) {
                    // if there is just one move action, check there isn't a unit on there that is not moving and not a city tile
                    var action = currActions[0];
                    if (!cell.isCityTile()) {
                        if (cell.units.size === 1) {
                            var unitThereIsStill_1 = true;
                            cell.units.forEach(function (unit) {
                                if (movingUnits.has(unit.id)) {
                                    unitThereIsStill_1 = false;
                                }
                            });
                            if (unitThereIsStill_1) {
                                actionsToRevert.push(action);
                            }
                        }
                    }
                }
            }
            // if there are collisions, revert those actions and remove the mapping
            actionsToRevert.forEach(function (action) {
                revertAction(action);
            });
            actionsToRevert.forEach(function (action) {
                cellsToActionsToThere.delete(action.newcell);
            });
        };
        for (var _i = 0, actionedCells_1 = actionedCells; _i < actionedCells_1.length; _i++) {
            var cell = actionedCells_1[_i];
            _loop_2(cell);
        }
        var prunedActions = [];
        cellsToActionsToThere.forEach(function (currActions) {
            prunedActions.push.apply(prunedActions, currActions);
        });
        return prunedActions;
    };
    Game.prototype.isNight = function () {
        var dayLength = this.configs.parameters.DAY_LENGTH;
        var cycleLength = dayLength + this.configs.parameters.NIGHT_LENGTH;
        return this.state.turn % cycleLength >= dayLength;
    };
    Game.prototype.toStateObject = function () {
        var _a;
        var _this = this;
        var cities = {};
        this.cities.forEach(function (city) {
            cities[city.id] = {
                id: city.id,
                fuel: city.fuel,
                lightupkeep: city.getLightUpkeep(),
                team: city.team,
                cityCells: city.citycells.map(function (cell) {
                    return {
                        x: cell.pos.x,
                        y: cell.pos.y,
                        cooldown: cell.citytile.cooldown,
                    };
                }),
            };
        });
        var state = {
            turn: this.state.turn,
            globalCityIDCount: this.globalCityIDCount,
            globalUnitIDCount: this.globalUnitIDCount,
            teamStates: (_a = {},
                _a[Unit_1.Unit.TEAM.A] = {
                    researchPoints: 0,
                    units: {},
                    researched: {
                        wood: true,
                        coal: false,
                        uranium: false,
                    },
                },
                _a[Unit_1.Unit.TEAM.B] = {
                    researchPoints: 0,
                    units: {},
                    researched: {
                        wood: true,
                        coal: false,
                        uranium: false,
                    },
                },
                _a),
            // stats: deepCopy(this.stats),
            map: this.map.toStateObject(),
            cities: cities,
        };
        var teams = [Unit_1.Unit.TEAM.A, Unit_1.Unit.TEAM.B];
        teams.forEach(function (team) {
            _this.state.teamStates[team].units.forEach(function (unit) {
                state.teamStates[team].units[unit.id] = {
                    cargo: utils_1.deepCopy(unit.cargo),
                    cooldown: unit.cooldown,
                    x: unit.pos.x,
                    y: unit.pos.y,
                    type: unit.type,
                };
            });
            state.teamStates[team].researchPoints =
                _this.state.teamStates[team].researchPoints;
            state.teamStates[team].researched = utils_1.deepCopy(_this.state.teamStates[team].researched);
        });
        return state;
    };
    return Game;
}());
exports.Game = Game;
(function (Game) {
    /**
     * All the available agent actions with specifications as to what they do and restrictions.
     */
    var ACTIONS;
    (function (ACTIONS) {
        /**
         * Formatted as `m unitid direction`. unitid should be valid and should have empty space in that direction. moves
         * unit with id unitid in the direction
         */
        ACTIONS["MOVE"] = "m";
        /**
         * Formatted as `r x y`. (x,y) should be an owned city tile, the city tile is commanded to research for
         * the next X turns
         */
        ACTIONS["RESEARCH"] = "r";
        /** Formatted as `bw x y`. (x,y) should be an owned city tile, where worker is to be built */
        ACTIONS["BUILD_WORKER"] = "bw";
        /** Formatted as `bc x y`. (x,y) should be an owned city tile, where the cart is to be built */
        ACTIONS["BUILD_CART"] = "bc";
        /**
         * Formatted as `bcity unitid`. builds city at unitid's pos, unitid should be
         * friendly owned unit that is a worker
         */
        ACTIONS["BUILD_CITY"] = "bcity";
        /**
         * Formatted as `t source_unitid destination_unitid resource_type amount`. Both units in transfer should be
         * adjacent. If command valid, it will transfer as much as possible with a max of the amount specified
         */
        ACTIONS["TRANSFER"] = "t";
        /** formatted as `p unitid`. Unit with the given unitid must be owned and pillages the tile they are on */
        ACTIONS["PILLAGE"] = "p";
        /** formatted as dc <x> <y> */
        ACTIONS["DEBUG_ANNOTATE_CIRCLE"] = "dc";
        /** formatted as dx <x> <y> */
        ACTIONS["DEBUG_ANNOTATE_X"] = "dx";
        /** formatted as dl <x1> <y1> <x2> <y2> */
        ACTIONS["DEBUG_ANNOTATE_LINE"] = "dl";
        /** formatted as dt <x> <y> <message> <fontsize> */
        ACTIONS["DEBUG_ANNOTATE_TEXT"] = "dt";
        /** formatted as dst <message> */
        ACTIONS["DEBUG_ANNOTATE_SIDETEXT"] = "dst";
    })(ACTIONS = Game.ACTIONS || (Game.ACTIONS = {}));
    var DIRECTIONS;
    (function (DIRECTIONS) {
        DIRECTIONS["NORTH"] = "n";
        DIRECTIONS["EAST"] = "e";
        DIRECTIONS["SOUTH"] = "s";
        DIRECTIONS["WEST"] = "w";
        DIRECTIONS["CENTER"] = "c";
    })(DIRECTIONS = Game.DIRECTIONS || (Game.DIRECTIONS = {}));
    Game.ALL_DIRECTIONS = [
        DIRECTIONS.NORTH,
        DIRECTIONS.EAST,
        DIRECTIONS.SOUTH,
        DIRECTIONS.WEST,
        DIRECTIONS.CENTER,
    ];
})(Game = exports.Game || (exports.Game = {}));
exports.Game = Game;
//# sourceMappingURL=index.js.map