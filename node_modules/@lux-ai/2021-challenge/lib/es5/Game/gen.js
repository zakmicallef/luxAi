"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.generateGame = void 0;
var _1 = require(".");
var Resource_1 = require("../Resource");
var Unit_1 = require("../Unit");
var GameMap_1 = require("../GameMap");
var seedrandom_1 = __importDefault(require("seedrandom"));
var position_1 = require("../GameMap/position");
var mapSizes = [12, 16, 24, 32];
var generateGame = function (matchconfigs) {
    if (matchconfigs === void 0) { matchconfigs = {}; }
    var configs = __assign({}, matchconfigs);
    var seed = configs.seed;
    var rng = seedrandom_1.default("gen_" + seed);
    var size = mapSizes[Math.floor(rng() * mapSizes.length)];
    if (configs.width === undefined) {
        // TODO: use rng to get width and heights
        configs.width = size;
    }
    if (configs.height === undefined) {
        configs.height = size;
    }
    var game = new _1.Game(configs);
    var map = game.map;
    var width = map.width;
    var height = map.height;
    if (configs.mapType === GameMap_1.GameMap.Types.DEBUG) {
        // for testing, hardcode wood and coal
        var woodCoords = [
            [3, 3],
            [3, 4],
            [4, 3],
            [5, 6],
            [1, 1],
            [1, 2],
            [1, 3],
            [2, 5],
            [2, 14],
            [2, 13],
            [4, 13],
            [5, 13],
            [5, 12],
            [5, 14],
        ];
        for (var _i = 0, woodCoords_1 = woodCoords; _i < woodCoords_1.length; _i++) {
            var c = woodCoords_1[_i];
            map.addResource(c[0], c[1], Resource_1.Resource.Types.WOOD, 1500);
            map.addResource(width - c[0] - 1, c[1], Resource_1.Resource.Types.WOOD, 1500);
        }
        var coalCoords = [
            [5, 5],
            [6, 5],
            [9, 4],
        ];
        for (var _a = 0, coalCoords_1 = coalCoords; _a < coalCoords_1.length; _a++) {
            var c = coalCoords_1[_a];
            map.addResource(c[0], c[1], Resource_1.Resource.Types.COAL, 300);
            map.addResource(width - c[0] - 1, c[1], Resource_1.Resource.Types.COAL, 300);
        }
        var uCoords = [
            [9, 7],
            [7, 8],
        ];
        for (var _b = 0, uCoords_1 = uCoords; _b < uCoords_1.length; _b++) {
            var c = uCoords_1[_b];
            map.addResource(c[0], c[1], Resource_1.Resource.Types.URANIUM, 30);
            map.addResource(width - c[0] - 1, c[1], Resource_1.Resource.Types.URANIUM, 30);
        }
        // hardcode initial city tiles
        game.spawnCityTile(Unit_1.Unit.TEAM.A, 2, 1);
        game.spawnCityTile(Unit_1.Unit.TEAM.B, width - 3, 1);
        game.spawnWorker(Unit_1.Unit.TEAM.A, 2, 2);
        game.spawnWorker(Unit_1.Unit.TEAM.B, width - 3, 2);
        game.spawnCart(Unit_1.Unit.TEAM.A, 1, 2);
        game.spawnCart(Unit_1.Unit.TEAM.B, width - 2, 2);
    }
    else if (configs.mapType === GameMap_1.GameMap.Types.EMPTY) {
        return game;
    }
    else {
        var symmetry = SYMMETRY.HORIZONTAL;
        var halfWidth = width;
        var halfHeight = height;
        if (rng() < 0.5) {
            symmetry = SYMMETRY.VERTICAL;
            halfWidth = width / 2;
        }
        else {
            halfHeight = height / 2;
        }
        var resourcesMap = generateAllResources(rng, symmetry, width, height, halfWidth, halfHeight);
        var retries = 0;
        while (!validateResourcesMap(resourcesMap)) {
            retries += 1;
            resourcesMap = generateAllResources(rng, symmetry, width, height, halfWidth, halfHeight);
        }
        resourcesMap.forEach(function (row, y) {
            row.forEach(function (val, x) {
                if (val !== null) {
                    map.addResource(x, y, val.type, val.amt);
                }
            });
        });
        var spawnX = Math.floor(rng() * (halfWidth - 1)) + 1;
        var spawnY = Math.floor(rng() * (halfHeight - 1)) + 1;
        while (map.getCell(spawnX, spawnY).hasResource()) {
            spawnX = Math.floor(rng() * (halfWidth - 1)) + 1;
            spawnY = Math.floor(rng() * (halfHeight - 1)) + 1;
        }
        game.spawnWorker(Unit_1.Unit.TEAM.A, spawnX, spawnY);
        game.spawnCityTile(Unit_1.Unit.TEAM.A, spawnX, spawnY);
        if (symmetry === SYMMETRY.HORIZONTAL) {
            game.spawnWorker(Unit_1.Unit.TEAM.B, spawnX, height - spawnY - 1);
            game.spawnCityTile(Unit_1.Unit.TEAM.B, spawnX, height - spawnY - 1);
        }
        else {
            game.spawnWorker(Unit_1.Unit.TEAM.B, width - spawnX - 1, spawnY);
            game.spawnCityTile(Unit_1.Unit.TEAM.B, width - spawnX - 1, spawnY);
        }
        // add at least 3 wood deposits near spawns
        var deltaIndex = Math.floor(rng() * MOVE_DELTAS.length);
        var woodSpawnsDeltas = [
            MOVE_DELTAS[deltaIndex],
            MOVE_DELTAS[(deltaIndex + 1) % MOVE_DELTAS.length],
            MOVE_DELTAS[(deltaIndex + 2) % MOVE_DELTAS.length],
            MOVE_DELTAS[(deltaIndex + 3) % MOVE_DELTAS.length],
            MOVE_DELTAS[(deltaIndex + 4) % MOVE_DELTAS.length],
            MOVE_DELTAS[(deltaIndex + 5) % MOVE_DELTAS.length],
            MOVE_DELTAS[(deltaIndex + 6) % MOVE_DELTAS.length]
        ];
        var count = 0;
        for (var _c = 0, woodSpawnsDeltas_1 = woodSpawnsDeltas; _c < woodSpawnsDeltas_1.length; _c++) {
            var delta = woodSpawnsDeltas_1[_c];
            var nx = spawnX + delta[0];
            var ny = spawnY + delta[1];
            var nx2 = nx;
            var ny2 = ny;
            if (symmetry === SYMMETRY.HORIZONTAL) {
                ny2 = height - ny - 1;
            }
            else {
                nx2 = width - nx - 1;
            }
            if (!map.inMap(new position_1.Position(nx, ny)) ||
                !map.inMap(new position_1.Position(nx2, ny2))) {
                continue;
            }
            if (!map.getCell(nx, ny).hasResource() &&
                map.getCell(nx, ny).citytile === null) {
                count += 1;
                map.addResource(nx, ny, Resource_1.Resource.Types.WOOD, 800);
            }
            if (!map.getCell(nx2, ny2).hasResource() &&
                map.getCell(nx2, ny2).citytile === null) {
                count += 1;
                map.addResource(nx2, ny2, Resource_1.Resource.Types.WOOD, 800);
            }
            if (count == 6)
                break;
        }
        return game;
    }
    return game;
};
exports.generateGame = generateGame;
var SYMMETRY;
(function (SYMMETRY) {
    SYMMETRY[SYMMETRY["HORIZONTAL"] = 0] = "HORIZONTAL";
    SYMMETRY[SYMMETRY["VERTICAL"] = 1] = "VERTICAL";
})(SYMMETRY || (SYMMETRY = {}));
var validateResourcesMap = function (resourcesMap) {
    var data = { wood: 0, coal: 0, uranium: 0 };
    resourcesMap.forEach(function (row, y) {
        row.forEach(function (val, x) {
            if (val !== null) {
                data[resourcesMap[y][x].type] += resourcesMap[y][x].amt;
            }
        });
    });
    if (data.wood < 2000)
        return false;
    if (data.coal < 1500)
        return false;
    if (data.uranium < 300)
        return false;
    return true;
};
var generateAllResources = function (rng, symmetry, width, height, halfWidth, halfHeight) {
    var resourcesMap = [];
    for (var i = 0; i < height; i++) {
        resourcesMap.push([]);
        for (var j = 0; j < width; j++) {
            resourcesMap[i].push(null);
        }
    }
    var woodResourcesMap = generateResourceMap(rng, 0.21, 0.01, halfWidth, halfHeight, { deathLimit: 2, birthLimit: 4 });
    woodResourcesMap.forEach(function (row, y) {
        row.forEach(function (val, x) {
            if (val === 1) {
                var amt = Math.min(300 + Math.floor(rng() * 100), 500);
                resourcesMap[y][x] = { type: Resource_1.Resource.Types.WOOD, amt: amt };
            }
        });
    });
    var coalResourcesMap = generateResourceMap(rng, 0.11, 0.02, halfWidth, halfHeight, { deathLimit: 2, birthLimit: 4 });
    coalResourcesMap.forEach(function (row, y) {
        row.forEach(function (val, x) {
            if (val === 1) {
                var amt = 350 + Math.floor(rng() * 75);
                resourcesMap[y][x] = { type: Resource_1.Resource.Types.COAL, amt: amt };
            }
        });
    });
    var uraniumResourcesMap = generateResourceMap(rng, 0.055, 0.04, halfWidth, halfHeight, { deathLimit: 1, birthLimit: 6 });
    uraniumResourcesMap.forEach(function (row, y) {
        row.forEach(function (val, x) {
            if (val === 1) {
                var amt = 300 + Math.floor(rng() * 50);
                resourcesMap[y][x] = { type: Resource_1.Resource.Types.URANIUM, amt: amt };
            }
        });
    });
    for (var i = 0; i < 10; i++) {
        resourcesMap = gravitateResources(resourcesMap);
    }
    // perturb resources
    for (var y = 0; y < halfHeight; y++) {
        for (var x = 0; x < halfWidth; x++) {
            var resource = resourcesMap[y][x];
            if (resource === null)
                continue;
            for (var _i = 0, MOVE_DELTAS_1 = MOVE_DELTAS; _i < MOVE_DELTAS_1.length; _i++) {
                var d = MOVE_DELTAS_1[_i];
                var nx = x + d[0];
                var ny = y + d[1];
                if (nx < 0 || ny < 0 || nx >= halfHeight || ny >= halfWidth)
                    continue;
                if (rng() < 0.05) {
                    var amt = 300 + Math.floor(rng() * 50);
                    if (resource.type === 'coal') {
                        amt = 350 + Math.floor(rng() * 75);
                    }
                    if (resource.type === 'wood') {
                        amt = Math.min(300 + Math.floor(rng() * 100), 500);
                    }
                    resourcesMap[ny][nx] = { type: resource.type, amt: amt };
                }
            }
        }
    }
    for (var y = 0; y < halfHeight; y++) {
        for (var x = 0; x < halfWidth; x++) {
            var resource = resourcesMap[y][x];
            if (symmetry === SYMMETRY.VERTICAL) {
                resourcesMap[y][width - x - 1] = resource;
            }
            else {
                resourcesMap[height - y - 1][x] = resource;
            }
        }
    }
    return resourcesMap;
};
var generateResourceMap = function (rng, density, densityRange, width, height, golOptions) {
    if (golOptions === void 0) { golOptions = { deathLimit: 2, birthLimit: 4 }; }
    // width, height should represent half of the map
    var DENSITY = density - densityRange / 2 + densityRange * rng();
    var arr = [];
    for (var y = 0; y < height; y++) {
        arr.push([]);
        for (var x = 0; x < width; x++) {
            var type = 0;
            if (rng() < DENSITY) {
                type = 1;
            }
            arr[y].push(type);
        }
    }
    // simulate GOL for 2 rounds
    for (var i = 0; i < 2; i++) {
        simulateGOL(arr, golOptions);
    }
    return arr;
};
var MOVE_DELTAS = [
    [0, 1],
    [-1, 1],
    [-1, 0],
    [-1, -1],
    [0, -1],
    [1, -1],
    [1, 0],
    [1, 1],
];
var simulateGOL = function (arr, options) {
    // high birthlimit = unlikely to deviate from initial random spots
    // high deathlimit = lots of patches die
    var padding = 1;
    var deathLimit = options.deathLimit;
    var birthLimit = options.birthLimit;
    for (var i = padding; i < arr.length - padding; i++) {
        for (var j = padding; j < arr[0].length - padding; j++) {
            var alive = 0;
            for (var k = 0; k < MOVE_DELTAS.length; k++) {
                var delta = MOVE_DELTAS[k];
                var ny = i + delta[1];
                var nx = j + delta[0];
                if (arr[ny][nx] === 1) {
                    alive++;
                }
            }
            if (arr[i][j] == 1) {
                if (alive < deathLimit) {
                    arr[i][j] = 0;
                }
                else {
                    arr[i][j] = 1;
                }
            }
            else {
                if (alive > birthLimit) {
                    arr[i][j] = 1;
                }
                else {
                    arr[i][j] = 0;
                }
            }
        }
    }
};
var kernelForce = function (resourcesMap, rx, ry) {
    var force = [0, 0];
    var resource = resourcesMap[ry][rx];
    var kernelSize = 5;
    for (var y = ry - kernelSize; y < ry + kernelSize; y++) {
        for (var x = rx - kernelSize; x < rx + kernelSize; x++) {
            if (x < 0 || y < 0 || x >= resourcesMap[0].length || y >= resourcesMap.length)
                continue;
            var r2 = resourcesMap[y][x];
            if (r2 !== null) {
                var dx = rx - x;
                var dy = ry - y;
                var mdist = Math.abs(dx) + Math.abs(dy);
                if (r2.type !== resource.type) {
                    if (dx !== 0)
                        force[0] += Math.pow(dx / mdist, 2) * Math.sign(dx);
                    if (dy !== 0)
                        force[1] += Math.pow(dy / mdist, 2) * Math.sign(dy);
                }
                else {
                    if (dx !== 0)
                        force[0] -= Math.pow(dx / mdist, 2) * Math.sign(dx);
                    if (dy !== 0)
                        force[1] -= Math.pow(dy / mdist, 2) * Math.sign(dy);
                }
            }
        }
    }
    return force;
};
/**
 * Gravitate like to like, push different resources away from each other.
 *
 * Add's a force direction to each cell.
 */
var gravitateResources = function (resourcesMap) {
    var newResourcesMap = [];
    for (var y = 0; y < resourcesMap.length; y++) {
        newResourcesMap.push([]);
        for (var x = 0; x < resourcesMap[y].length; x++) {
            newResourcesMap[y].push(null);
            var res = resourcesMap[y][x];
            if (res !== null) {
                var f = kernelForce(resourcesMap, x, y);
                resourcesMap[y][x].force = f;
            }
        }
    }
    for (var y = 0; y < resourcesMap.length; y++) {
        for (var x = 0; x < resourcesMap[y].length; x++) {
            var res = resourcesMap[y][x];
            if (res !== null) {
                var nx = x + Math.sign(res.force[0]) * 1;
                var ny = y + Math.sign(res.force[1]) * 1;
                if (nx < 0)
                    nx = 0;
                if (ny < 0)
                    ny = 0;
                if (nx >= resourcesMap[0].length)
                    nx = resourcesMap[0].length - 1;
                if (ny >= resourcesMap.length)
                    ny = resourcesMap.length - 1;
                if (newResourcesMap[ny][nx] === null) {
                    newResourcesMap[ny][nx] = res;
                }
                else {
                    newResourcesMap[y][x] = res;
                }
            }
        }
    }
    return newResourcesMap;
};
var printMap = function (resourcesMap) {
    for (var y = 0; y < resourcesMap.length; y++) {
        var str = '';
        for (var x = 0; x < resourcesMap[y].length; x++) {
            var res = resourcesMap[y][x];
            if (res === null) {
                str += "0 ".grey;
            }
            else {
                switch (res.type) {
                    case 'wood':
                        str += "X ".yellow;
                        break;
                    case 'coal':
                        str += "X ".black;
                        break;
                    case 'uranium':
                        str += "X ".magenta;
                        break;
                }
            }
        }
        console.log(str);
    }
};
// const rng = seedrandom(`gen_${23122929}`);
// const size = mapSizes[Math.floor(rng() * mapSizes.length)];
// let halfWidth = size;
// let halfHeight = size;
// let symmetry = SYMMETRY.HORIZONTAL;
// if (rng() < 0.5) {
//   symmetry = SYMMETRY.VERTICAL;
//   halfWidth = size / 2;
// } else {
//   halfHeight = size / 2;
// }
// let resourcesMap = generateAllResources(
//   rng,
//   symmetry,
//   size,
//   size,
//   halfWidth,
//   halfHeight
// );
// console.log("Initial Resource Half Map")
// printMap(resourcesMap)
// for (let i = 0; i < 10; i++) {
//   // console.log(resourcesMap[4][0])
//   // console.log("gravitating")
//   if (i %2 == 0) {
//     console.log(`Resource Half Map after ${i + 1} gravitation steps`)
//     resourcesMap = gravitateResources(resourcesMap)
//     printMap(resourcesMap)
//   }
// }
//# sourceMappingURL=gen.js.map