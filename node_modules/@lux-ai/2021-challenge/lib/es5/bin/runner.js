"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.runner = void 0;
var design_1 = require("../design");
var Dimension = __importStar(require("dimensions-ai"));
var DimensionError_1 = require("dimensions-ai/lib/main/DimensionError");
var dimensions_ai_1 = require("dimensions-ai");
var TournamentTypes_1 = require("dimensions-ai/lib/main/Tournament/TournamentTypes");
var runner = function (argv) {
    var maxtime = argv.maxtime;
    var loglevel = Dimension.Logger.LEVEL.INFO;
    switch (argv['loglevel']) {
        case 0:
            loglevel = Dimension.Logger.LEVEL.NONE;
            break;
        case 1:
            loglevel = Dimension.Logger.LEVEL.ERROR;
            break;
        case 2:
            loglevel = Dimension.Logger.LEVEL.INFO;
            break;
        case 3:
            loglevel = Dimension.Logger.LEVEL.DETAIL;
            break;
        case 4:
            loglevel = Dimension.Logger.LEVEL.ALL;
            break;
    }
    var storeLogs = argv.storeLogs;
    var storereplay = argv.storeReplay;
    var statefulReplay = argv.statefulReplay;
    var seed = Math.floor(Math.random() * 1e9);
    if (argv.seed !== undefined) {
        seed = argv.seed;
    }
    var out = argv.out;
    if (argv.out !== undefined) {
        out = argv.out;
    }
    var width = undefined;
    var height = undefined;
    if (argv.width !== undefined) {
        width = argv.width;
    }
    if (argv.height !== undefined) {
        height = argv.height;
    }
    var lux2021 = new design_1.LuxDesign('lux_ai_2021', {
        engineOptions: {
            noStdErr: false,
            timeout: {
                max: maxtime,
            },
            memory: {
                limit: argv.memory * 1024 * 1024
            }
        },
    });
    var dim = Dimension.create(lux2021, {
        name: 'Lux',
        loggingLevel: dimensions_ai_1.Logger.LEVEL.NONE,
        activateStation: false,
        observe: false,
        defaultMatchConfigs: {
            agentOptions: {
                runCommands: { '.py': [argv.python] },
            },
            storeErrorLogs: storeLogs,
        },
    });
    if (argv.tournament) {
        var resultHandler = function (results) {
            // console.log(results)
            return results;
        };
        // console.log(argv._)
        // const competitors = JSON.parse(argv._[0] as string);
        var competitors = [];
        for (var _i = 0, _a = argv._; _i < _a.length; _i++) {
            var file = _a[_i];
            competitors.push({ file: file, name: file });
        }
        var tournament = dim.createTournament(competitors, {
            name: 'Lux AI Season 1 Tournament',
            type: TournamentTypes_1.TournamentType.LADDER,
            rankSystem: argv.rankSystem,
            agentsPerMatch: [2],
            resultHandler: resultHandler,
            loggingLevel: loglevel
        });
        tournament.run({
            tournamentConfigs: {
                maxConcurrentMatches: argv.maxConcurrentMatches,
            },
            consoleDisplay: true,
            defaultMatchConfigs: {
                storeReplay: storereplay,
                statefulReplay: statefulReplay,
                debug: false,
                width: width,
                height: height,
                runProfiler: false,
                debugDelay: 150,
                debugAnnotations: true,
                engineOptions: {
                    noStdErr: false,
                    timeout: {
                        active: true,
                    },
                },
                mapType: 'random',
                loggingLevel: dimensions_ai_1.Logger.LEVEL.NONE,
            },
        });
    }
    else {
        // take in two files
        var file1_1 = argv._[0];
        var file2_1 = argv._[1];
        if (!file1_1 || !file2_1) {
            throw Error('Need two paths to agents');
        }
        dim
            .runMatch([
            { file: file1_1, name: file1_1 },
            { file: file2_1, name: file2_1 },
        ], {
            seed: seed,
            storeReplay: storereplay,
            statefulReplay: statefulReplay,
            out: out,
            debug: false,
            width: width,
            height: height,
            runProfiler: false,
            debugDelay: 150,
            debugAnnotations: true,
            engineOptions: {
                noStdErr: false,
                timeout: {
                    active: true,
                },
            },
            mapType: 'random',
            loggingLevel: loglevel,
        })
            .then(function (r) {
            r.ranks.forEach(function (info) {
                if (info.agentID == 0) {
                    info.name = file1_1;
                }
                else {
                    info.name = file2_1;
                }
            });
            r.seed = seed;
            console.log(r);
        })
            .catch(function (err) {
            if (err instanceof DimensionError_1.MatchDestroyedError) {
                // ignore;
            }
            else {
                dim.cleanup();
                throw err;
            }
        })
            .catch(function (err) {
            console.error(err);
        })
            .finally(function () {
            dim.cleanup();
        });
    }
};
exports.runner = runner;
//# sourceMappingURL=runner.js.map