import { DeepPartial } from '../utils/DeepPartial';
import { Logger } from '../Logger';
import { Match } from '../Match';
import { Station } from '../Station';
import { Design } from '../Design';
import { Tournament } from '../Tournament';
import { Plugin } from '../Plugin';
import { Database } from '../Plugin/Database';
import { Storage } from '../Plugin/Storage';
import { Agent } from '../Agent';
/**
 * Some standard database type strings
 */
export declare enum DatabaseType {
    /**
     * Represents no database used
     */
    NONE = "none",
    /**
     * Represents mongodb database used
     */
    MONGO = "mongo",
    /**
     * Firestore DB is used
     */
    FIRESTORE = "firestore"
}
export declare enum StorageType {
    /**
     * Represents no storage used, all files stored locally on devide
     */
    NONE = "none",
    /**
     * Represents gcloud storage used
     */
    GCLOUD = "gcloud",
    /** Using local file system for storage*/
    FS = "fs-storage"
}
/**
 * An id generated using nanoid
 */
export declare type NanoID = string;
/**
 * Dimension configurations
 */
export interface DimensionConfigs {
    /** Name of the dimension */
    name: string;
    /**
     * Whether or not to activate the Station
     * @default `true`
     */
    activateStation: boolean;
    /**
     * Whether the station should observe this Dimension
     * @default `true`
     */
    observe: boolean;
    /** The logging level for this Dimension */
    loggingLevel: Logger.LEVEL;
    /** The default match configurations to use when creating matches using this Dimension */
    defaultMatchConfigs: DeepPartial<Match.Configs>;
    /** An overriding ID to use for the dimension instead of generating a new one */
    id: NanoID;
    /**
     * Whether to run Dimension in a more secure environment.
     * Requires rbash and setting up users beforehand and running dimensions in sudo mode
     * @default `false`
     */
    secureMode: boolean;
    /**
     * String denoting what kind of backing database is being used
     * @default {@link DatabaseType.NONE}
     */
    backingDatabase: string | DatabaseType;
    /**
     * String denoting what kind of backing storage is being used
     * @default {@link DatabaseType.NONE}
     */
    backingStorage: string | StorageType;
    /**
     * Station configs to use
     */
    stationConfigs: DeepPartial<Station.Configs>;
    /**
     * Whether to create a local temp bot folder. Default True. Required if you are letting Dimensions handle bot downloading, uploading etc.
     * @default `true`
     */
    createBotDirectories: boolean;
}
/**
 * The Dimension framework for intiating a {@link Design} to then run instances of a {@link Match} or
 * {@link Tournament} on.
 */
export declare class Dimension {
    design: Design;
    /**
     * A map of the matches running in this Dimension
     */
    matches: Map<NanoID, Match>;
    /**
     * A map of the tournaments in this Dimension.
     */
    tournaments: Map<NanoID, Tournament>;
    /**
     * This Dimension's name
     */
    name: string;
    /**
     * This dimension's ID. It is always a 6 character NanoID unless overrided through the {@link DimensionConfigs}
     */
    id: NanoID;
    /**
     * Logger
     */
    log: Logger;
    /**
     * The database plugin being used. Allows Dimensions to interact with a database and store {@link Match},
     * {@link Tournament}, and user data, allowing for data persistance across instances.
     */
    databasePlugin: Database;
    /**
     * The storage plugin being used. Allows Dimensions to interact with a storage service and store user object data,
     * particuarly bot file uploads
     */
    storagePlugin: Storage;
    /**
     * The Station associated with this Dimension and current node instance
     */
    static Station: Station;
    /**
     * Stats
     */
    statistics: {
        tournamentsCreated: number;
        matchesCreated: number;
    };
    /**
     * Dimension configs. Set to defaults
     */
    configs: DimensionConfigs;
    /**
     * Indicator of whether cleanup was called already or not
     */
    private cleaningUp;
    constructor(design: Design, configs?: DeepPartial<DimensionConfigs>);
    /**
     * Create a match with the given files and any optional {@link Match.Configs}. Resolves with the initialized
     * {@link Match} object as specified by the {@link Design} of this {@link Dimension}
     *
     * Rejects if an error occurs.
     *
     * @param files - List of files or objects to use to generate agents and use for a new match
     * @param matchOptions - Options for the created match
     * @param configs - Configurations that are {@link Design} dependent
     */
    createMatch(files: Agent.GenerationMetaData_FilesOnly | Agent.GenerationMetaData_CreateMatch, configs?: DeepPartial<Match.Configs>): Promise<Match>;
    /**
     * Runs a match with the given files and any optional {@link Match.Configs}. It rejects if an error occurs. Some
     * errors include {@link MatchDestroyedError} which happens when {@link Match.destroy} is called.
     *
     * This also automatically stores matches into the {@link Database} if database is active and configured to save
     *
     * Resolves with the results of the match as specified by the {@link Design} of this {@link Dimension}
     *
     * @param files - List of files or objects to use to generate agents and use for a new match
     * @param matchOptions - Options for the created match
     * @param configs - Configurations that are `Design` dependent. These configs are passed into `Design.initialize`
     * `Design.update` and `Design.storeResults`
     */
    runMatch(files: Agent.GenerationMetaData_FilesOnly | Agent.GenerationMetaData_CreateMatch, configs?: DeepPartial<Match.Configs>): Promise<any>;
    /**
     * Create a tournament
     *
     * @param files - The initial files to make competitors in this tournament. Can also specify the name and an
     * existingID, which is the playerID. If database is used, this existingID is used to find the assocciated user with
     * this ID.
     *
     * @param configs - Configuration for the tournament
     *
     * @see {@link Tournament} for the different tournament types
     * @returns a Tournament of the specified type
     */
    createTournament(files: Array<string> | Array<{
        file: string;
        name: string;
        existingId?: string;
    }>, configs: Tournament.TournamentConfigsBase): Tournament;
    /**
     * Get the station
     */
    getStation(): Station;
    /**
     * Removes a match by id. Returns true if removed, false if nothing was removed
     */
    removeMatch(matchID: NanoID): Promise<boolean>;
    /**
     * Sets up necessary security and checks if everything is in place
     */
    private setupSecurity;
    /**
     * Generates a 6 character nanoID string for identifying dimensions
     */
    static genDimensionID(): string;
    /**
     * Uses a particular plugin in the dimensions framework.
     *
     * @param plugin - the plugin
     */
    use(plugin: Plugin): Promise<void>;
    /**
     * Returns true if dimension has a database backing it
     */
    hasDatabase(): boolean;
    /**
     * Returns true if dimension has a storage plugin backing it
     */
    hasStorage(): boolean;
    /**
     * Cleanup function that cleans up any resources used and related to this dimension. For use right before
     * process exits and during testing.
     */
    cleanup(): Promise<void>;
    cleanupMatches(): Promise<Array<void>>;
    cleanupTournaments(): Promise<Array<void>>;
}
/**
 * Creates a dimension for use to start matches, run tournaments, etc.
 * @param design - the design to use
 * @param configs - optional configurations for the dimension
 */
export declare function create(design: Design, configs?: DeepPartial<DimensionConfigs>): Dimension;
