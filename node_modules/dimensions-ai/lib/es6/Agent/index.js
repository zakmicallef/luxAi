var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
import path from 'path';
import os from 'os';
import fs from 'fs';
import treekill from 'tree-kill';
import { Logger } from '../Logger';
import { AgentFileError, AgentDirectoryError, AgentMissingIDError, AgentInstallTimeoutError, AgentCompileTimeoutError, AgentCompileError, AgentInstallError, } from '../DimensionError';
import { deepMerge } from '../utils/DeepMerge';
import { processIsRunning, dockerCopy } from '../utils/System';
import { deepCopy } from '../utils/DeepCopy';
import { Stream } from 'stream';
import { EventEmitter } from 'events';
import { isChildProcess, AgentClassTypeGuards } from '../utils/TypeGuards';
import pidusage from 'pidusage';
import DefaultSeccompProfileJSON from '../Security/seccomp/default.json';
import { noop } from '../utils';
import spawn from 'cross-spawn';
import processExists from 'process-exists';
const DefaultSeccompProfileString = JSON.stringify(DefaultSeccompProfileJSON);
const containerBotFolder = '/code';
/**
 * @class Agent
 * @classdesc The agent is what participates in a match and contains details on the files powering the agent, the
 * process associated and many other details.
 *
 * Reads in a file source for the code and copies the bot folder to a temporary directory in secure modes
 * and creates an `Agent` for use in the {@link MatchEngine} and {@link Match}
 *
 * This is a class that should not be broken. If something goes wrong, this should always throw a error. It is
 * expected that agents are used knowing beforehand that the file given is validated
 */
export class Agent extends EventEmitter {
    constructor(file, options, languageSpecificOptions = {}) {
        super();
        /**
         * This agent's ID in a match. It is always a non-negative integer and agents in a match are always numbered
         * `0, 1, 2, ...n` where there are `n` agents.
         */
        this.id = 0;
        /**
         * A tournmanet ID if Agent is generated from within a {@link Tournament}
         */
        this.tournamentID = null;
        /** The command used to run the file */
        this.cmd = null;
        /**
         * The agent's options
         */
        this.options = deepCopy(Agent.OptionDefaults);
        /** internal buffer to store stdout from an agent that has yet to be delimited / used */
        this._buffer = [];
        /** Interval that periodically watches the memory usage of the process associated with this agent */
        this.memoryWatchInterval = null;
        /**
         * The associated process running the Agent
         */
        this.process = null;
        /**
         * Associated docker container running the agent
         */
        this.container = null;
        /**
         * Streams associated with the agent
         */
        this.streams = {
            in: null,
            out: null,
            err: null,
        };
        /**
         * Current status of the agent
         */
        this.status = Agent.Status.UNINITIALIZED;
        /** The commands collected so far for the current move */
        this.currentMoveCommands = [];
        /* istanbul ignore next */
        this._currentMoveResolve = noop; // set as a dummy function
        /** A number that counts the number of times the agent has essentially interacted with the {@link MatchEngine} */
        this.agentTimeStep = 0;
        /** Clears out the timer associated with the agent during a match */
        this._clearTimer = noop;
        this.errorLogWriteStream = null;
        this.log = new Logger();
        /**
         * Key used to retrieve the error logs of this agent
         */
        this.logkey = null;
        /** whether agent is allowed to send commands. Used to help ignore extra output from agents */
        this.allowedToSendCommands = true;
        /** Agent version, used by tournament */
        this.version = 0;
        /** Size of agent's logs so far */
        this._logsize = 0;
        this._trimmed = false;
        /** List of all messages written to this agent are directly pushed to here when in detached mode */
        this.messages = [];
        this.creationDate = new Date();
        this.options = deepMerge(this.options, deepCopy(options));
        this.log.level = this.options.loggingLevel;
        if (!this.options.detached) {
            this.ext = path.extname(file);
            if (languageSpecificOptions[this.ext]) {
                this.options = deepMerge(this.options, deepCopy(languageSpecificOptions[this.ext]));
            }
            this.cwd = path.dirname(file);
            this.src = path.basename(file);
            this.srcNoExt = this.src.slice(0, -this.ext.length);
            // check if folder is valid
            if (!fs.existsSync(this.cwd)) {
                throw new AgentDirectoryError(`${this.cwd} directory does not exist, check if directory provided through the file is correct`, this.id);
            }
            // check if file exists
            if (!fs.existsSync(file)) {
                throw new AgentFileError(`${file} does not exist, check if file path provided is correct`, this.id);
            }
            this.file = file;
            switch (this.ext) {
                case '.py':
                    this.cmd = 'python';
                    break;
                case '.js':
                case '.ts':
                    this.cmd = 'node';
                    break;
                case '.java':
                    this.cmd = 'java';
                    break;
                case '.php':
                    this.cmd = 'php';
                    break;
                case '.c':
                case '.cpp':
                case '.go':
                    this.cmd = '';
                    break;
                default:
            }
        }
        if (this.options.id !== null) {
            this.id = options.id;
        }
        else {
            throw new AgentMissingIDError(`No id provided for agent using ${file}`, this.id);
        }
        if (this.options.name) {
            this.name = this.options.name;
        }
        else {
            this.name = `agent_${this.id}`;
        }
        if (this.options.tournamentID) {
            this.tournamentID = options.tournamentID;
            this.name = this.tournamentID.name;
        }
        this.log.system(`Created agent: ${this.name}`);
        // set agent as ready
        this.status = Agent.Status.READY;
    }
    setupContainer(name, docker, engineOptions) {
        return __awaiter(this, void 0, void 0, function* () {
            const HostConfig = {
                // apply seccomp profile for security
                SecurityOpt: [`seccomp=${DefaultSeccompProfileString}`],
            };
            if (engineOptions.memory.active) {
                HostConfig.Memory = engineOptions.memory.limit;
            }
            const container = yield docker.createContainer({
                Image: this.options.image,
                name: name,
                OpenStdin: true,
                StdinOnce: true,
                HostConfig,
            });
            this.log.system(`Created container ${name}`);
            // store container
            this.container = container;
            yield container.start();
            this.log.system(`Started container ${name}`);
            // copy bot directory into container
            yield dockerCopy(this.cwd + '/.', name, '/code');
            this.log.system(`Copied bot into container ${name}`);
        });
    }
    /**
     * Install whatever is needed through a `install.sh` file in the root of the bot folder
     */
    _install(stderrWritestream, stdoutWritestream, engineOptions) {
        // eslint-disable-next-line no-async-promise-executor
        return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
            // if there is a install.sh file, use it
            if (fs.existsSync(path.join(this.cwd, 'install.sh'))) {
                let stdout;
                let stderr;
                const installTimer = setTimeout(() => {
                    const msg = 'Agent went over install time during the install stage\n';
                    this.writeToErrorLog(msg);
                    reject(new AgentInstallTimeoutError(msg, this.id));
                }, this.options.maxInstallTime);
                const chunks = [];
                const handleClose = (code) => {
                    clearTimeout(installTimer);
                    if (code === 0) {
                        resolve();
                    }
                    else {
                        let msg = `A install time error occured. Install step for agent ${this.id} exited with code: ${code}; Installing ${path.join(this.cwd, 'install.sh')}; Install Output:\n${chunks.join('')}`;
                        if (code === 137) {
                            msg += `\nAgent likely ran out of memory, exceeded ${engineOptions.memory.limit / 1000000} MB`;
                        }
                        this.writeToErrorLog(msg + '\n');
                        reject(new AgentInstallError(msg, this.id));
                    }
                };
                const handleError = (err) => {
                    clearTimeout(installTimer);
                    reject(err);
                };
                if (this.options.secureMode) {
                    try {
                        const exec = yield this.container.exec({
                            Cmd: ['/bin/sh', '-c', 'chmod u+x install.sh'],
                            WorkingDir: containerBotFolder,
                        });
                        yield exec.start({});
                        const data = yield this.containerSpawn(path.join(containerBotFolder, 'install.sh'));
                        stderr = data.err;
                        stdout = data.out;
                        data.stream.on('end', () => __awaiter(this, void 0, void 0, function* () {
                            const endRes = yield data.exec.inspect();
                            handleClose(endRes.ExitCode);
                        }));
                        data.stream.on('error', (err) => {
                            handleError(err);
                        });
                    }
                    catch (err) {
                        handleError(err);
                        return;
                    }
                }
                else {
                    const p = spawn('sh', ['install.sh'], {
                        cwd: this.cwd,
                    });
                    p.on('error', (err) => {
                        handleError(err);
                    });
                    p.on('close', (code) => {
                        handleClose(code);
                    });
                    stderr = p.stderr;
                    stdout = p.stdout;
                }
                stdout.on('data', (chunk) => {
                    chunks.push(chunk);
                });
                stderr.on('data', (chunk) => {
                    chunks.push(chunk);
                });
                if (stderrWritestream) {
                    stderr.pipe(stderrWritestream, {
                        end: false,
                    });
                }
                if (stdoutWritestream) {
                    stdout.pipe(stdoutWritestream, {
                        end: false,
                    });
                }
            }
            else {
                resolve();
            }
        }));
    }
    /**
     * Compile whatever is needed and validate files. Called by {@link MatchEngine} and has a timer set by the
     * maxCompileTime option in {@link Agent.Options}
     */
    _compile(stderrWritestream, stdoutWritestream, engineOptions) {
        return __awaiter(this, void 0, void 0, function* () {
            // eslint-disable-next-line no-async-promise-executor
            return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
                let p;
                let stdout;
                let stderr;
                const compileTimer = setTimeout(() => {
                    const msg = 'Agent went over compile time during the compile stage\n';
                    this.writeToErrorLog(msg);
                    reject(new AgentCompileTimeoutError(msg, this.id));
                }, this.options.maxCompileTime);
                if (this.options.compileCommands[this.ext]) {
                    const cmd1 = this.options.compileCommands[this.ext][0];
                    const restofCmds = this.options.compileCommands[this.ext].slice(1);
                    p = yield this._spawnCompileProcess(cmd1, [...restofCmds, this.src]);
                }
                else {
                    switch (this.ext) {
                        case '.py':
                        case '.php':
                        case '.js':
                            clearTimeout(compileTimer);
                            resolve();
                            return;
                        case '.ts':
                            // expect user to provide a tsconfig.json
                            p = yield this._spawnCompileProcess('tsc', []);
                            break;
                        case '.go':
                            p = yield this._spawnCompileProcess('go', [
                                'build',
                                '-o',
                                `${this.srcNoExt}.out`,
                                this.src,
                            ]);
                            break;
                        case '.cpp':
                            p = yield this._spawnCompileProcess('g++', [
                                '-std=c++11',
                                '-O3',
                                '-o',
                                `${this.srcNoExt}.out`,
                                this.src,
                            ]);
                            break;
                        case '.c':
                            p = yield this._spawnCompileProcess('gcc', [
                                '-O3',
                                '-o',
                                `${this.srcNoExt}.out`,
                                this.src,
                            ]);
                            break;
                        case '.java':
                            p = yield this._spawnCompileProcess('javac', [this.src]);
                            break;
                        default:
                            this.log.system(`${this.ext} not recognized, skipping compilation`);
                            // reject(
                            //   new NotSupportedError(
                            //     `Language with extension ${this.ext} is not supported at the moment`
                            //   )
                            // );
                            clearTimeout(compileTimer);
                            resolve();
                            return;
                    }
                }
                const chunks = [];
                const handleClose = (code) => {
                    clearTimeout(compileTimer);
                    if (code === 0) {
                        resolve();
                    }
                    else {
                        let msg = `A compile time error occured. Compile step for agent ${this.id} exited with code: ${code}; Compiling ${this.file}; Compile Output:\n${chunks.join('')}`;
                        if (code === 137) {
                            msg += `\nAgent likely ran out of memory, exceeded ${engineOptions.memory.limit / 1000000} MB`;
                        }
                        this.writeToErrorLog(msg + '\n');
                        reject(new AgentCompileError(msg, this.id));
                    }
                };
                const handleError = (err) => {
                    clearTimeout(compileTimer);
                    reject(err);
                };
                if (isChildProcess(p)) {
                    stdout = p.stdout;
                    stderr = p.stderr;
                    p.on('error', (err) => {
                        handleError(err);
                    });
                    p.on('close', (code) => {
                        handleClose(code);
                    });
                }
                else {
                    stdout = p.out;
                    stderr = p.err;
                    const containerExec = p.exec;
                    p.stream.on('error', (err) => {
                        handleError(err);
                    });
                    p.stream.on('end', () => __awaiter(this, void 0, void 0, function* () {
                        const endRes = yield containerExec.inspect();
                        handleClose(endRes.ExitCode);
                    }));
                }
                stdout.on('data', (chunk) => {
                    chunks.push(chunk);
                });
                stderr.on('data', (chunk) => {
                    chunks.push(chunk);
                });
                if (stderrWritestream) {
                    stderr.pipe(stderrWritestream, {
                        end: false,
                    });
                }
                if (stdoutWritestream) {
                    stdout.pipe(stdoutWritestream, {
                        end: false,
                    });
                }
            }));
        });
    }
    /**
     * Spawns the compilation process
     * @param command - command to compile with
     * @param args - argument for the compilation
     */
    _spawnCompileProcess(command, args) {
        return __awaiter(this, void 0, void 0, function* () {
            return new Promise((resolve, reject) => {
                if (this.options.secureMode) {
                    this.containerSpawn(`${command} ${args.join(' ')}`, containerBotFolder)
                        .then(resolve)
                        .catch(reject);
                }
                else {
                    const p = spawn(command, [...args], {
                        cwd: this.cwd,
                    }).on('error', (err) => {
                        reject(err);
                    });
                    resolve(p);
                }
            });
        });
    }
    /**
     * Executes the given command string in the agent's container and attaches stdin, stdout, and stderr accordingly
     * @param command - the command to execute in the container
     */
    containerSpawn(command, workingDir = '/') {
        return __awaiter(this, void 0, void 0, function* () {
            const exec = yield this.container.exec({
                Cmd: ['/bin/sh', '-c', command],
                AttachStdin: true,
                AttachStdout: true,
                AttachStderr: true,
                WorkingDir: workingDir,
            });
            const stream = yield exec.start({ stdin: true, hijack: true });
            const instream = new Stream.PassThrough();
            const outstream = new Stream.PassThrough();
            const errstream = new Stream.PassThrough();
            instream.pipe(stream);
            this.container.modem.demuxStream(stream, outstream, errstream);
            return {
                in: instream,
                out: outstream,
                err: errstream,
                stream,
                exec,
            };
        });
    }
    /**
     * Spawn the process and return the process
     */
    _spawn() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.options.runCommands[this.ext]) {
                return this._spawnProcess(this.options.runCommands[this.ext][0], [
                    ...this.options.runCommands[this.ext].slice(1),
                    this.src,
                ]);
            }
            else {
                switch (this.ext) {
                    case '.py':
                    case '.js':
                    case '.php': {
                        const p = this._spawnProcess(this.cmd, [this.src]);
                        return p;
                    }
                    case '.ts':
                        return this._spawnProcess(this.cmd, [this.srcNoExt + '.js']);
                    case '.java':
                        return this._spawnProcess(this.cmd, [this.srcNoExt]);
                    case '.c':
                    case '.cpp':
                    case '.go':
                        return this._spawnProcess('./' + this.srcNoExt + '.out', []);
                    default:
                        this.log.system(`${this.ext} not recognized, directly executing file`);
                        return this._spawnProcess('./' + this.src, []);
                    // throw new NotSupportedError(
                    //   `Language with extension ${this.ext} is not supported yet`
                    // );
                }
            }
        });
    }
    /**
     * Spawns process in this.cwd accordingly and uses the configs accordingly.
     * Resolves with the process if spawned succesfully
     *
     * Note, we are spawning detached so we can kill off all sub processes if they are made. See {@link _terminate} for
     * explanation
     */
    _spawnProcess(command, args) {
        return new Promise((resolve, reject) => {
            if (this.options.secureMode) {
                this.containerSpawn(`${command} ${args.join(' ')}`, containerBotFolder)
                    .then(resolve)
                    .catch(reject);
            }
            else {
                const p = spawn(command, args, {
                    cwd: this.cwd,
                    detached: false,
                }).on('error', (err) => {
                    reject(err);
                });
                resolve(p);
            }
        });
    }
    /**
     * Stop an agent provided it is not terminated. To terminate it, see {@link _terminate};
     */
    stop() {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.isTerminated()) {
                if (this.options.secureMode) {
                    yield this.container.pause();
                }
                else {
                    if (os.platform() !== 'win32') {
                        this.process.kill('SIGSTOP');
                    }
                }
                this.status = Agent.Status.STOPPED;
            }
        });
    }
    /**
     * Resume an agent as long it is not terminated already
     */
    resume() {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.isTerminated()) {
                this._allowCommands();
                if (this.options.secureMode) {
                    // await this.container.unpause();
                }
                else {
                    if (os.platform() !== 'win32') {
                        this.process.kill('SIGCONT');
                    }
                }
                this.status = Agent.Status.RUNNING;
            }
        });
    }
    /**
     * timeout the agent
     */
    timeout() {
        const msg = 'Agent timed out';
        this.writeToErrorLog(msg);
        this.emit(Agent.AGENT_EVENTS.TIMEOUT);
    }
    /**
     * call out agent for exceeding memory limit
     */
    overMemory() {
        const msg = 'Agent exceeded memory limit';
        this.writeToErrorLog(msg);
        this.emit(Agent.AGENT_EVENTS.EXCEED_MEMORY_LIMIT);
    }
    /**
     * Whether or not input is destroyed
     */
    inputDestroyed() {
        return this.streams.in.destroyed;
    }
    /**
     * Write to stdin of the process associated with the agent
     * @param message - the message
     * @param callback - callback function
     *
     * returns true if written, false if highWaterMark reached
     */
    write(message, callback) {
        // in detached mode, simply keep track of messages sent.
        if (this.options.detached) {
            this.messages.push(message);
            process.nextTick(callback);
            return true;
        }
        /**
         * the following few lines are based on the suggestion at
         * https://nodejs.org/api/stream.html#stream_writable_write_chunk_encoding_callback
         */
        if (!this.streams.in.write(message)) {
            return false;
        }
        else {
            process.nextTick(callback);
        }
        return true;
    }
    writeToErrorLog(message) {
        if (this.errorLogWriteStream) {
            this._logsize += message.length;
            this.errorLogWriteStream.write(message);
        }
    }
    /**
     * Get process of agent
     */
    _getProcess() {
        return this.process;
    }
    /**
     * Store process for agent
     * @param p - process to store
     */
    _storeProcess(p) {
        this.process = p;
    }
    /**
     * Returns true if this agent was terminated and no longer send or receive emssages
     */
    isTerminated() {
        return this.status === Agent.Status.KILLED;
    }
    /**
     * Terminates this agent by stopping all related processes and remove any temporary directory. this is the only function allowed to
     * set the status value to killed.
     */
    _terminate() {
        this.status = Agent.Status.KILLED;
        // eslint-disable-next-line no-async-promise-executor
        return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
            if (this.options.secureMode) {
                if (this.container) {
                    try {
                        const ins = yield this.container.inspect();
                        this._clearTimer();
                        clearInterval(this.memoryWatchInterval);
                        if (ins.State.Running) {
                            yield this.container.kill();
                            yield this.container.remove();
                        }
                        resolve();
                    }
                    catch (err) {
                        if (err.statusCode !== 409 && err.reason !== 'no such container') {
                            reject(err);
                        }
                        else {
                            resolve();
                        }
                    }
                }
                else {
                    resolve();
                }
            }
            else {
                if (this.process) {
                    let exists = true;
                    if (os.platform() === 'win32') {
                        // fix bug where on windows, would throw error when treekill fails
                        exists = yield processExists(this.process.pid);
                    }
                    if (exists) {
                        treekill(this.process.pid, 'SIGKILL', (err) => {
                            this._clearTimer();
                            clearInterval(this.memoryWatchInterval);
                            if (err) {
                                reject(err);
                            }
                            else {
                                resolve();
                            }
                        });
                    }
                }
                else {
                    resolve();
                }
            }
        }));
    }
    /**
     * Disallow an agent from sending more commands
     */
    _disallowCommands() {
        this.allowedToSendCommands = false;
    }
    /**
     * Allow agent to send commands again
     */
    _allowCommands() {
        this.allowedToSendCommands = true;
    }
    /**
     * Check if agent is set to be allowed to send commands. The {@link EngineOptions} affect when this is flipped
     */
    isAllowedToSendCommands() {
        return this.allowedToSendCommands;
    }
    /**
     * Setup the agent timer clear out method
     */
    _setTimeout(fn, delay, ...args) {
        const timer = setTimeout(() => {
            fn(...args);
        }, delay);
        this._clearTimer = () => {
            clearTimeout(timer);
        };
    }
    /**
     * Stop this agent from more outputs and mark it as done for now and awaiting for updates. Effectively force agent to sync with match
     */
    _finishMove() {
        return __awaiter(this, void 0, void 0, function* () {
            this._clearTimer();
            // Resolve move and tell engine in `getCommands` this agent is done outputting commands and awaits input
            this._currentMoveResolve();
            // stop the process for now from sending more output and disallow commmands to ignore rest of output
            if (this.options.secureMode) {
                // TODO: Implement
                // await this.container.pause();
            }
            else {
                if (os.platform() !== 'win32') {
                    this.process.kill('SIGSTOP');
                }
            }
            this._disallowCommands();
        });
    }
    // Start an Agent's move and setup the promise structures
    _setupMove() {
        // allows agent to send commands; increment time; clear past commands; reset the promise structure
        this.allowedToSendCommands = true;
        this.agentTimeStep++;
        this.currentMoveCommands = [];
        this._currentMovePromise = new Promise((resolve, reject) => {
            this._currentMoveResolve = resolve;
            this._currentMoveReject = reject;
        });
    }
    /**
     * Used by {@link MatchEngine} only. Setups the memory watcher if docker is not used.
     * @param engineOptions - engine options to configure the agent with
     */
    _setupMemoryWatcher(engineOptions) {
        const checkAgentMemoryUsage = () => {
            // setting { maxage: 0 } because otherwise pidusage leaves interval "memory leaks" and process doesn't exit fast
            if (os.platform() !== 'win32' && processIsRunning(this.process.pid)) {
                pidusage(this.process.pid, {
                    maxage: 0,
                    usePs: engineOptions.memory.usePs,
                })
                    .then((stat) => {
                    if (stat.memory > engineOptions.memory.limit) {
                        this.overMemory();
                    }
                })
                    .catch((err) => {
                    this.log.system(err);
                });
            }
        };
        checkAgentMemoryUsage();
        this.memoryWatchInterval = setInterval(checkAgentMemoryUsage, engineOptions.memory.checkRate);
    }
    /**
     * Generates a list of agents for use
     * @param files List of files to use to make agents or a list of objects with a file key for the file path to the bot
     *              and a name key for the name of the agent
     * @param options - Options to first override with for all agents
     * @param languageSpecificOptions - Options to second overrided with for agents depending on language
     * @param agentSpecificOptions - Options to lastly override with depending on agent's index
     */
    static generateAgents(files, options, languageSpecificOptions = {}, agentSpecificOptions = []) {
        if (files.length === 0) {
            throw new AgentFileError('No files provided to generate agents with!', -1);
        }
        const agents = [];
        if (AgentClassTypeGuards.isGenerationMetaData_FilesOnly(files)) {
            files.forEach((file, index) => {
                let configs = deepCopy(options);
                configs = deepMerge(configs, deepCopy(agentSpecificOptions[index] ? agentSpecificOptions[index] : {}));
                configs.id = index;
                agents.push(new Agent(file, configs, languageSpecificOptions));
            });
        }
        else if (AgentClassTypeGuards.isGenerationMetaData_CreateMatch(files)) {
            files.forEach((info, index) => {
                let configs = deepCopy(options);
                configs = deepMerge(configs, deepCopy(agentSpecificOptions[index] ? agentSpecificOptions[index] : {}));
                configs.id = index;
                configs.name = info.name;
                agents.push(new Agent(info.file, configs, languageSpecificOptions));
            });
        }
        else {
            files.forEach((info, index) => {
                let configs = deepCopy(options);
                configs = deepMerge(configs, deepCopy(agentSpecificOptions[index] ? agentSpecificOptions[index] : {}));
                configs.id = index;
                configs.tournamentID = info.tournamentID;
                const newAgent = new Agent(info.file, configs, languageSpecificOptions);
                newAgent.version = info.version;
                agents.push(newAgent);
            });
        }
        return agents;
    }
    getAgentErrorLogFilename() {
        return `agent_${this.id}.log`;
    }
}
(function (Agent) {
    /**
     * Status enums for an Agent
     */
    let Status;
    (function (Status) {
        /** When agent is just created */
        Status["UNINITIALIZED"] = "uninitialized";
        /** Agent is ready too be used by the {@link MatchEngine} in a {@link Match} */
        Status["READY"] = "ready";
        /** Agent is currently running */
        Status["RUNNING"] = "running";
        /** Agent crashed somehow */
        Status["CRASHED"] = "crashed";
        /** Agent is finished and no longer in use after {@link Match} ended or was prematurely killed */
        Status["KILLED"] = "killed";
        /** Agent is currently not running */
        Status["STOPPED"] = "stopped";
    })(Status = Agent.Status || (Agent.Status = {}));
    /**
     * Agent events
     */
    let AGENT_EVENTS;
    (function (AGENT_EVENTS) {
        /**
         * Event emitted by process of {@link Agent} when memory limit is exceeded
         */
        AGENT_EVENTS["EXCEED_MEMORY_LIMIT"] = "exceedMemoryLimit";
        /**
         * Event emitted by process of {@link Agent} when it times out.
         */
        AGENT_EVENTS["TIMEOUT"] = "timeout";
        /**
         * event emitted when associated process or container for agent closes and agent effectively is terminated
         */
        AGENT_EVENTS["CLOSE"] = "close";
    })(AGENT_EVENTS = Agent.AGENT_EVENTS || (Agent.AGENT_EVENTS = {}));
    /**
     * Default Agent options
     */
    Agent.OptionDefaults = {
        secureMode: false,
        loggingLevel: Logger.LEVEL.INFO,
        id: null,
        tournamentID: null,
        name: null,
        maxInstallTime: 300000,
        maxCompileTime: 60000,
        runCommands: {},
        compileCommands: {},
        image: 'docker.io/stonezt2000/dimensions_langs',
        useCachedBotFile: false,
        logLimit: 1e5,
        detached: false,
    };
})(Agent || (Agent = {}));
//# sourceMappingURL=index.js.map