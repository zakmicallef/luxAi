var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
import { Storage } from '../../Plugin/Storage';
import { StorageType } from '../../Dimension';
import { Plugin } from '../../Plugin';
import path from 'path';
import { writeFileToDestination, LOCAL_DIR } from '../../utils/System';
import LRUFileCache from '../../utils/LRUFileCache';
import { Logger } from '../../Logger';
import { deepMerge } from '../../utils/DeepMerge';
import { deepCopy } from '../../utils/DeepCopy';
import { copyFileSync } from 'fs';
export class FileSystemStorage extends Storage {
    constructor(configs) {
        super();
        this.name = 'FS-Storage';
        this.type = Plugin.Type.STORAGE;
        this._useCacheCount = 0;
        this.configs = {
            maxCacheSize: 1024 * 1024 * 50,
            cacheDir: 'cache',
            loggingLevel: Logger.LEVEL.INFO,
        };
        this.configs = deepMerge(this.configs, deepCopy(configs));
        this.lruFileCache = new LRUFileCache(this.configs.maxCacheSize, path.join(LOCAL_DIR, this.configs.cacheDir));
        this.log = new Logger(this.configs.loggingLevel, 'FS-Storage');
    }
    /**
     * Initializer. Initializes the storage object and creates necessary buckets
     */
    initialize(dimension) {
        return __awaiter(this, void 0, void 0, function* () {
            const bucketPath = path.join(LOCAL_DIR, dimension.name.toLowerCase().replace(/ /g, '_') +
                '_' +
                dimension.id.toLowerCase());
            this.bucketPath = bucketPath;
        });
    }
    writeFileToBucket(file, dest) {
        return __awaiter(this, void 0, void 0, function* () {
            this.log.system(`writing to bucket ${file} -> ${dest}`);
            yield writeFileToDestination(file, path.join(this.bucketPath, dest));
        });
    }
    writeFileFromBucket(key, dest) {
        return __awaiter(this, void 0, void 0, function* () {
            this.log.system(`writing from bucket ${key} -> ${dest}`);
            yield writeFileToDestination(path.join(this.bucketPath, key), dest);
        });
    }
    uploadTournamentFile(file, user, tournament) {
        return __awaiter(this, void 0, void 0, function* () {
            const dest = `users/${user.username}_${user.playerID}/tournaments/${tournament.getKeyName()}/bot.zip`;
            yield this.writeFileToBucket(file, dest);
            return dest;
        });
    }
    upload(file, destination) {
        return __awaiter(this, void 0, void 0, function* () {
            const dest = `${destination ? destination : path.basename(file)}`;
            yield this.writeFileToBucket(file, dest);
            return dest;
        });
    }
    download(key, destination, useCached) {
        return __awaiter(this, void 0, void 0, function* () {
            if (useCached) {
                // note this scope of code working with the cache is async safe, it won't be interuptted because none of the functions used are async
                const cachedPath = this.lruFileCache.get(key);
                // if there is a cached path, use it
                if (cachedPath) {
                    this._useCacheCount++;
                    // TODO: It would be nice if we could just resolve with the cachedPath and let user use that, but
                    // unfortunately that invokes a race condition where downloading two files causes one file's cache to be
                    // invalidated and thus unretrievable after we give the user the old cachedPath. This race condition shouldn't
                    // happen often, if ever unless there are very little bots and max size is low.
                    // a better optimization would be to
                    copyFileSync(cachedPath, destination);
                    return destination;
                }
            }
            yield this.writeFileFromBucket(key, destination);
            // store in cache
            // eslint-disable-next-line @typescript-eslint/no-unused-vars
            const cachedPath = yield this.lruFileCache.add(key, destination);
            this.log.system(`${key} cached to ${cachedPath}`);
            return destination;
        });
    }
    /**
     * Returns a download URL to use to download an object
     * @param key - key referencing the object to download
     */
    getDownloadURL(key) {
        return __awaiter(this, void 0, void 0, function* () {
            return path.join(this.bucketPath, key);
        });
    }
    manipulate(dimension) {
        return __awaiter(this, void 0, void 0, function* () {
            dimension.configs.backingStorage = StorageType.FS;
            return;
        });
    }
}
//# sourceMappingURL=index.js.map