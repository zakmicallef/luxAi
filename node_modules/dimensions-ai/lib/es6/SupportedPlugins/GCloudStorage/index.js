var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
import { Storage as DStorage } from '../../Plugin/Storage';
import { Storage } from '@google-cloud/storage';
import { StorageType } from '../../Dimension';
import { Plugin } from '../../Plugin';
import path from 'path';
import fs, { copyFileSync } from 'fs';
import LRUFileCache from '../../utils/LRUFileCache';
import { LOCAL_DIR } from '../../utils/System';
import { Logger } from '../../Logger';
import { deepCopy } from '../../utils/DeepCopy';
import { deepMerge } from '../../utils/DeepMerge';
export class GCloudStorage extends DStorage {
    constructor(configs) {
        super();
        this.name = 'GCloudStorage';
        this.type = Plugin.Type.STORAGE;
        this.configs = {
            keyFilename: '',
            projectId: '',
            fileCacheMaxSize: 1024 * 1024 * 1024,
            loggingLevel: Logger.LEVEL.INFO,
            cacheDir: 'cache',
        };
        this.configs = deepMerge(this.configs, deepCopy(configs));
        // default cache size of 1 GB
        this.lruFileCache = new LRUFileCache(this.configs.fileCacheMaxSize, path.join(LOCAL_DIR, this.configs.cacheDir));
        this.log = new Logger(this.configs.loggingLevel, 'GCloud-Storage');
    }
    /**
     * Initializer. Initializes the storage object and creates necessary buckets
     */
    initialize(dimension) {
        return __awaiter(this, void 0, void 0, function* () {
            const bucketName = dimension.name.toLowerCase().replace(/ /g, '_') +
                '_' +
                dimension.id.toLowerCase();
            this.storage = new Storage({
                keyFilename: this.configs.keyFilename,
                projectId: this.configs.projectId,
            });
            const exists = yield this.storage.bucket(bucketName).exists();
            if (!exists[0]) {
                this.log.system(`creating bucket ${bucketName}`);
                yield this.storage.createBucket(bucketName);
            }
            this.dimensionBucket = this.storage.bucket(bucketName);
        });
    }
    uploadTournamentFile(file, user, tournament) {
        return __awaiter(this, void 0, void 0, function* () {
            const dest = `users/${user.username}_${user.playerID}/tournaments/${tournament.getKeyName()}/bot.zip`;
            return this.dimensionBucket
                .upload(file, {
                destination: dest,
            })
                .then(() => {
                this.log.system(`uploaded tournament file for player ${user.playerID} to ${dest}`);
                return dest;
            });
        });
    }
    upload(file, destination) {
        return __awaiter(this, void 0, void 0, function* () {
            const dest = `${destination ? destination : path.basename(file)}`;
            return this.dimensionBucket
                .upload(file, {
                destination: dest,
            })
                .then(() => {
                this.log.system(`uploaded file from ${file} to ${dest}`);
                return dest;
            });
        });
    }
    download(key, destination, useCached) {
        return __awaiter(this, void 0, void 0, function* () {
            return new Promise((resolve) => {
                if (useCached) {
                    const cachedPath = this.lruFileCache.get(key);
                    // if there is a cached path, use it
                    if (cachedPath) {
                        copyFileSync(cachedPath, destination);
                        resolve(destination);
                        return;
                    }
                }
                const file = this.dimensionBucket.file(key);
                const ws = file
                    .createReadStream()
                    .pipe(fs.createWriteStream(destination));
                ws.on('close', () => __awaiter(this, void 0, void 0, function* () {
                    // store in cache
                    const cachedPath = yield this.lruFileCache.add(key, destination);
                    this.log.system(`writing from bucket ${key} -> ${destination}; cached to ${cachedPath}`);
                    resolve(destination);
                }));
            });
        });
    }
    /**
     * Returns a download URL to use to download an object
     * @param key - key referencing the object to download
     */
    getDownloadURL(key) {
        return __awaiter(this, void 0, void 0, function* () {
            const options = {
                version: 'v4',
                action: 'read',
                expires: new Date().getTime() + 15 * 60 * 1000,
            };
            return this.dimensionBucket
                .file(key)
                .getSignedUrl(options)
                .then((url) => {
                return url[0];
            });
        });
    }
    manipulate(dimension) {
        return __awaiter(this, void 0, void 0, function* () {
            dimension.configs.backingDatabase = StorageType.GCLOUD;
            return;
        });
    }
}
//# sourceMappingURL=index.js.map