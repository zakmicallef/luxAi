var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
import mongoose from 'mongoose';
import { Plugin } from '../../Plugin';
import { Database } from '../../Plugin/Database';
import { DatabaseType } from '../../Dimension';
import MatchSchemaCreator from './models/match';
import { pickMatch } from '../../Station/routes/api/dimensions/match';
import bcrypt from 'bcryptjs';
import UserSchemaCreator from './models/user';
import { generateToken, verify } from '../../Plugin/Database/utils';
import { pick } from '../../utils';
import TournamentConfigSchema from './models/tournamentConfig';
// eslint-disable-next-line @typescript-eslint/no-var-requires
require('dotenv').config();
const salt = bcrypt.genSaltSync();
export class MongoDB extends Database {
    constructor(connectionString, configs = {}) {
        super(configs);
        this.name = 'MongoDB';
        this.type = Plugin.Type.DATABASE;
        this.models = {
            user: null,
            match: null,
            tournamentConfigs: null,
        };
        this.mongoose = new mongoose.Mongoose({ useUnifiedTopology: true });
        this.mongoose.set('useCreateIndex', true);
        this.mongoose.set('useFindAndModify', false);
        this.connectionString = connectionString;
        const matchSchema = MatchSchemaCreator();
        this.models.match = this.mongoose.model('Match', matchSchema);
        const userSchema = UserSchemaCreator();
        this.models.user = this.mongoose.model('User', userSchema);
        this.models.tournamentConfigs = this.mongoose.model('TournamentConfigs', TournamentConfigSchema);
    }
    /**
     * Connects to the mongo database and returns the Connection object
     */
    connect() {
        return __awaiter(this, void 0, void 0, function* () {
            this.mongoose.connect(this.connectionString, { useNewUrlParser: true });
            this.db = this.mongoose.connection;
            this.db.on('error', console.error.bind(console, 'connection error:'));
            return this.db;
        });
    }
    initialize() {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.connect();
            // create admin user
            const existingUser = yield this.getUser('admin');
            if (!existingUser) {
                yield this.registerUser('admin', process.env.ADMIN_PASSWORD);
            }
            return;
        });
    }
    storeMatch(match, governID) {
        return __awaiter(this, void 0, void 0, function* () {
            const data = Object.assign(Object.assign({}, pickMatch(match)), { governID: governID });
            // store all relevant data
            return this.models.match.create(data);
        });
    }
    getMatch(id) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.models.match.findOne({ id: id });
        });
    }
    getPlayerMatches(usernameOrID, governID, offset = 0, limit = 10, order = -1) {
        return __awaiter(this, void 0, void 0, function* () {
            const user = yield this.getUser(usernameOrID);
            if (user) {
                return this.models.match.aggregate([
                    {
                        $match: {
                            governID: {
                                $eq: governID,
                            },
                            'agents.tournamentID.id': {
                                $eq: user.playerID,
                            },
                        },
                    },
                    {
                        $sort: {
                            creationDate: order,
                        },
                    },
                    {
                        $skip: offset,
                    },
                    {
                        $limit: limit,
                    },
                ]);
            }
            else {
                return [];
            }
        });
    }
    registerUser(username, password, 
    // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types
    userData) {
        return __awaiter(this, void 0, void 0, function* () {
            const hash = bcrypt.hashSync(password, salt);
            return this.models.user.create({
                username: username,
                passwordHash: hash,
                statistics: {},
                meta: Object.assign({}, userData),
            });
        });
    }
    /**
     * Gets user information. If public is false, will retrieve all information other than password
     * @param usernameOrID
     */
    getUser(usernameOrID, publicView = true) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.models.user
                .findOne({
                $or: [{ username: usernameOrID }, { playerID: usernameOrID }],
            })
                .then((user) => {
                let obj;
                if (user) {
                    obj = user.toObject();
                    if (!publicView)
                        return obj;
                    const d = (pick(obj, 'creationDate', 'meta', 'statistics', 'playerID', 'username'));
                    obj = Object.assign(Object.assign({}, d), { passwordHash: '' });
                    return obj;
                }
                return null;
            });
        });
    }
    loginUser(username, password) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.models.user
                .findOne({ username: username })
                .then((user) => {
                if (user) {
                    if (bcrypt.compareSync(password, user.passwordHash)) {
                        return generateToken(user);
                    }
                    else {
                        throw new Error('Invalid password');
                    }
                }
                else {
                    throw new Error('Not a valid user');
                }
            });
        });
    }
    updateUser(usernameOrID, update) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.models.user
                .findOneAndUpdate({ $or: [{ username: usernameOrID }, { playerID: usernameOrID }] }, update)
                .then((user) => {
                if (user) {
                    return user.toObject();
                }
                else {
                    throw new Error('Not a valid user');
                }
            });
        });
    }
    deleteUser(usernameOrID) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.models.user
                .findOneAndDelete({
                $or: [{ username: usernameOrID }, { playerID: usernameOrID }],
            })
                .then((user) => {
                if (!user) {
                    throw new Error('Not a valid user');
                }
            });
        });
    }
    verifyToken(jwt) {
        return __awaiter(this, void 0, void 0, function* () {
            return verify(jwt);
        });
    }
    isAdmin(user) {
        if (user.username === 'admin')
            return true;
        return false;
    }
    getUsersInTournament(tournamentKey, offset = 0, limit = -1) {
        return __awaiter(this, void 0, void 0, function* () {
            const key = `statistics.${tournamentKey}`;
            if (limit == -1) {
                limit = 0;
            }
            else if (limit == 0) {
                return [];
            }
            return this.models.user
                .find({ [key]: { $exists: true } })
                .skip(offset)
                .limit(limit)
                .then((users) => {
                const mapped = users.map((user) => user.toObject());
                return mapped;
            });
        });
    }
    manipulate(dimension) {
        return __awaiter(this, void 0, void 0, function* () {
            dimension.configs.backingDatabase = DatabaseType.MONGO;
            return;
        });
    }
    storeTournamentConfigs(tournamentID, tournamentConfigs, status) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.models.tournamentConfigs.updateOne({ id: tournamentID }, {
                configs: tournamentConfigs,
                id: tournamentID,
                status: status,
                modificationDate: new Date(),
            }, { upsert: true });
        });
    }
    getTournamentConfigsModificationDate(tournamentID) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.models.tournamentConfigs
                .findOne({ id: tournamentID })
                .select({ modificationDate: 1 })
                .then((date) => {
                if (date) {
                    return new Date(date.toObject().modificationDate);
                }
                else {
                    return null;
                }
            });
        });
    }
    getTournamentConfigs(tournamentID) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.models.tournamentConfigs
                .findOne({ id: tournamentID })
                .then((data) => {
                if (data) {
                    return data.toObject();
                }
                else {
                    return null;
                }
            });
        });
    }
}
//# sourceMappingURL=index.js.map