import { Tournament, Player } from '..';
import { DeepPartial } from '../../utils/DeepPartial';
import { Design } from '../../Design';
import { Agent } from '../../Agent';
import { Dimension, NanoID } from '../../Dimension';
import { RankSystem } from '../RankSystem';
import LadderState = Ladder.State;
import LadderConfigs = Ladder.Configs;
import LadderPlayerStat = Ladder.PlayerStat;
import { nanoid } from '../..';
/**
 * The Ladder Tournament class and namespace.
 */
export declare class Ladder extends Tournament {
    configs: Tournament.TournamentConfigs<LadderConfigs>;
    state: LadderState;
    type: Tournament.Type;
    private matchQueueLocked;
    /**
     * The ranksystem object being used to update, initialize, etc. ranks
     */
    private ranksystem;
    /**
     * tournament runner interval, periodically calls tourneyRunner to start up new matches
     */
    private runInterval;
    /**
     * Configuration synchronization interval. Periodically makes a request to the DB if there is one and syncs configs
     */
    private configSyncInterval;
    /**
     * Last modification date of configs
     */
    private configLastModificationDate;
    resultProcessingQueue: Array<{
        result: RankSystem.Results;
        mapAgentIDtoTournamentID: Map<Agent.ID, Tournament.ID>;
    }>;
    constructor(design: Design, files: Array<string> | Array<{
        file: string;
        name: string;
        existingID?: string;
    }>, tournamentConfigs: Tournament.TournamentConfigsBase, id: NanoID, dimension: Dimension);
    private getConfigsStrippedOfFunctionFields;
    /**
     * Sync configs from DB
     */
    private syncConfigs;
    private setupConfigSyncInterval;
    /**
     * Retrieves the local configurations
     */
    getConfigs(): Tournament.TournamentConfigs<LadderConfigs>;
    /**
     * Set tournament status and updates DB / propagates the message to every other tournament instance
     */
    setStatus(status: Tournament.Status): Promise<void>;
    /**
     * Sets configs and updates DB / propagates the message to every other tournament instance
     */
    setConfigs(configs?: DeepPartial<Tournament.TournamentConfigs<LadderConfigs>>): Promise<void>;
    /**
     * Gets all rankings with the given offset from rank 1 and limit. Note this it's not recommended to use this
     * function if there are many users. It is suggested to create your own (aggregation) query to get rankings directly
     * from the DB.
     * @param offset
     * @param limit
     */
    getRankings(offset?: number, limit?: number): Promise<Array<LadderPlayerStat>>;
    /**
     * Resets rankings of all competitors loaded to initial scores
     */
    resetRankings(): Promise<void>;
    /**
     * Stops the tournament if it was running.
     * @param primary - whether or not the instance calling stop was the first one, the "primary" instance
     */
    stop(primary?: boolean): Promise<void>;
    /**
     * Resumes the tournament if it was stopped.
     * @param primary - whether or not the instance calling stop was the first one, the "primary" instance
     */
    resume(primary?: boolean): Promise<void>;
    /**
     * Begin the tournament. Resolves once the tournament is started
     * @param configs - tournament configurations to use
     * @param master - whether or not the instance calling stop was the first one, the "master" instance
     */
    run(configs?: DeepPartial<Tournament.TournamentConfigs<LadderConfigs>>, master?: boolean): Promise<void>;
    private tourneyRunner;
    /**
     * Updates database with new player stats
     *
     * If failure occurs, we ignore it and just log it as we will likely in the future perform an update operation
     * on the database again anyway
     */
    private updateDatabasePlayerStats;
    private initializePlayerStats;
    /**
     * Initialize competition with given players, which can be local or stored in DB
     *
     * Does not read in any DB players, only uses those that are given at construction of tourney
     */
    initialize(): Promise<void>;
    /**
     * Schedules matches to play. By default uses {@link Scheduler.RankRangeRandom}
     *
     * If a {@link Ladder.Configs.matchMake | matchMake} function is provided, that will be used instead of the default.
     *
     * For users who want to host larger scale competitions with 1000+ competitors, its recommended to turn self match
     * make off and setup a separate match scheduling server that tournament servers can pull queued matches from
     */
    private schedule;
    /** Schedule a match using match info */
    scheduleMatches(...matchInfos: Array<Tournament.QueuedMatch>): void;
    internalAddPlayer(player: Player): Promise<void>;
    updatePlayer(player: Player): Promise<void>;
    /**
     * Removes player from tournament. Removes from state and stats from database
     * @param playerID
     */
    internalRemovePlayer(playerID: nanoid): Promise<void>;
    /**
     * Print tournament status to display
     */
    private printTournamentStatus;
    /**
     * Checks whether match can still be run
     *
     * If there are no stats, player was removed and match can't be run. If player is disabled, then it won't run
     */
    private checkMatchIntegrity;
    /**
     * Handles the start and end of a match, and updates state accrding to match results and the given result handler
     * @param matchInfo
     */
    private handleMatch;
    /**
     * Update player stats for whoever stats owns this player stat. Determined by checking the player field of
     * {@link Ladder.PlayerStat}
     */
    private updatePlayerStat;
    private handleMatchResults;
    protected preInternalDestroy(): Promise<void>;
}
/**
 * The Ladder Tournament namespace
 */
export declare namespace Ladder {
    /**
     * Configuration interface for Ladder Tournaments
     */
    interface Configs extends Tournament.TournamentTypeConfig {
        /** Max matches that can run concurrently on one node instance
         * @default 1
         */
        maxConcurrentMatches: number;
        /** The date to stop running this tournament once it is started. If null, no end date
         * @default null
         */
        endDate: Date;
        /** The max matches to run before stopping the tournament. If null, then no maximum
         * @default null
         */
        maxTotalMatches: number;
        /**
         * Custom match making scheduler function. User can provide a custom function here to create matches to store
         * into the matchqueue for {@link Match} making. This function will be called every time the number of queued
         * matches is below a threshold of {@link maxConcurrentMatches} * 2.
         *
         * It should return an array of {@link Player } arrays, a list of all the new matches to append to the matchQueue.
         * A player array represents a queued match and the players that will compete in that match.
         *
         *
         * Default function is described in {@link schedule}
         *
         */
        matchMake: (playerStats: Array<PlayerStat>) => Array<Tournament.QueuedMatch>;
        /**
         * Rate in ms of how fast to sync the configs. Used for synchronizing configs in a distributed system.
         *
         * @default `6000`
         */
        configSyncRefreshRate: number;
        /**
         * Whether or not to sync configs with database and other tournaments of the same id
         *
         * @default `true`
         */
        syncConfigs: boolean;
        /**
         * Whether or not this tournament will schedule its own matches using its own {@link Ladder.Configs.matchMake | matchMake} function
         *
         * @default `true`
         */
        selfMatchMake: boolean;
    }
    /**
     * The Ladder Tournament state, consisting of the current player statistics and past results
     */
    interface State extends Tournament.TournamentTypeState {
        /**
         * A map from a {@link Player} Tournament ID string to statistics
         */
        playerStats: Map<NanoID, PlayerStat>;
        /**
         * Stats for this Tournament in this instance. Intended to be constant memory usage
         */
        statistics: {
            totalMatches: number;
        };
        currentRanks: Array<{
            player: Player;
            rankState: any;
        }>;
    }
    /**
     * Player stat interface for ladder tournaments
     */
    interface PlayerStat extends Tournament.PlayerStatBase {
        /**
         * total matches played with current bot
         */
        matchesPlayed: number;
        /**
         * the ranking statistics for the player. the type of this variable is dependent on the ranking system you use for
         * the tournament. If the ranking system is {@link RankSystem.TrueSkill | TrueSkill}, then see
         * {@link RankSystem.TrueSkill.RankState} for the rank state typings.
         */
        rankState: any;
    }
}
