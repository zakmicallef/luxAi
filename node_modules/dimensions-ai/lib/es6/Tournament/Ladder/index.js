var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
import { Tournament } from '..';
import { deepMerge } from '../../utils/DeepMerge';
import { MatchDestroyedError, TournamentError, NotSupportedError, TournamentPlayerDoesNotExistError, AgentCompileError, AgentInstallError, FatalError, } from '../../DimensionError';
import { Logger } from '../../Logger';
import { TournamentStatus } from '../TournamentStatus';
import { TournamentType } from '../TournamentTypes';
import { TrueSkillSystem } from '../RankSystem/TrueSkillSystem';
import { ELOSystem } from '../RankSystem/ELOSystem';
import { deepCopy } from '../../utils/DeepCopy';
import { Scheduler } from '../Scheduler';
import { WinsSystem } from '../RankSystem/WinsSystem';
const REFRESH_RATE = 10000;
/**
 * The Ladder Tournament class and namespace.
 */
export class Ladder extends Tournament {
    constructor(design, files, tournamentConfigs, id, dimension) {
        super(design, id, tournamentConfigs, dimension);
        this.configs = {
            defaultMatchConfigs: {},
            type: TournamentType.LADDER,
            rankSystem: null,
            rankSystemConfigs: null,
            tournamentConfigs: {
                maxConcurrentMatches: 1,
                endDate: null,
                storePastResults: true,
                maxTotalMatches: null,
                matchMake: null,
                configSyncRefreshRate: 6000,
                syncConfigs: true,
                selfMatchMake: true,
            },
            resultHandler: null,
            agentsPerMatch: [2],
            consoleDisplay: true,
            id: 'z3plg',
        };
        this.state = {
            playerStats: new Map(),
            currentRanks: [],
            results: [],
            statistics: {
                totalMatches: 0,
            },
        };
        this.type = Tournament.Type.LADDER;
        // lock matchqueue for concurrency
        this.matchQueueLocked = false;
        /**
         * tournament runner interval, periodically calls tourneyRunner to start up new matches
         */
        this.runInterval = null;
        /**
         * Configuration synchronization interval. Periodically makes a request to the DB if there is one and syncs configs
         */
        this.configSyncInterval = null;
        /**
         * Last modification date of configs
         */
        this.configLastModificationDate = new Date(0);
        // queue of the results to process
        this.resultProcessingQueue = [];
        this.configs = deepMerge(this.configs, tournamentConfigs, true);
        if (typeof this.configs.rankSystem === 'string') {
            if (this.configs.rankSystemConfigs === null) {
                this.configs.rankSystemConfigs = {};
            }
            switch (this.configs.rankSystem) {
                case Tournament.RankSystemTypes.TRUESKILL:
                    this.ranksystem = new TrueSkillSystem(this.configs.rankSystemConfigs);
                    break;
                case Tournament.RankSystemTypes.ELO:
                    this.ranksystem = new ELOSystem(this.configs.rankSystemConfigs);
                    break;
                case Tournament.RankSystemTypes.WINS:
                    this.ranksystem = new WinsSystem(this.configs.rankSystemConfigs);
                    break;
                default:
                    throw new NotSupportedError('We currently do not support this rank system for ladder tournaments');
            }
        }
        else {
            this.ranksystem = this.configs.rankSystem;
        }
        if (this.ranksystem === null) {
            throw new FatalError('Did not supply a rank system');
        }
        files.forEach((file) => {
            if (typeof file === 'string') {
                this.initialAddPlayerPromises.push(this.addplayer(file, undefined, true));
            }
            else {
                this.initialAddPlayerPromises.push(this.addplayer(file, file.existingID, true));
            }
        });
        Promise.all(this.initialAddPlayerPromises).then(() => {
            this.emit(Tournament.Events.INITIAL_PLAYERS_INITIALIZED);
        });
        this.status = TournamentStatus.INITIALIZED;
        // setup config syncing if DB is enabled and store configs if not stored already
        if (this.dimension.hasDatabase()) {
            if (this.configs.tournamentConfigs.syncConfigs) {
                this.syncConfigs();
                this.setupConfigSyncInterval();
                this.dimension.databasePlugin
                    .getTournamentConfigs(this.id)
                    .then((data) => {
                    if (!data) {
                        this.configLastModificationDate = new Date();
                        // store tournament configs if no configs found
                        this.dimension.databasePlugin
                            .storeTournamentConfigs(this.id, this.getConfigsStrippedOfFunctionFields(this.configs), this.status)
                            .then(() => {
                            this.log.info('Storing initial tournament configuration data');
                        });
                    }
                });
            }
        }
        // setup matchmaking algorithm to default if not provided
        if (!this.configs.tournamentConfigs.matchMake) {
            let max = this.configs.agentsPerMatch[0];
            this.configs.agentsPerMatch.forEach((v) => {
                max = Math.max(max, v);
            });
            this.configs.tournamentConfigs.matchMake = Scheduler.RankRangeRandom({
                agentsPerMatch: this.configs.agentsPerMatch,
                range: Math.ceil(max * 2.5),
            });
        }
        this.log.info('Initialized Ladder Tournament');
    }
    getConfigsStrippedOfFunctionFields(object) {
        const obj = deepCopy(object);
        delete obj.resultHandler;
        delete obj.rankSystem;
        delete obj.tournamentConfigs.matchMake;
        return obj;
    }
    /**
     * Sync configs from DB
     */
    syncConfigs() {
        return __awaiter(this, void 0, void 0, function* () {
            const modDate = yield this.dimension.databasePlugin.getTournamentConfigsModificationDate(this.id);
            // if modDate exists, and mod date is past the last mode date.
            if (modDate &&
                modDate.getTime() > this.configLastModificationDate.getTime()) {
                const { configs, status, } = yield this.dimension.databasePlugin.getTournamentConfigs(this.id);
                this.log.info(`Received new configurations, mod date - ${modDate}`);
                this.log.detail(configs);
                this.configLastModificationDate = modDate;
                this.configs = deepMerge(this.configs, configs, true);
                // update status and run/stop/resume tourney as needed
                if (status !== this.status) {
                    if (status === Tournament.Status.STOPPED) {
                        if (this.status === Tournament.Status.RUNNING) {
                            this.stop();
                        }
                    }
                    else if (status === Tournament.Status.RUNNING) {
                        if (this.status === Tournament.Status.INITIALIZED) {
                            this.run();
                        }
                        else if (this.status === Tournament.Status.STOPPED) {
                            this.resume();
                        }
                    }
                }
            }
        });
    }
    setupConfigSyncInterval() {
        this.configSyncInterval = setInterval(() => {
            this.syncConfigs();
        }, this.configs.tournamentConfigs.configSyncRefreshRate);
    }
    /**
     * Retrieves the local configurations
     */
    getConfigs() {
        return this.configs;
    }
    /**
     * Set tournament status and updates DB / propagates the message to every other tournament instance
     */
    setStatus(status) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.dimension.hasDatabase() &&
                this.configs.tournamentConfigs.syncConfigs) {
                yield this.syncConfigs();
                yield this.dimension.databasePlugin.storeTournamentConfigs(this.id, this.getConfigsStrippedOfFunctionFields(this.configs), status);
                this.status = status;
            }
            else {
                this.status = status;
            }
        });
    }
    /**
     * Sets configs and updates DB / propagates the message to every other tournament instance
     */
    setConfigs(configs = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            if (configs.id) {
                throw new TournamentError('You cannot change the tournament ID after constructing the tournament');
            }
            if (configs.rankSystem) {
                throw new TournamentError('You cannot change the rank system after constructing the tournament');
            }
            if (this.dimension.hasDatabase() &&
                this.configs.tournamentConfigs.syncConfigs) {
                const plugin = this.dimension.databasePlugin;
                // ensure configs are up to date first, then set configs
                this.syncConfigs().then(() => {
                    const newconfigs = deepMerge(deepCopy(this.configs), configs, true);
                    plugin
                        .storeTournamentConfigs(this.id, this.getConfigsStrippedOfFunctionFields(newconfigs), this.status)
                        .then(() => {
                        // set configs locally as well if we succesfully store into DB
                        this.configs = newconfigs;
                    });
                });
            }
            else {
                // if sync off or no database, edit configs in memory
                this.configs = deepMerge(this.configs, configs, true);
            }
        });
    }
    /**
     * Gets all rankings with the given offset from rank 1 and limit. Note this it's not recommended to use this
     * function if there are many users. It is suggested to create your own (aggregation) query to get rankings directly
     * from the DB.
     * @param offset
     * @param limit
     */
    getRankings(offset = 0, limit = -1) {
        return __awaiter(this, void 0, void 0, function* () {
            let rankings = [];
            if (this.dimension.hasDatabase()) {
                const users = yield this.dimension.databasePlugin.getUsersInTournament(this.getKeyName(), 0, -1);
                rankings = users.map((user) => {
                    const stat = user.statistics[this.getKeyName()];
                    const rankState = stat.rankState;
                    return {
                        player: stat.player,
                        matchesPlayed: stat.matchesPlayed,
                        rankState,
                    };
                });
                if (this.anonymousCompetitors.size > 0) {
                    this.anonymousCompetitors.forEach((player) => {
                        const stat = this.state.playerStats.get(player.tournamentID.id);
                        const rankState = stat.rankState;
                        rankings.push({
                            player: stat.player,
                            matchesPlayed: stat.matchesPlayed,
                            rankState,
                        });
                    });
                }
            }
            else {
                this.state.playerStats.forEach((stat) => {
                    rankings.push({
                        player: stat.player,
                        matchesPlayed: stat.matchesPlayed,
                        rankState: stat.rankState,
                    });
                });
            }
            rankings.sort((a, b) => {
                return this.ranksystem.rankComparator(a.rankState, b.rankState);
            });
            const end = limit === -1 ? rankings.length : offset + limit;
            return rankings.slice(offset, end);
        });
    }
    /**
     * Resets rankings of all competitors loaded to initial scores
     */
    resetRankings() {
        return __awaiter(this, void 0, void 0, function* () {
            // TODO: Some instances of tournament might still be running once this one is stopped, and reset won't work
            // correctly
            if (this.status == TournamentStatus.RUNNING) {
                throw new TournamentError('Cannot reset while tournament is running!');
            }
            const updatePromises = [];
            let playerStatsList = [];
            let userList = [];
            if (this.dimension.hasDatabase()) {
                // get every user
                userList = yield this.dimension.databasePlugin.getUsersInTournament(this.getKeyName(), 0, -1);
                playerStatsList = userList.map((user) => user.statistics[this.getKeyName()]);
                // add anonymous users
                playerStatsList.push(...Array.from(this.state.playerStats.values()));
            }
            else {
                playerStatsList = Array.from(this.state.playerStats.values());
            }
            playerStatsList.forEach((stats, i) => {
                const resetPlayer = () => __awaiter(this, void 0, void 0, function* () {
                    stats.matchesPlayed = 0;
                    stats.rankState = this.ranksystem.resetRank(stats.rankState);
                    if (this.dimension.hasDatabase()) {
                        yield this.updateDatabasePlayerStats(stats, userList[i]);
                    }
                });
                updatePromises.push(resetPlayer());
            });
            yield Promise.all(updatePromises);
        });
    }
    /**
     * Stops the tournament if it was running.
     * @param primary - whether or not the instance calling stop was the first one, the "primary" instance
     */
    stop(primary = false) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.status !== TournamentStatus.RUNNING) {
                throw new TournamentError(`Can't stop a tournament that isn't running`);
            }
            this.log.info('Stopping Tournament...');
            clearInterval(this.runInterval);
            if (primary) {
                yield this.setStatus(TournamentStatus.STOPPED);
            }
            else {
                this.status = TournamentStatus.STOPPED;
            }
        });
    }
    /**
     * Resumes the tournament if it was stopped.
     * @param primary - whether or not the instance calling stop was the first one, the "primary" instance
     */
    resume(primary = false) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.status !== TournamentStatus.STOPPED) {
                throw new TournamentError(`Can't resume a tournament that isn't stopped`);
            }
            this.log.info('Resuming Tournament...');
            if (primary) {
                yield this.setStatus(TournamentStatus.RUNNING);
            }
            else {
                this.status = TournamentStatus.RUNNING;
            }
            this.tourneyRunner();
            this.runInterval = setInterval(() => {
                this.tourneyRunner();
            }, REFRESH_RATE);
        });
    }
    /**
     * Begin the tournament. Resolves once the tournament is started
     * @param configs - tournament configurations to use
     * @param master - whether or not the instance calling stop was the first one, the "master" instance
     */
    run(configs, master = false) {
        return __awaiter(this, void 0, void 0, function* () {
            this.log.info('Running Tournament');
            this.configs = deepMerge(this.configs, configs, true);
            yield this.initialize();
            this.configs.tournamentConfigs.selfMatchMake
                ? yield this.schedule()
                : this.log.info('Self match make turned off, tournament will only run matches stored in match queue');
            if (master) {
                this.setStatus(TournamentStatus.RUNNING);
            }
            else {
                this.status = TournamentStatus.RUNNING;
            }
            this.tourneyRunner();
            this.runInterval = setInterval(() => {
                this.tourneyRunner();
            }, REFRESH_RATE);
        });
    }
    tourneyRunner() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.matchQueueLocked) {
                return;
            }
            this.matchQueueLocked = true;
            if (this.matches.size >= this.configs.tournamentConfigs.maxConcurrentMatches) {
                this.matchQueueLocked = false;
                return;
            }
            const maxTotalMatches = this.configs.tournamentConfigs.maxTotalMatches;
            if (this.configs.tournamentConfigs.endDate) {
                const currDate = new Date();
                if (currDate.getTime() > this.configs.tournamentConfigs.endDate.getTime()) {
                    this.log.info('Reached past Tournament marked End Date, shutting down tournament...');
                    // stop the tournament
                    this.stop();
                    return;
                }
            }
            if (maxTotalMatches) {
                if (this.state.statistics.totalMatches >= maxTotalMatches) {
                    this.log.info('Reached max matches, shutting down tournament...');
                    this.stop();
                    this.matchQueueLocked = false;
                    return;
                }
            }
            const matchPromises = [];
            // if too little matches, schedule another set provided tournament is set to schedule its own matches
            if (this.configs.tournamentConfigs.selfMatchMake &&
                this.matchQueue.length <
                    this.configs.tournamentConfigs.maxConcurrentMatches * 2) {
                yield this.schedule();
            }
            // run as many matches as allowed by maxConcurrentMatches, maxTotalMatches, and how many matches left in queue allow
            for (let i = 0; i <
                Math.min(this.matchQueue.length, this.configs.tournamentConfigs.maxConcurrentMatches - this.matches.size); i++) {
                if (maxTotalMatches &&
                    maxTotalMatches -
                        this.state.statistics.totalMatches -
                        this.matches.size <=
                        0) {
                    break;
                }
                const matchInfo = this.matchQueue.shift();
                matchPromises.push(this.handleMatch(matchInfo));
            }
            // as soon as one match finished, call it again
            Promise.race(matchPromises)
                .then(() => {
                if (this.status == TournamentStatus.RUNNING) {
                    this.tourneyRunner();
                }
            })
                .catch((error) => {
                this.log.error(error);
                if (error instanceof MatchDestroyedError) {
                    // keep running even if a match is destroyed and the tournament is marked as to keep running
                    if (this.status == TournamentStatus.RUNNING) {
                        this.tourneyRunner();
                    }
                }
                else {
                    if (this.status == TournamentStatus.RUNNING) {
                        this.tourneyRunner();
                    }
                }
            });
            this.matchQueueLocked = false;
        });
    }
    /**
     * Updates database with new player stats
     *
     * If failure occurs, we ignore it and just log it as we will likely in the future perform an update operation
     * on the database again anyway
     */
    updateDatabasePlayerStats(playerStat, user) {
        return __awaiter(this, void 0, void 0, function* () {
            const player = playerStat.player;
            if (!player.anonymous) {
                const keyName = this.getKeyName();
                const update = {
                    statistics: {},
                };
                // if there exists stats already, keep them
                if (user && user.statistics) {
                    update.statistics = user.statistics;
                }
                // perform update
                const plainPlayer = {};
                Object.entries(player).forEach(([key, value]) => {
                    plainPlayer[key] = value;
                });
                update.statistics[keyName] = Object.assign(Object.assign({}, playerStat), { player: plainPlayer });
                try {
                    yield this.dimension.databasePlugin.updateUser(player.tournamentID.id, update);
                }
                catch (err) {
                    this.log.error(`Failed to update user with player stats`, err);
                }
            }
        });
    }
    initializePlayerStats(player) {
        return __awaiter(this, void 0, void 0, function* () {
            let playerStat = null;
            let user;
            const keyName = this.getKeyName();
            if (!player.anonymous && this.dimension.hasDatabase()) {
                user = yield this.dimension.databasePlugin.getUser(player.tournamentID.id);
                if (user) {
                    // if there are stats
                    if (user.statistics) {
                        playerStat = user.statistics[keyName];
                        if (playerStat) {
                            // if player stats exist already, we can return as we dont need to initialize anything and store to DB
                            // we don't store anything locally because this is a user and we have DB
                            return;
                        }
                    }
                }
            }
            // Initialize to default values
            if (!playerStat) {
                playerStat = {
                    player: player,
                    matchesPlayed: 0,
                    rankState: this.ranksystem.initializeRankState(),
                };
                yield this.updateDatabasePlayerStats(playerStat, user);
            }
            // only store locally if not in DB
            if (!user) {
                this.state.playerStats.set(player.tournamentID.id, playerStat);
            }
        });
    }
    /**
     * Initialize competition with given players, which can be local or stored in DB
     *
     * Does not read in any DB players, only uses those that are given at construction of tourney
     */
    initialize() {
        return __awaiter(this, void 0, void 0, function* () {
            // wait for all players to add in.
            yield Promise.all(this.initialAddPlayerPromises);
            this.state.playerStats = new Map();
            this.state.results = [];
            const promises = [];
            this.competitors.forEach((player) => {
                promises.push(this.initializePlayerStats(player));
            });
            yield Promise.all(promises);
            if (this.configs.consoleDisplay) {
                yield this.printTournamentStatus();
            }
        });
    }
    /**
     * Schedules matches to play. By default uses {@link Scheduler.RankRangeRandom}
     *
     * If a {@link Ladder.Configs.matchMake | matchMake} function is provided, that will be used instead of the default.
     *
     * For users who want to host larger scale competitions with 1000+ competitors, its recommended to turn self match
     * make off and setup a separate match scheduling server that tournament servers can pull queued matches from
     */
    schedule() {
        return __awaiter(this, void 0, void 0, function* () {
            const rankings = yield this.getRankings(0, -1);
            if (this.configs.tournamentConfigs.matchMake) {
                const newMatches = this.configs.tournamentConfigs.matchMake(rankings);
                this.matchQueue.push(...newMatches);
                return;
            }
        });
    }
    /** Schedule a match using match info */
    scheduleMatches(...matchInfos) {
        this.matchQueue.push(...matchInfos);
        // kick off the runner to process any matches
        this.tourneyRunner();
    }
    // called adding a new player
    internalAddPlayer(player) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.initializePlayerStats(player);
        });
    }
    // should be called only for DB users
    updatePlayer(player) {
        return __awaiter(this, void 0, void 0, function* () {
            const { user, playerStat } = yield this.getPlayerStat(player.tournamentID.id);
            const playerStats = playerStat;
            playerStats.player = player;
            playerStats.matchesPlayed = 0;
            playerStats.rankState = this.ranksystem.onPlayerUpdate(playerStats.rankState);
            if (this.dimension.hasDatabase()) {
                if (!player.anonymous) {
                    yield this.updateDatabasePlayerStats(playerStats, user);
                }
            }
        });
    }
    /**
     * Removes player from tournament. Removes from state and stats from database
     * @param playerID
     */
    internalRemovePlayer(playerID) {
        return __awaiter(this, void 0, void 0, function* () {
            // TODO: we sometimes do a redudant call to get player stats when we really just need to check for existence
            const { user, playerStat } = yield this.getPlayerStat(playerID);
            if (playerStat) {
                this.state.playerStats.delete(playerID);
                this.log.info('Removed player ' + playerID);
                if (this.dimension.hasDatabase()) {
                    if (user) {
                        const keyName = this.getKeyName();
                        const update = {
                            statistics: {},
                        };
                        // if there exists stats already, keep them
                        if (user && user.statistics) {
                            update.statistics = user.statistics;
                        }
                        // delete stats for this tournament to remove player
                        delete update.statistics[keyName];
                        yield this.dimension.databasePlugin.updateUser(playerID, update);
                        this.log.info('Removed player ' + playerID + ' from DB');
                    }
                }
            }
            else {
                throw new TournamentPlayerDoesNotExistError(`Could not find player with ID: ${playerID}`);
            }
        });
    }
    /**
     * Print tournament status to display
     */
    /* istanbul ignore next */
    printTournamentStatus() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.log.level > Logger.LEVEL.NONE) {
                const ranks = yield this.getRankings(0, -1);
                console.clear();
                console.log(this.log.bar());
                console.log(`Tournament - ID: ${this.id}, Name: ${this.name} | Dimension - ID: ${this.dimension.id}, Name: ${this.dimension.name}\nStatus: ${this.status} | Competitors: ${this.competitors.size} | Rank System: ${this.configs.rankSystem}\n`);
                console.log('Total Matches: ' +
                    this.state.statistics.totalMatches +
                    ' | Matches Queued: ' +
                    this.matchQueue.length);
                console.log(this.ranksystem.getRankStatesHeaderString());
                ranks.forEach((info) => {
                    console.log(this.ranksystem.getRankStateString(info.player, info.rankState, info.matchesPlayed));
                });
                console.log();
                console.log('Current Matches: ' + this.matches.size);
                this.matches.forEach((match) => {
                    const names = [];
                    match.agents.forEach((agent) => {
                        names.push(agent.name);
                    });
                    console.log(names);
                });
            }
        });
    }
    /**
     * Checks whether match can still be run
     *
     * If there are no stats, player was removed and match can't be run. If player is disabled, then it won't run
     */
    checkMatchIntegrity(matchInfo) {
        return __awaiter(this, void 0, void 0, function* () {
            const checkIntegrity = (id) => __awaiter(this, void 0, void 0, function* () {
                const stat = yield this.getPlayerStat(id);
                if (!stat.playerStat) {
                    return false;
                }
                else if (stat.playerStat.player.disabled) {
                    return false;
                }
                return true;
            });
            const promises = [];
            for (let i = 0; i < matchInfo.length; i++) {
                const player = matchInfo[i];
                promises.push(checkIntegrity(player.tournamentID.id));
            }
            return Promise.all(promises).then((integritys) => {
                for (let i = 0; i < integritys.length; i++) {
                    if (integritys[i] === false)
                        return false;
                }
                return true;
            });
        });
    }
    /**
     * Handles the start and end of a match, and updates state accrding to match results and the given result handler
     * @param matchInfo
     */
    handleMatch(queuedMatchInfo) {
        return __awaiter(this, void 0, void 0, function* () {
            // Consider adding possibility to use cached player meta data
            const matchInfo = yield this.getMatchInfoFromQueuedMatch(queuedMatchInfo);
            if (!(yield this.checkMatchIntegrity(matchInfo))) {
                // quit
                this.log.detail('Match queued cannot be run anymore');
                return;
            }
            if (this.configs.consoleDisplay) {
                yield this.printTournamentStatus();
            }
            this.log.detail('Running match - Competitors: ', matchInfo.map((player) => {
                return player.tournamentID.name;
            }));
            const matchRes = yield this.runMatch(matchInfo);
            if (matchRes.err) {
                if (matchRes.err instanceof AgentCompileError) {
                    const tournamentID = matchRes.match.mapAgentIDtoTournamentID.get(matchRes.err.agentID);
                    this.log.warn(`Match couldn't run. Player ${tournamentID.id} got a compile error`);
                    yield this.disablePlayer(tournamentID.id);
                }
                else if (matchRes.err instanceof AgentInstallError) {
                    const tournamentID = matchRes.match.mapAgentIDtoTournamentID.get(matchRes.err.agentID);
                    this.log.warn(`Match couldn't run. Player ${tournamentID.id} got an install error`);
                    yield this.disablePlayer(tournamentID.id);
                }
                else {
                    this.log.error(`Match couldn't run, aborting... `, matchRes.err);
                }
                // remove the match from the active matches list
                this.matches.delete(matchRes.match.id);
                return;
            }
            // update total matches
            this.state.statistics.totalMatches++;
            const resInfo = this.configs.resultHandler(matchRes.results);
            // push to result processing queue
            this.resultProcessingQueue.push({
                result: resInfo,
                mapAgentIDtoTournamentID: matchRes.match.mapAgentIDtoTournamentID,
            });
            // make a call to handle match with trueskill to process the next result in the processing queue
            this.handleMatchResults();
            // store past results
            if (this.configs.tournamentConfigs.storePastResults) {
                if (!(this.dimension.hasDatabase() &&
                    this.dimension.databasePlugin.configs.saveTournamentMatches)) {
                    // if we have don't have a database that is set to actively store tournament matches we store locally
                    this.state.results.push(matchRes.results);
                }
            }
        });
    }
    /**
     * Update player stats for whoever stats owns this player stat. Determined by checking the player field of
     * {@link Ladder.PlayerStat}
     */
    updatePlayerStat(currentStats) {
        return __awaiter(this, void 0, void 0, function* () {
            // store locally if not in db
            if (currentStats.player.anonymous) {
                this.state.playerStats.set(currentStats.player.tournamentID.id, currentStats);
            }
            else {
                try {
                    const user = yield this.dimension.databasePlugin.getUser(currentStats.player.tournamentID.id);
                    // if user is still in tourney, update it
                    if (user && user.statistics[this.getKeyName()]) {
                        yield this.updateDatabasePlayerStats(currentStats, user);
                    }
                }
                catch (err) {
                    // don't stop tourney if this happens
                    this.log.error(`Issue with using database`, err);
                }
            }
        });
    }
    handleMatchResults() {
        return __awaiter(this, void 0, void 0, function* () {
            const toProcess = this.resultProcessingQueue.shift();
            const mapAgentIDtoTournamentID = toProcess.mapAgentIDtoTournamentID;
            const result = toProcess.result;
            // stop if no ranks provided, meaning match not successful and we throw result away
            if (result.ranks.length === 0) {
                this.emit(Tournament.Events.MATCH_HANDLED);
                return;
            }
            result.ranks.sort((a, b) => a.rank - b.rank);
            const rankStatePromises = [];
            // the following 3 arrays are parallel
            const ranks = [];
            const currentRankStates = [];
            const tourneyIDs = [];
            result.ranks.forEach((rankInfo) => {
                const fetchRankState = () => __awaiter(this, void 0, void 0, function* () {
                    const tournamentID = mapAgentIDtoTournamentID.get(rankInfo.agentID);
                    const { playerStat } = yield this.getPlayerStat(tournamentID.id);
                    if (!playerStat) {
                        throw new TournamentPlayerDoesNotExistError(`Player ${tournamentID.id} doesn't exist anymore, likely was removed`);
                    }
                    const currentplayerStats = playerStat;
                    currentplayerStats.matchesPlayed++;
                    ranks.push(rankInfo.rank);
                    tourneyIDs.push({ id: tournamentID, stats: currentplayerStats });
                    currentRankStates.push(currentplayerStats.rankState);
                });
                rankStatePromises.push(fetchRankState());
            });
            try {
                yield Promise.all(rankStatePromises);
            }
            catch (err) {
                this.log.error('Probably due to player being removed: ', err);
                this.emit(Tournament.Events.MATCH_HANDLED);
                return;
            }
            const newRankStates = this.ranksystem.updateRanks(currentRankStates, ranks);
            const updatePlayerStatsPromises = [];
            tourneyIDs.forEach((info, i) => {
                const updateStat = () => __awaiter(this, void 0, void 0, function* () {
                    const currentStats = info.stats;
                    currentStats.rankState = newRankStates[i];
                    yield this.updatePlayerStat(currentStats);
                });
                updatePlayerStatsPromises.push(updateStat());
            });
            yield Promise.all(updatePlayerStatsPromises);
            if (this.configs.consoleDisplay) {
                yield this.printTournamentStatus();
            }
            this.emit(Tournament.Events.MATCH_HANDLED);
        });
    }
    preInternalDestroy() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.runInterval)
                clearInterval(this.runInterval);
            if (this.configSyncInterval)
                clearInterval(this.configSyncInterval);
        });
    }
}
//# sourceMappingURL=index.js.map