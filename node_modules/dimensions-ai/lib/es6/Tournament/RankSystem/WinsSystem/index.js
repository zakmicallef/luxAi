import { sprintf } from 'sprintf-js';
import { deepMerge } from '../../../utils/DeepMerge';
import { deepCopy } from '../../../utils/DeepCopy';
import { RankSystem } from '..';
import { FatalError } from '../../../DimensionError';
export class WinsSystem extends RankSystem {
    constructor(configs) {
        super();
        this.configs = {
            winValue: 3,
            tieValue: 1,
            lossValue: 0,
            descending: true,
        };
        this.configs = deepMerge(this.configs, deepCopy(configs));
    }
    getPoints(wins, ties, losses) {
        return (wins * this.configs.winValue +
            ties * this.configs.tieValue +
            losses * this.configs.lossValue);
    }
    initializeRankState() {
        return {
            wins: 0,
            losses: 0,
            ties: 0,
            points: this.getPoints(0, 0, 0),
        };
    }
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    onPlayerUpdate(rankState) {
        return {
            wins: 0,
            losses: 0,
            ties: 0,
            points: this.getPoints(0, 0, 0),
        };
    }
    updateRanks(rankStates, relativeRanks) {
        if (relativeRanks.length > 2 || rankStates.length > 2) {
            throw new FatalError('WinsSystem only supports 2 agent matches');
        }
        if (relativeRanks[0] === relativeRanks[1]) {
            return rankStates.map((state) => {
                return {
                    wins: state.wins,
                    ties: state.ties + 1,
                    losses: state.losses,
                    points: this.getPoints(state.wins, state.ties + 1, state.losses),
                };
            });
        }
        else {
            let winningInd = 0;
            let losingInd = 1;
            if (relativeRanks[0] > relativeRanks[1]) {
                // if [1] won
                winningInd = 1;
                losingInd = 0;
            }
            return [
                {
                    wins: rankStates[winningInd].wins + 1,
                    ties: rankStates[winningInd].ties,
                    losses: rankStates[winningInd].losses,
                    points: this.getPoints(rankStates[winningInd].wins + 1, rankStates[winningInd].ties, rankStates[winningInd].losses),
                },
                {
                    wins: rankStates[losingInd].wins,
                    ties: rankStates[losingInd].ties,
                    losses: rankStates[losingInd].losses + 1,
                    points: this.getPoints(rankStates[losingInd].wins, rankStates[losingInd].ties, rankStates[losingInd].losses + 1),
                },
            ];
        }
    }
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    resetRank(rankState) {
        return {
            wins: 0,
            ties: 0,
            losses: 0,
            points: this.getPoints(0, 0, 0),
        };
    }
    rankComparator(rankState1, rankState2) {
        return this.configs.descending
            ? rankState2.points - rankState1.points
            : rankState1.points - rankState2.points;
    }
    getRankStatesHeaderString() {
        return sprintf(`%-30s | %-14s | %-5s | %-5s | %-5s | %8s | %-8s`.underline, 'Name', 'ID', 'W', 'T', 'L', 'Points', 'Matches');
    }
    getRankStateString(player, rankState, matchesPlayed) {
        return sprintf(`%-30s`.blue +
            ` | %-14s | %-5s | %-5s | %-5s | ` +
            `%-8s`.green +
            ` | %-8s`, player.tournamentID.name, player.tournamentID.id, rankState.wins, rankState.ties, rankState.losses, rankState.points, matchesPlayed);
    }
}
//# sourceMappingURL=index.js.map