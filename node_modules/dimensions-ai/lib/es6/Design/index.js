var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
import { deepMerge } from '../utils/DeepMerge';
import { deepCopy } from '../utils/DeepCopy';
import { Logger } from '../Logger';
/**
 * @class Design
 * @classdesc Abstract class detailing a Design to be used as the platform that holds match lifecycle logic for
 * updating and manipulating ongoing matches
 *
 * Refer to {@link Match} class and the {@link Agent} for exposed fields available for user's use when making your own
 * Design
 *
 * The important functions to implement are {@link initialize}, {@link update}, and {@link getResults}
 *
 */
export class Design {
    /**
     * Design constructor
     * @param name - The name of the design
     * @param designOptions - The options for this design
     */
    constructor(name, designOptions = {}) {
        this.name = name;
        /** Logger */
        this.log = new Logger();
        // Copy defaults
        this.designOptions = deepCopy(DefaultDesignOptions);
        // Override with user provided params
        deepMerge(this.designOptions, designOptions);
        this.log.detail(`Design + MatchEngine Options`, this.designOptions);
        // Set log level to default
        this.log.level = Logger.LEVEL.INFO;
        this.log.system(`Initialized Design: ` + this.name);
    }
    /**
     * Set log level of the design
     * @param level - level to set design logger to
     */
    setLogLevel(level) {
        this.log.level = level;
    }
    /**
     * Get the design options associated with this `Design`
     */
    getDesignOptions() {
        return this.designOptions;
    }
    /**
     * Creates a Design class wrapper around a custom design written without the use of Dimensions framework
     */
    static createCustom(name, overrideOptions) {
        return new CustomDesign(name, overrideOptions);
    }
}
/**
 * This class is meant for wrapping around existing designs built without the use of Dimensions framework
 *
 * This is created so a user provided non-dimension framework based design can be used within the Dimensions framework
 * and leverage other features such as tournament running, an API for viewing relevant data, and automatic, scalable
 * competition running
 */
class CustomDesign extends Design {
    constructor(name, overrideOptions) {
        // this should always be true
        overrideOptions.active = true;
        // pass in the override options to Design
        super(name, {
            override: overrideOptions,
        });
    }
    /**
     * Initializer. Declares any relevant state fields
     */
    initialize(match) {
        return __awaiter(this, void 0, void 0, function* () {
            match.state = {
                matchOutput: [],
            };
            match.results = [];
            return;
        });
    }
    /**
     * Empty function, not used
     */
    /* istanbul ignore next */
    update() {
        return __awaiter(this, void 0, void 0, function* () {
            return;
        });
    }
    /**
     * Returns the results stored. {@link MatchEngine.runCustom} should automatically populate match.results for us and so
     * we just return itt.
     * @param match - Match to get results of
     */
    getResults(match) {
        return __awaiter(this, void 0, void 0, function* () {
            return match.results;
        });
    }
}
/**
 * Default Design Options
 */
export const DefaultDesignOptions = {
    override: {
        active: false,
        command: 'echo NO COMMAND PROVIDED',
        conclude_command: 'D_MATCH_FINISHED',
        arguments: [],
        timeout: 1000 * 60 * 10,
        resultHandler: null,
    },
};
//# sourceMappingURL=index.js.map