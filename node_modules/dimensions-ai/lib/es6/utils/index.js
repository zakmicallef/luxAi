var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
import { customAlphabet } from 'nanoid';
/**
 * Pick stuff
 * @param obj - object to pick out from
 * @param params - fields to pick out
 */
export const pick = (obj, ...params) => {
    const picked = {};
    params.forEach((key) => {
        picked[key] = obj[key];
    });
    return picked;
};
const ALPHA_NUM_STRING = '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ';
// Map from length to id generator for that length
const idGenFunctionMap = new Map();
for (let i = 4; i <= 22; i++) {
    idGenFunctionMap.set(i, customAlphabet(ALPHA_NUM_STRING, i));
}
/**
 * Generate unique IDs using nanoid
 * @param n - length of id
 */
export const genID = (n) => {
    return idGenFunctionMap.get(n)();
};
export const stripFunctions = (object) => {
    const seen = new Set();
    const helper = (object) => {
        for (const key in object) {
            if (!seen.has(key)) {
                seen.add(key);
                if (typeof object[key] === 'function') {
                    delete object[key];
                    continue;
                }
                else if (object[key] !== null &&
                    object[key] !== undefined &&
                    object[key].constructor.name === 'Array') {
                    continue;
                }
                helper(object[key]);
            }
        }
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        return object;
    };
    return helper(object);
};
export const stripNull = (object) => {
    const seen = new Set();
    const helper = (object) => {
        for (const key in object) {
            if (!seen.has(key)) {
                seen.add(key);
                if (object[key] === null) {
                    delete object[key];
                }
                else {
                    helper(object[key]);
                }
            }
        }
        return object;
    };
    return helper(object);
};
/**
 * Async function that resolves after `ms` milliseconds
 * @param ms - number of milliseconds to sleep for
 */
export const sleep = (ms) => __awaiter(void 0, void 0, void 0, function* () {
    return new Promise((resolve) => {
        setTimeout(() => {
            resolve();
        }, ms);
    });
});
// eslint-disable-next-line @typescript-eslint/no-empty-function
export const noop = () => { };
//# sourceMappingURL=index.js.map