var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
import fs, { copyFileSync, mkdirSync } from 'fs';
import constants from 'constants';
import { removeDirectory } from './System';
import path from 'path';
import { noop } from '.';
/**
 * A variant of the LRU cache where this cache stores mappings from keys to file paths. This throws out least recently
 * used items when adding a new file path to cache. Thrown out items are removed from cache and the file it pointed to
 * is deleted
 */
export default class LRUFileCache {
    constructor(max, cachePath) {
        this.size = 0;
        this.cache = new Map();
        this.queueHead = null;
        this.queueTail = null;
        this.max = max;
        this.cachePath = cachePath;
    }
    /**
     * Adds key to file path pair to cache and copies file to new location. Does not delete the given file at filepath
     *
     * Automatically throws out least recently used items if not enough space left to
     * fit new file
     *
     * Resolves with path to cached file location
     *
     * @param key - the key pointing to the given file path
     * @param filepath - the file path representing the file to cache
     */
    add(key, filepath) {
        return __awaiter(this, void 0, void 0, function* () {
            let newfilesize = 0;
            key = key.replace(/\//g, '_');
            try {
                const meta = fs.statSync(filepath);
                newfilesize = meta.size;
            }
            catch (err) {
                if (err.errno === -constants.ENOENT) {
                    throw new Error('file does not exist');
                }
            }
            if (newfilesize > this.max) {
                throw new Error(`file is at ${filepath} too large, ${newfilesize} > ${this.max} allocated bytes`);
            }
            let trimmedSize = this.size;
            const removeFilePromises = [];
            while (newfilesize + trimmedSize > this.max) {
                // find files until under max
                const newtail = this.queueTail.prev;
                trimmedSize -= this.queueTail.filesize;
                removeFilePromises.push(removeDirectory(path.dirname(this.getCachedFilePath(this.queueTail.filepath, this.queueTail.key))).catch(noop));
                this.cache.delete(this.queueTail.key);
                if (newtail) {
                    newtail.next = null;
                    this.queueTail = newtail;
                }
            }
            yield Promise.all(removeFilePromises);
            const node = new LRUFileCacheNode(filepath, newfilesize, key);
            if (this.cache.size === 0) {
                this.queueHead = node;
                this.queueTail = node;
            }
            else if (this.cache.size === 1) {
                this.queueTail = this.queueHead;
                this.queueHead = node;
                this.queueHead.next = this.queueTail;
                this.queueTail.prev = this.queueHead;
            }
            else {
                // integrate new node into queue.
                node.next = this.queueHead;
                this.queueHead.prev = node;
                this.queueHead = node;
            }
            this.cache.set(key, node);
            // copy file
            const cachedPath = this.getCachedFilePath(filepath, key);
            mkdirSync(path.dirname(cachedPath), {
                recursive: true,
            });
            copyFileSync(filepath, cachedPath);
            this.size = trimmedSize + newfilesize;
            return cachedPath;
        });
    }
    getCachedFilePath(filepath, key) {
        key = key.replace(/\//g, '_');
        return path.join(this.cachePath, key, path.basename(filepath));
    }
    has(key) {
        key = key.replace(/\//g, '_');
        return this.cache.has(key);
    }
    /**
     * Gets the cached file path associated with the key. Returns undefined if file mapped from key is not cached
     * @param key
     */
    get(key) {
        key = key.replace(/\//g, '_');
        if (this.has(key)) {
            if (this.cache.size !== 1) {
                // move node to front
                const node = this.cache.get(key);
                if (node.prev) {
                    node.prev.next = node.next;
                }
                if (node.next) {
                    node.next.prev = node.prev;
                }
                if (node === this.queueTail) {
                    this.queueTail = node.prev;
                }
                node.next = this.queueHead;
                this.queueHead.prev = node;
                node.prev = null;
                this.queueHead = node;
            }
            // return cached path
            return this.getCachedFilePath(this.cache.get(key).filepath, key);
        }
        return undefined;
    }
}
class LRUFileCacheNode {
    constructor(filepath, filesize, key) {
        this.filepath = filepath;
        this.filesize = filesize;
        this.key = key;
        this.next = null;
        this.prev = null;
    }
}
//# sourceMappingURL=LRUFileCache.js.map