/**
 * This file defines error classes based on their semantic meaning. It abstracts away
 * HTTP status codes so they can be used in a RESTful way without worrying about a
 * consistent error interface.
 *
 * These classes descend from the base Error class, so they also automatically capture
 * stack traces--useful for debugging.
 */
import { Request, Response, NextFunction } from 'express';
import { Logger } from '../../Logger';
/**
 * Base error class.
 *
 * Supports HTTP status codes and a custom message.
 * From the ACM Membership Portal Backend repository
 */
export declare class HttpError extends Error {
    status: number;
    constructor(status: number, message: string | Error);
}
export declare class UserError extends HttpError {
    constructor(message: string | Error);
}
export declare class BadRequest extends HttpError {
    constructor(message: string | Error);
}
export declare class Unauthorized extends HttpError {
    constructor(message: string | Error);
}
export declare class Forbidden extends HttpError {
    constructor(message: string | Error);
}
export declare class NotFound extends HttpError {
    constructor(message: string | Error);
}
export declare class Unprocessable extends HttpError {
    constructor(message: string | Error);
}
export declare class InternalServerError extends HttpError {
    constructor(message: string | Error);
}
export declare class NotImplemented extends HttpError {
    constructor(message: string | Error);
}
/**
 * General error handling middleware. Attaches to Express so that throwing or calling next() with
 * an error ends up here and all errors are handled uniformly.
 */
export declare const errorHandler: (log: Logger) => (err: HttpError, req: Request<import("express-serve-static-core").ParamsDictionary>, res: Response<any>, next: NextFunction) => void;
