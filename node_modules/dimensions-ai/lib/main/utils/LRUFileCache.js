"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var fs_1 = __importStar(require("fs"));
var constants_1 = __importDefault(require("constants"));
var System_1 = require("./System");
var path_1 = __importDefault(require("path"));
var _1 = require(".");
/**
 * A variant of the LRU cache where this cache stores mappings from keys to file paths. This throws out least recently
 * used items when adding a new file path to cache. Thrown out items are removed from cache and the file it pointed to
 * is deleted
 */
var LRUFileCache = /** @class */ (function () {
    function LRUFileCache(max, cachePath) {
        this.size = 0;
        this.cache = new Map();
        this.queueHead = null;
        this.queueTail = null;
        this.max = max;
        this.cachePath = cachePath;
    }
    /**
     * Adds key to file path pair to cache and copies file to new location. Does not delete the given file at filepath
     *
     * Automatically throws out least recently used items if not enough space left to
     * fit new file
     *
     * Resolves with path to cached file location
     *
     * @param key - the key pointing to the given file path
     * @param filepath - the file path representing the file to cache
     */
    LRUFileCache.prototype.add = function (key, filepath) {
        return __awaiter(this, void 0, void 0, function () {
            var newfilesize, meta, trimmedSize, removeFilePromises, newtail, node, cachedPath;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        newfilesize = 0;
                        key = key.replace(/\//g, '_');
                        try {
                            meta = fs_1.default.statSync(filepath);
                            newfilesize = meta.size;
                        }
                        catch (err) {
                            if (err.errno === -constants_1.default.ENOENT) {
                                throw new Error('file does not exist');
                            }
                        }
                        if (newfilesize > this.max) {
                            throw new Error("file is at " + filepath + " too large, " + newfilesize + " > " + this.max + " allocated bytes");
                        }
                        trimmedSize = this.size;
                        removeFilePromises = [];
                        while (newfilesize + trimmedSize > this.max) {
                            newtail = this.queueTail.prev;
                            trimmedSize -= this.queueTail.filesize;
                            removeFilePromises.push(System_1.removeDirectory(path_1.default.dirname(this.getCachedFilePath(this.queueTail.filepath, this.queueTail.key))).catch(_1.noop));
                            this.cache.delete(this.queueTail.key);
                            if (newtail) {
                                newtail.next = null;
                                this.queueTail = newtail;
                            }
                        }
                        return [4 /*yield*/, Promise.all(removeFilePromises)];
                    case 1:
                        _a.sent();
                        node = new LRUFileCacheNode(filepath, newfilesize, key);
                        if (this.cache.size === 0) {
                            this.queueHead = node;
                            this.queueTail = node;
                        }
                        else if (this.cache.size === 1) {
                            this.queueTail = this.queueHead;
                            this.queueHead = node;
                            this.queueHead.next = this.queueTail;
                            this.queueTail.prev = this.queueHead;
                        }
                        else {
                            // integrate new node into queue.
                            node.next = this.queueHead;
                            this.queueHead.prev = node;
                            this.queueHead = node;
                        }
                        this.cache.set(key, node);
                        cachedPath = this.getCachedFilePath(filepath, key);
                        fs_1.mkdirSync(path_1.default.dirname(cachedPath), {
                            recursive: true,
                        });
                        fs_1.copyFileSync(filepath, cachedPath);
                        this.size = trimmedSize + newfilesize;
                        return [2 /*return*/, cachedPath];
                }
            });
        });
    };
    LRUFileCache.prototype.getCachedFilePath = function (filepath, key) {
        key = key.replace(/\//g, '_');
        return path_1.default.join(this.cachePath, key, path_1.default.basename(filepath));
    };
    LRUFileCache.prototype.has = function (key) {
        key = key.replace(/\//g, '_');
        return this.cache.has(key);
    };
    /**
     * Gets the cached file path associated with the key. Returns undefined if file mapped from key is not cached
     * @param key
     */
    LRUFileCache.prototype.get = function (key) {
        key = key.replace(/\//g, '_');
        if (this.has(key)) {
            if (this.cache.size !== 1) {
                // move node to front
                var node = this.cache.get(key);
                if (node.prev) {
                    node.prev.next = node.next;
                }
                if (node.next) {
                    node.next.prev = node.prev;
                }
                if (node === this.queueTail) {
                    this.queueTail = node.prev;
                }
                node.next = this.queueHead;
                this.queueHead.prev = node;
                node.prev = null;
                this.queueHead = node;
            }
            // return cached path
            return this.getCachedFilePath(this.cache.get(key).filepath, key);
        }
        return undefined;
    };
    return LRUFileCache;
}());
exports.default = LRUFileCache;
var LRUFileCacheNode = /** @class */ (function () {
    function LRUFileCacheNode(filepath, filesize, key) {
        this.filepath = filepath;
        this.filesize = filesize;
        this.key = key;
        this.next = null;
        this.prev = null;
    }
    return LRUFileCacheNode;
}());
//# sourceMappingURL=LRUFileCache.js.map