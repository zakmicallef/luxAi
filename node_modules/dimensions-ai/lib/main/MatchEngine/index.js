"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var os_1 = __importDefault(require("os"));
var child_process_1 = require("child_process");
var fs_1 = __importDefault(require("fs"));
var path_1 = __importDefault(require("path"));
// Import utilities
var DeepCopy_1 = require("../utils/DeepCopy");
var DeepMerge_1 = require("../utils/DeepMerge");
var DimensionError_1 = require("../DimensionError");
var Logger_1 = require("../Logger");
var Agent_1 = require("../Agent");
var Match_1 = require("../Match");
var dockerode_1 = __importDefault(require("dockerode"));
var TypeGuards_1 = require("../utils/TypeGuards");
var utils_1 = require("../utils");
var System_1 = require("../utils/System");
/**
 * The Match Engine that takes a {@link Design} and its specified {@link EngineOptions} to form the backend
 * for running matches with agents.
 */
var MatchEngine = /** @class */ (function () {
    /**
     * Match engine constructor
     * @param design - the design to use
     * @param loggingLevel - the logging level for this engine
     */
    function MatchEngine(design, loggingLevel) {
        /** Engine options */
        this.engineOptions = DeepCopy_1.deepCopy(exports.DefaultMatchEngineOptions);
        /** Logger */
        this.log = new Logger_1.Logger();
        /**
         * A coordination signal to ensure that all processes are indeed killed due to asynchronous initialization of agents
         * There is a race condition when a tournament/match is being destroyed and while every match is being destroyed, some
         * matches are in the initialization stage where they call the engine's initialize function. As a result, when we
         * send a match destroy signal, we spawn some processes and haven't spawned some others for the agents. As a result,
         * all processes eventually get spawned but not all are cleaned up and killed.
         */
        this.killOffSignal = false;
        /**
         * Single memory watch interval so that all memory checks are made together
         */
        this.memoryWatchInterval = null;
        this.design = design;
        this.engineOptions = DeepMerge_1.deepMerge(this.engineOptions, DeepCopy_1.deepCopy(this.design.getDesignOptions().engineOptions));
        this.overrideOptions = DeepCopy_1.deepCopy(this.design.getDesignOptions().override);
        this.log.identifier = "Engine";
        this.setLogLevel(loggingLevel);
        this.docker = new dockerode_1.default({ socketPath: '/var/run/docker.sock' });
    }
    /** Set log level */
    MatchEngine.prototype.setLogLevel = function (loggingLevel) {
        this.log.level = loggingLevel;
    };
    /** Get the engine options */
    MatchEngine.prototype.getEngineOptions = function () {
        return this.engineOptions;
    };
    /** Set the engine options */
    MatchEngine.prototype.setEngineOptions = function (newOptions) {
        if (newOptions === void 0) { newOptions = {}; }
        this.engineOptions = DeepMerge_1.deepMerge(this.engineOptions, newOptions);
    };
    /**
     * Starts up the engine by intializing processes for all the agents and setting some variables for a match
     * @param agents - The agents involved to be setup for the given match
     * @param match - The match to initialize
     * @returns a promise that resolves once succesfully initialized
     */
    MatchEngine.prototype.initialize = function (agents, match) {
        return __awaiter(this, void 0, void 0, function () {
            var agentSetupPromises;
            var _this = this;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        this.log.systembar();
                        agentSetupPromises = [];
                        match.agents.forEach(function (agent) {
                            agentSetupPromises.push(_this.initializeAgent(agent, match));
                        }, this);
                        return [4 /*yield*/, Promise.all(agentSetupPromises)];
                    case 1:
                        _a.sent();
                        this.log.system('FINISHED INITIALIZATION OF PROCESSES\n');
                        return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Initializes a single agent, called by {@link initialize}
     * @param agent - agent to initialize
     * @param match - match to initialize in
     */
    MatchEngine.prototype.initializeAgent = function (agent, match) {
        return __awaiter(this, void 0, void 0, function () {
            var name_1, errorLogFilepath, errorLogWriteStream, p, containerExec_1;
            var _this = this;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        this.log.system('Setting up and spawning ' +
                            agent.name +
                            (" | Command: " + agent.cmd + " " + agent.src));
                        if (!match.configs.secureMode) return [3 /*break*/, 2];
                        name_1 = match.id + "_agent_" + agent.id;
                        return [4 /*yield*/, agent.setupContainer(name_1, this.docker, this.engineOptions)];
                    case 1:
                        _a.sent();
                        _a.label = 2;
                    case 2:
                        if (this.engineOptions.memory.active) {
                            if (agent.options.secureMode) {
                                // await agent._setupMemoryWatcherOnContainer(this.engineOptions);
                            }
                        }
                        errorLogFilepath = path_1.default.join(match.getMatchErrorLogDirectory(), agent.getAgentErrorLogFilename());
                        errorLogWriteStream = null;
                        if (match.configs.storeErrorLogs) {
                            errorLogWriteStream = fs_1.default.createWriteStream(errorLogFilepath);
                            agent.errorLogWriteStream = errorLogWriteStream;
                            errorLogWriteStream.write('=== Agent Install Log ===\n');
                        }
                        // wait for install step
                        return [4 /*yield*/, agent._install(errorLogWriteStream, errorLogWriteStream, this.engineOptions)];
                    case 3:
                        // wait for install step
                        _a.sent();
                        this.log.system('Succesfully ran install step for agent ' + agent.id);
                        if (match.configs.storeErrorLogs) {
                            errorLogWriteStream.write('=== Agent Compile Log ===\n');
                        }
                        // wait for compilation step
                        return [4 /*yield*/, agent._compile(errorLogWriteStream, errorLogWriteStream, this.engineOptions)];
                    case 4:
                        // wait for compilation step
                        _a.sent();
                        this.log.system('Succesfully ran compile step for agent ' + agent.id);
                        p = null;
                        return [4 /*yield*/, agent._spawn()];
                    case 5:
                        p = _a.sent();
                        this.log.system('Spawned agent ' + agent.id);
                        if (TypeGuards_1.isChildProcess(p)) {
                            // store process and streams
                            agent._storeProcess(p);
                            agent.streams.in = p.stdin;
                            agent.streams.out = p.stdout;
                            agent.streams.err = p.stderr;
                            p.on('close', function (code) {
                                agent.emit(Agent_1.Agent.AGENT_EVENTS.CLOSE, code);
                            });
                            // we do not care if input stream is broken, engine will detect this error through timeouts and what not
                            agent.streams.in.on('error', utils_1.noop);
                        }
                        else {
                            // store streams
                            agent.streams.in = p.in;
                            agent.streams.out = p.out;
                            agent.streams.err = p.err;
                            containerExec_1 = p.exec;
                            p.stream.on('end', function () { return __awaiter(_this, void 0, void 0, function () {
                                var endRes;
                                return __generator(this, function (_a) {
                                    switch (_a.label) {
                                        case 0: return [4 /*yield*/, containerExec_1.inspect()];
                                        case 1:
                                            endRes = _a.sent();
                                            agent.emit(Agent_1.Agent.AGENT_EVENTS.CLOSE, endRes.ExitCode);
                                            return [2 /*return*/];
                                    }
                                });
                            }); });
                        }
                        // add listener for memory limit exceeded
                        agent.on(Agent_1.Agent.AGENT_EVENTS.EXCEED_MEMORY_LIMIT, function () {
                            _this.engineOptions.memory.memoryCallback(agent, match, _this.engineOptions);
                        });
                        // add listener for timeouts
                        agent.on(Agent_1.Agent.AGENT_EVENTS.TIMEOUT, function () {
                            _this.engineOptions.timeout.timeoutCallback(agent, match, _this.engineOptions);
                        });
                        match.idToAgentsMap.set(agent.id, agent);
                        // set agent status as running
                        agent.status = Agent_1.Agent.Status.RUNNING;
                        // handler for stdout of Agent processes. Stores their output commands and resolves move promises
                        agent.streams.out.on('readable', function () {
                            var data;
                            while ((data = agent.streams.out.read())) {
                                // split chunks into line by line and handle each line of commands
                                var strs = ("" + data).split(/\r?\n/);
                                // first store data into a buffer and process later if no newline character is detected
                                // if final char in the strs array is not '', then \n is not at the end
                                var endsWithNewline = strs[strs.length - 1] === '';
                                // if strs when split up by \n, is greater than one in length, must have at least 1 newline char
                                var agentOutputContainsNewline = strs.length > 1;
                                if (agentOutputContainsNewline) {
                                    // if there is a newline, take whatever was stored in the buffer and
                                    // concat it with the output before the newline as they are part of the same line of commands
                                    strs[0] = agent._buffer.join('').concat(strs[0]);
                                    agent._buffer = [];
                                }
                                // handle each complete line of commands
                                for (var i = 0; i < strs.length - 1; i++) {
                                    if (strs[i] === '')
                                        continue; // skip empty lines caused by adjacent \n chars
                                    // handle commands from this agent provided it is allowed to send commands
                                    if (agent.isAllowedToSendCommands()) {
                                        _this.handleCommand(agent, strs[i]);
                                    }
                                }
                                // push final command that didn't have a newline into buffer
                                if (_this.engineOptions.commandLines.waitForNewline &&
                                    strs.length >= 1 &&
                                    !endsWithNewline) {
                                    agent._buffer.push(strs[strs.length - 1]);
                                }
                            }
                        });
                        // log stderr from agents to this stderr if option active
                        if (!this.engineOptions.noStdErr) {
                            agent.streams.err.on('data', function (data) {
                                var strs = ("" + data).split(/\r?\n/);
                                for (var _i = 0, strs_1 = strs; _i < strs_1.length; _i++) {
                                    var str = strs_1[_i];
                                    if (str === '')
                                        continue;
                                    _this.log.custom(("[Agent " + agent.id + " Log]").cyan, Logger_1.Logger.LEVEL.WARN, str);
                                }
                            });
                        }
                        // pipe stderr of agent process to error log file if enabled
                        if (match.configs.storeErrorLogs) {
                            errorLogWriteStream.write('=== Agent Error Log ===\n');
                            agent.streams.err.on('data', function (data) {
                                // store logs below limit only
                                if (agent._logsize < agent.options.logLimit) {
                                    agent._logsize += data.length;
                                    errorLogWriteStream.write("" + data);
                                }
                                else {
                                    if (agent._trimmed === false) {
                                        agent._trimmed = true;
                                        _this.log.warn("agent " + agent.id + "'s logs were trimmed");
                                        errorLogWriteStream.write("\nend of logs as logs were trimmed\n");
                                    }
                                }
                            });
                        }
                        // when process closes, print message
                        agent.on(Agent_1.Agent.AGENT_EVENTS.CLOSE, function (code) {
                            // terminate agent with engine kill if it hasn't been marked as terminated yet, indicating process likely exited
                            // prematurely
                            if (!agent.isTerminated()) {
                                // if secureMode, agent wasn't terminated yet, and container exited prematurely with 137, it likely had an OOM error
                                if (agent.options.secureMode && code === 137) {
                                    _this.kill(agent, 'agent closed but agent not terminated yet, likely exceeded memory');
                                    _this.engineOptions.memory.memoryCallback(agent, match, _this.engineOptions);
                                }
                                else {
                                    _this.kill(agent, 'agent closed but agent not terminated yet');
                                }
                            }
                            _this.log.system(agent.name + " | id: " + agent.id + " - exited with code " + code);
                        });
                        if (this.engineOptions.memory.active) {
                            if (!agent.options.secureMode) {
                                agent._setupMemoryWatcher(this.engineOptions);
                            }
                        }
                        // this is for handling a race condition explained in the comments of this.killOffSignal
                        // Briefly, sometimes agent process isn't stored yet during initialization and doesn't get killed as a result
                        if (this.killOffSignal) {
                            this.kill(agent, 'engine has killOffSignal on, killing agent during initialization');
                        }
                        return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Handles partial stdout from an agent
     * @param agent - the agent to process the command for
     * @param str - the string the agent sent
     */
    MatchEngine.prototype.handleCommand = function (agent, str) {
        return __awaiter(this, void 0, void 0, function () {
            var _a;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        if (!(this.engineOptions.commandStreamType ===
                            MatchEngine.COMMAND_STREAM_TYPE.SEQUENTIAL)) return [3 /*break*/, 12];
                        _a = this.engineOptions.commandFinishPolicy;
                        switch (_a) {
                            case MatchEngine.COMMAND_FINISH_POLICIES.FINISH_SYMBOL: return [3 /*break*/, 1];
                            case MatchEngine.COMMAND_FINISH_POLICIES.LINE_COUNT: return [3 /*break*/, 5];
                            case MatchEngine.COMMAND_FINISH_POLICIES.CUSTOM: return [3 /*break*/, 11];
                        }
                        return [3 /*break*/, 12];
                    case 1:
                        if (!("" + str === this.engineOptions.commandFinishSymbol)) return [3 /*break*/, 3];
                        return [4 /*yield*/, agent._finishMove()];
                    case 2:
                        _b.sent();
                        return [3 /*break*/, 4];
                    case 3:
                        agent.currentMoveCommands.push(str);
                        _b.label = 4;
                    case 4: return [3 /*break*/, 12];
                    case 5:
                        if (!("" + str === this.engineOptions.commandFinishSymbol)) return [3 /*break*/, 7];
                        return [4 /*yield*/, agent._finishMove()];
                    case 6:
                        _b.sent();
                        return [3 /*break*/, 10];
                    case 7:
                        if (!(agent.currentMoveCommands.length <
                            this.engineOptions.commandLines.max - 1)) return [3 /*break*/, 8];
                        agent.currentMoveCommands.push(str);
                        return [3 /*break*/, 10];
                    case 8:
                        if (!(agent.currentMoveCommands.length ==
                            this.engineOptions.commandLines.max - 1)) return [3 /*break*/, 10];
                        return [4 /*yield*/, agent._finishMove()];
                    case 9:
                        _b.sent();
                        agent.currentMoveCommands.push(str);
                        _b.label = 10;
                    case 10: return [3 /*break*/, 12];
                    case 11: 
                    // TODO: Not implemented yet
                    throw new DimensionError_1.NotSupportedError('Custom command finish policies are not allowed yet');
                    case 12: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Attempts to gracefully and synchronously stop a match's agents
     * @param match - the match to stop
     */
    MatchEngine.prototype.stop = function (match) {
        return __awaiter(this, void 0, void 0, function () {
            var stopPromises;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        stopPromises = [];
                        match.agents.forEach(function (agent) {
                            stopPromises.push(agent.stop());
                        });
                        return [4 /*yield*/, Promise.all(stopPromises)];
                    case 1:
                        _a.sent();
                        this.log.system('Stopped all agents');
                        return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Attempts to gracefully and synchronously resume a previously stopped match
     * @param match - the match to resume
     */
    MatchEngine.prototype.resume = function (match) {
        return __awaiter(this, void 0, void 0, function () {
            var resumePromises;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        resumePromises = [];
                        match.agents.forEach(function (agent) {
                            resumePromises.push(agent.resume());
                        });
                        return [4 /*yield*/, Promise.all(resumePromises)];
                    case 1:
                        _a.sent();
                        this.log.system('Resumed all agents');
                        return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Kills all intervals and agents and processes from a match and cleans up. Kills any game processes as well. Shouldn't be used
     * for custom design based matches. Called by {@link Match}
     *
     * @param match - the match to kill all agents in and clean up
     */
    MatchEngine.prototype.killAndClean = function (match) {
        return __awaiter(this, void 0, void 0, function () {
            var cleanUpPromises;
            var _this = this;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        // set to true to ensure no more processes are being spawned.
                        this.killOffSignal = true;
                        clearInterval(this.memoryWatchInterval);
                        cleanUpPromises = [];
                        if (match.agents) {
                            match.agents.forEach(function (agent) {
                                cleanUpPromises.push(_this.kill(agent, 'cleanup'));
                            });
                        }
                        return [4 /*yield*/, Promise.all(cleanUpPromises)];
                    case 1:
                        _a.sent();
                        return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Kills an agent and closes the process, and no longer attempts to receive coommands from it anymore
     * @param agent - the agent to kill off
     */
    MatchEngine.prototype.kill = function (agent, reason) {
        if (reason === void 0) { reason = 'unspecified'; }
        return __awaiter(this, void 0, void 0, function () {
            var err_1;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        _a.trys.push([0, 2, , 3]);
                        return [4 /*yield*/, agent._terminate()];
                    case 1:
                        _a.sent();
                        this.log.system("Killed off agent " + agent.id + " - " + agent.name, "Reason: " + reason);
                        return [3 /*break*/, 3];
                    case 2:
                        err_1 = _a.sent();
                        this.log.system('This should not happen when terminating agents.', err_1);
                        return [3 /*break*/, 3];
                    case 3:
                        agent._currentMoveResolve();
                        return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Returns a promise that resolves with all the commands loaded from the previous time step of the provided match
     * This coordinates all the Agents and waits for each one to finish their step
     * @param match - The match to get commands from agents for
     * @returns a promise that resolves with an array of {@link MatchEngine.Command} elements, holding the command and id
     * of the agent that sent it
     */
    MatchEngine.prototype.getCommands = function (match) {
        var _this = this;
        return new Promise(function (resolve) {
            var commands = [];
            var nonTerminatedAgents = match.agents.filter(function (agent) {
                return !agent.isTerminated();
            });
            var allAgentMovePromises = nonTerminatedAgents.map(function (agent) {
                return agent._currentMovePromise;
            });
            Promise.all(allAgentMovePromises).then(function () {
                _this.log.system("All move promises resolved");
                match.agents.forEach(function (agent) {
                    // for each set of commands delimited by '\n' in stdout of process, split it by delimiter and push to
                    // commands
                    agent.currentMoveCommands.forEach(function (commandString) {
                        commandString
                            .split(_this.engineOptions.commandDelimiter)
                            .forEach(function (c) {
                            // we don't accept '' as commands.
                            if (c !== '') {
                                commands.push({ command: c, agentID: agent.id });
                            }
                        });
                    });
                });
                _this.log.systemIO("Agent commands at end of time step " + match.timeStep + " to be sent to match on time step " + (match.timeStep + 1) + " ");
                _this.log.systemIO(commands.length ? JSON.stringify(commands) : 'No commands');
                resolve(commands);
            });
        });
    };
    /**
     * Sends a message to a particular process governed by an agent in a specified match specified by the agentID
     * @param match - the match to work with
     * @param message - the message to send to agent's stdin
     * @param agentID - id that specifies the agent in the match to send the message to
     */
    MatchEngine.prototype.send = function (match, message, agentID) {
        var _this = this;
        return new Promise(function (resolve, reject) {
            var agent = match.idToAgentsMap.get(agentID);
            if (agent.options.detached ||
                (!agent.inputDestroyed() && !agent.isTerminated())) {
                var written = agent.options.detached ? "" + message : message + "\n";
                var bufferReachedHighWaterMark = agent.write(written, function (error) {
                    if (error)
                        reject(error);
                    resolve(true);
                });
                if (!bufferReachedHighWaterMark) {
                    // reject(
                    //   new AgentNotHandlingInputError(
                    //     'Input stream buffer highWaterMark reached, agent is not processing input',
                    //     agentID
                    //   )
                    // );
                    _this.log.system("Agent " + agentID + " buffer reached high watermark");
                }
            }
            else {
                _this.log.error("Agent " + agentID + " - " + agent.name + " - has been killed off already, can't send messages now");
                resolve(false);
            }
        });
    };
    /**
     * @param match - The match to initialize with a custom design
     */
    MatchEngine.prototype.initializeCustom = function () {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                // TODO: Initialize a custom design based match and run through some basic security measures
                return [2 /*return*/, true];
            });
        });
    };
    /**
     * Run a custom match. A custom match much print to stdout all relevant data to be used by the engine and
     * Dimensions framework. All output after the conclude command from {@link Design.OverrideOptions} is outputted
     * is stored as a list of new line delimited strings and returned as the match results. The match must exit with
     * exit code 0 to be marked as succesfully complete and the processing of results stops and this function resolves
     * @param match - the match to run
     */
    MatchEngine.prototype.runCustom = function (match) {
        var _this = this;
        return new Promise(function (resolve, reject) {
            if (_this.overrideOptions.active == false) {
                reject(new DimensionError_1.FatalError('Override was not set active! Make sure to set the overide.active field to true'));
            }
            var cmd = _this.overrideOptions.command;
            var parsed = _this.parseCustomArguments(match, _this.overrideOptions.arguments);
            // spawn the match process with the parsed arguments
            var matchProcessTimer;
            // TODO: configure some kind of secureMode for custom matches
            match.matchProcess = child_process_1.spawn(cmd, parsed).on('error', function (err) {
                if (err)
                    throw err;
            });
            _this.log.system(match.name + " | id: " + match.id + " - spawned: " + cmd + " " + parsed.join(' '));
            var errorLogFilepath = path_1.default.join(match.getMatchErrorLogDirectory(), "match_error.log");
            var errorLogWriteStream = null;
            if (match.configs.storeErrorLogs) {
                errorLogWriteStream = fs_1.default.createWriteStream(errorLogFilepath);
            }
            // pipe stderr of match process to error log file if enabled
            if (match.configs.storeErrorLogs) {
                errorLogWriteStream.write('=== Custom Match Error Log ===\n');
                match.matchProcess.stderr.pipe(errorLogWriteStream);
            }
            var matchTimedOut = false;
            // set up timer if specified
            if (_this.overrideOptions.timeout !== null) {
                matchProcessTimer = setTimeout(function () {
                    _this.log.system(match.name + " | id: " + match.id + " - Timed out");
                    match.matchProcess.kill('SIGKILL');
                    matchTimedOut = true;
                }, _this.overrideOptions.timeout);
            }
            var processingStage = false;
            match.matchProcess.stdout.on('readable', function () {
                var data;
                while ((data = match.matchProcess.stdout.read())) {
                    // split chunks into line by line and handle each line of output
                    var strs = ("" + data).split(/\r?\n/);
                    for (var i = 0; i < strs.length; i++) {
                        var str = strs[i];
                        // skip empties
                        if (str === '')
                            continue;
                        // if we reached conclude command, default being D_MATCH_FINISHED, we start the processing stage
                        if (str === _this.overrideOptions.conclude_command) {
                            processingStage = true;
                        }
                        // else if we aren't in the processing stage
                        else if (!processingStage) {
                            // store all stdout
                            match.state.matchOutput.push(str);
                        }
                        // otherwise we are in processing stage
                        else {
                            // store into results
                            match.results.push(str);
                        }
                    }
                }
            });
            match.matchProcess.stdout.on('close', function (code) {
                _this.log.system(match.name + " | id: " + match.id + " - exited with code " + code);
                if (matchTimedOut) {
                    reject(new DimensionError_1.MatchError('Match timed out'));
                }
                else {
                    clearTimeout(matchProcessTimer);
                    resolve(match.results);
                }
                // remove the agent files if on secureMode and double check it is the temporary directory
                match.agents.forEach(function (agent) {
                    if (agent.options.secureMode) {
                        var tmpdir = os_1.default.tmpdir();
                        if (agent.cwd.slice(0, tmpdir.length) === tmpdir) {
                            System_1.removeDirectorySync(agent.cwd);
                        }
                        else {
                            _this.log.error("couldn't remove agent files while in secure mode");
                        }
                    }
                });
            });
        });
    };
    /**
     * Attempts to stop a {@link Match} based on a custom {@link Design}
     * @param match - the match to stop
     */
    MatchEngine.prototype.stopCustom = function (match) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                // attempt to stop the match
                match.matchProcess.kill('SIGSTOP');
                return [2 /*return*/];
            });
        });
    };
    /**
     * Attempts to resume a {@link Match} based on a custom {@link Design}
     * @param match - the match to resume
     */
    MatchEngine.prototype.resumeCustom = function (match) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                // attempt to resume the match
                match.matchProcess.kill('SIGCONT');
                return [2 /*return*/];
            });
        });
    };
    /**
     * Attempts to kill and clean up anything else for a custom design based match
     * @param match - the match to kill and clean up
     */
    MatchEngine.prototype.killAndCleanCustom = function (match) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                if (match.matchProcess)
                    match.matchProcess.kill('SIGKILL');
                return [2 /*return*/];
            });
        });
    };
    /**
     * Parses a list of arguments for a given match and populates relevant strings as needed
     * @param match - the match to parse arguments for
     * @param args - the arguments to parse
     */
    MatchEngine.prototype.parseCustomArguments = function (match, args) {
        if (match.matchStatus === Match_1.Match.Status.UNINITIALIZED) {
            throw new DimensionError_1.FatalError("Match " + match.id + " - " + match.name + " is not initialized yet");
        }
        var parsed = [];
        for (var i = 0; i < args.length; i++) {
            switch (args[i]) {
                case MatchEngine.DynamicDataStrings.D_FILES:
                    match.agents.forEach(function (agent) {
                        parsed.push(agent.file);
                    });
                    break;
                case MatchEngine.DynamicDataStrings.D_TOURNAMENT_IDS:
                    match.agents.forEach(function (agent) {
                        // pass in tournament ID string if it exists, otherwise pass in 0
                        parsed.push(agent.tournamentID.id ? agent.tournamentID : '0');
                    });
                    break;
                case MatchEngine.DynamicDataStrings.D_AGENT_IDS:
                    match.agents.forEach(function (agent) {
                        parsed.push(agent.id);
                    });
                    break;
                case MatchEngine.DynamicDataStrings.D_MATCH_ID:
                    parsed.push(match.id);
                    break;
                case MatchEngine.DynamicDataStrings.D_MATCH_NAME:
                    parsed.push(match.name);
                    break;
                case MatchEngine.DynamicDataStrings.D_NAMES:
                    match.agents.forEach(function (agent) {
                        var parsedName = agent.name;
                        parsedName = parsedName.replace(/\//g, '-');
                        parsedName = parsedName.replace(/ /g, '_');
                        parsed.push(parsedName);
                    });
                    break;
                default:
                    parsed.push(args[i]);
                    break;
            }
        }
        return parsed;
    };
    /**
     * Returns the logger for this match engine
     */
    MatchEngine.prototype.getLogger = function () {
        return this.log;
    };
    /** approx extra buffer time given to agents due to engine processing for timeout mechanism */
    MatchEngine.timeoutBuffer = 25;
    return MatchEngine;
}());
exports.MatchEngine = MatchEngine;
(function (MatchEngine) {
    /**
     * Various policies available that describe the requirements before an agent is marked as done with sending commands
     * at some time step
     */
    var COMMAND_FINISH_POLICIES;
    (function (COMMAND_FINISH_POLICIES) {
        /**
         * Agent's finish their commands by sending a finish symbol, namely {@link EngineOptions.commandFinishSymbol}
         */
        COMMAND_FINISH_POLICIES["FINISH_SYMBOL"] = "finish_symbol";
        /**
         * Agent's finish their commands by either sending a finish symmbol or after they send
         * {@link EngineOptions.commandLines.max} lines
         */
        COMMAND_FINISH_POLICIES["LINE_COUNT"] = "line_count";
        /**
         * Custom finishing policy provided by user. Not allowed at the moment
         */
        COMMAND_FINISH_POLICIES["CUSTOM"] = "custom";
        // TODO: implement custom finish policy
    })(COMMAND_FINISH_POLICIES = MatchEngine.COMMAND_FINISH_POLICIES || (MatchEngine.COMMAND_FINISH_POLICIES = {}));
    /** Standard ways for commands from agents to be streamed to the MatchEngine for the {@link Design} to handle */
    var COMMAND_STREAM_TYPE;
    (function (COMMAND_STREAM_TYPE) {
        /** First come first serve for commands run. Not implemented */
        COMMAND_STREAM_TYPE["PARALLEL"] = "parallel";
        /** Each agent's set of commands is run before the next agent */
        COMMAND_STREAM_TYPE["SEQUENTIAL"] = "sequential";
    })(COMMAND_STREAM_TYPE = MatchEngine.COMMAND_STREAM_TYPE || (MatchEngine.COMMAND_STREAM_TYPE = {}));
    /**
     * Dynammic Data strings are strings in the {@link OverrideOptions} arguments array that are automatically replaced
     * with dynamic data as defined in the documentation of these enums
     */
    var DynamicDataStrings;
    (function (DynamicDataStrings) {
        /**
         * `D_FILES` is automatically populated by a space seperated string list of the file paths provided for each of the
         * agents competing in a match.
         *
         * NOTE, these paths don't actually need to be files, they can be directories or anything that works with
         * your own command and design
         *
         * @example Suppose the paths to the sources the agents operate on are `path1`, `path2`, `path3`. Then `D_FILES`
         * will be passed into your command as `path1 path2 path3`
         */
        DynamicDataStrings["D_FILES"] = "D_FILES";
        /**
         * `D_AGENT_IDS` is automatically populated by a space seperated string list of the agent IDs of every agent being
         * loaded into a match in the same order as D_FILES. This should always be sorted by default as agents are loaded
         * in order from agent ID `0` to agent ID `n-1`in a `n` agent match
         *
         * @example Suppose a match is running with agents with IDs `0, 1, 2, 3`. Then `D_AGENT_IDS` will be passed into
         * your command as `0 1 2 3`
         */
        DynamicDataStrings["D_AGENT_IDS"] = "D_AGENT_IDS";
        /**
         * `D_TOURNAMENT_IDS` is automatically populated by a space seperated string list of the tournament ID numbers of
         * the agents being loaded into the match in the same order. If no tournament is being run all the ID numbers will
         * default to 0 but still be passed in to the command you give for the override configurations
         *
         * @example Suppose a match in a tournament is running 2 agents with tournament IDs `Qb6NyTxufGGU`, `EGg3tSN2KUgl`
         * Then `D_TOURNAMENT_IDS` will be passed into your command as `Qb6NyTxufGGU EGg3tSN2KUgl`
         */
        DynamicDataStrings["D_TOURNAMENT_IDS"] = "D_TOURNAMENT_IDS";
        /**
         * D_MATCH_ID is automatically replaced with the id of the match being run
         *
         * @example Suppose the match has ID `eF1uEacgfgMm`, then `D_MATCH_ID` is passed into your command as `eF1uEacgfgMm`
         */
        DynamicDataStrings["D_MATCH_ID"] = "D_MATCH_ID";
        /**
         * D_MATCH_NAME is automatically replaced with the name of the match being run
         *
         * @example Suppose the match has name 'my_match'. Then `D_MATCH_NAME` is passed into your commnad as `my_match`
         */
        DynamicDataStrings["D_MATCH_NAME"] = "D_MATCH_NAME";
        /**
         * D_NAMES is automatically replaced with the names of the agents
         *
         * @example Suppose the agents 0 and 1 had names `bob, richard`. Then `D_NAMES` is passed into your command as
         * `bob richard`
         */
        DynamicDataStrings["D_NAMES"] = "D_NAMES";
    })(DynamicDataStrings = MatchEngine.DynamicDataStrings || (MatchEngine.DynamicDataStrings = {}));
})(MatchEngine = exports.MatchEngine || (exports.MatchEngine = {}));
exports.MatchEngine = MatchEngine;
exports.DefaultMatchEngineOptions = {
    commandStreamType: MatchEngine.COMMAND_STREAM_TYPE.SEQUENTIAL,
    commandDelimiter: ',',
    commandFinishSymbol: 'D_FINISH',
    commandFinishPolicy: MatchEngine.COMMAND_FINISH_POLICIES.FINISH_SYMBOL,
    commandLines: {
        max: 1,
        // min: 1
        waitForNewline: true,
    },
    noStdErr: true,
    timeout: {
        max: 1000,
        active: true,
        timeoutCallback: function (agent, match, engineOptions) {
            match.kill(agent.id, 'timed out');
            match.log.error("agent " + agent.id + " - '" + agent.name + "' timed out after " + engineOptions.timeout.max + " ms");
        },
    },
    memory: {
        limit: 1000000000,
        active: true,
        usePs: true,
        memoryCallback: function (agent, match, engineOptions) {
            match.kill(agent.id, 'exceed memory limit');
            match.log.error("agent " + agent.id + " - '" + agent.name + "' reached the memory limit of " + engineOptions.memory.limit / 1000000 + " MB");
        },
        checkRate: 100,
    },
};
//# sourceMappingURL=index.js.map