"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var DeepMerge_1 = require("../utils/DeepMerge");
var MatchEngine_1 = require("../MatchEngine");
var Agent_1 = require("../Agent");
var Logger_1 = require("../Logger");
var DimensionError_1 = require("../DimensionError");
var COMMAND_STREAM_TYPE = MatchEngine_1.MatchEngine.COMMAND_STREAM_TYPE;
var utils_1 = require("../utils");
var DeepCopy_1 = require("../utils/DeepCopy");
var path_1 = __importDefault(require("path"));
var extract_zip_1 = __importDefault(require("extract-zip"));
var System_1 = require("../utils/System");
var Station_1 = require("../Station");
var fs_1 = require("fs");
/**
 * An match created using a {@link Design} and a list of Agents. The match can be stopped and resumed with
 * {@link stop}, {@link resume}, and state and configurations can be retrieved at any point in time with the
 * {@link state} and {@link configs} fields
 *
 * @see {@link Design} for Design information
 * @see {@link Agent} for Agent information
 */
var Match = /** @class */ (function () {
    /**
     * Match Constructor
     * @param design - The {@link Design} used
     * @param agents - List of agents used to create Match.
     * @param configs - Configurations that are passed to every run through {@link Design.initialize}, {@link Design.update}, and {@link Design.getResults} functioon in the
     * given {@link Design}
     */
    function Match(design, 
    /**
     * agent meta data regarding files, ids, etc.
     */
    agentFiles, configs, dimension) {
        if (configs === void 0) { configs = {}; }
        this.design = design;
        this.agentFiles = agentFiles;
        this.dimension = dimension;
        /**
         * List of the agents currently involved in the match.
         * @See {@link Agent} for details on the agents.
         */
        this.agents = [];
        /**
         * Map from an {@link Agent.ID} ID to the {@link Agent}
         */
        this.idToAgentsMap = new Map();
        /**
         * The current time step of the Match. This time step is independent of any {@link Design} and agents are coordianted
         * against this timeStep
         */
        this.timeStep = 0;
        /**
         * The match logger.
         * @see {@link Logger} for details on how to use this
         */
        this.log = new Logger_1.Logger();
        /**
         * The results field meant to store any results retrieved with {@link Design.getResults}
         * @default `null`
         */
        this.results = null;
        /**
         * The current match status
         */
        this.matchStatus = Match.Status.UNINITIALIZED;
        /**
         * A mapping from {@link Agent} IDs to the tournament id of the {@link Player} in a tournament that generated the
         * {@link Agent}
         */
        this.mapAgentIDtoTournamentID = new Map();
        /**
         * Match Configurations. See {@link Match.Configs} for configuration options
         */
        this.configs = {
            name: '',
            loggingLevel: Logger_1.Logger.LEVEL.INFO,
            engineOptions: {},
            secureMode: false,
            agentOptions: DeepCopy_1.deepCopy(Agent_1.Agent.OptionDefaults),
            languageSpecificAgentOptions: {},
            storeReplay: true,
            storeReplayDirectory: 'replays',
            storeErrorLogs: true,
            storeErrorDirectory: 'errorlogs',
            agentSpecificOptions: [],
            storeMatchErrorLogs: false,
            detached: false,
        };
        /** Signal to stop at next time step */
        this.shouldStop = false;
        /**
         * Non local files that should be removed as they are stored somewhere else. Typically bot files are non local if
         * using a backing storage service
         */
        this.nonLocalFiles = [];
        // override configs with provided configs argument
        this.configs = DeepMerge_1.deepMerge(DeepCopy_1.deepCopy(this.configs), DeepCopy_1.deepCopy(configs));
        // agent runs in securemode if parent match is in securemode
        this.configs.agentOptions.secureMode = this.configs.secureMode;
        // agent logging level is inherited from parent match.
        this.configs.agentOptions.loggingLevel = this.configs.loggingLevel;
        this.id = Match.genMatchID();
        this.creationDate = new Date();
        if (this.configs.name) {
            this.name = this.configs.name;
        }
        else {
            this.name = "match_" + this.id;
        }
        // set logging level to what was given
        this.log.level = this.configs.loggingLevel;
        this.log.identifier = this.name;
        // store reference to the matchEngine used and override any options
        this.matchEngine = new MatchEngine_1.MatchEngine(this.design, this.log.level);
        this.matchEngine.setEngineOptions(configs.engineOptions);
    }
    /**
     * Initializes this match using its configurations and using the {@link Design.initialize} function. This can
     * throw error with agent generation, design initialization, or with engine initialization. In engine initialization,
     * errors that can be thrown can be {@link AgentCompileError | AgentCompileErrors},
     * {@link AgentInstallError | AgentInstallErrors}, etc.
     *
     *
     * @returns a promise that resolves true if initialized correctly
     */
    Match.prototype.initialize = function () {
        return __awaiter(this, void 0, void 0, function () {
            var overrideOptions, matchErrorLogDirectory, retrieveBotFilePromises_1, retrieveBotFileIndexes_1, retrievedBotFiles_1, err_1;
            var _this = this;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        _a.trys.push([0, 7, , 10]);
                        this.log.infobar();
                        this.log.info("Design: " + this.design.name + " | Initializing match - ID: " + this.id + ", Name: " + this.name);
                        overrideOptions = this.design.getDesignOptions().override;
                        this.log.detail('Match Configs', this.configs);
                        this.timeStep = 0;
                        if (this.configs.storeErrorLogs) {
                            // create error log folder if it does not exist
                            if (!fs_1.existsSync(this.configs.storeErrorDirectory)) {
                                fs_1.mkdirSync(this.configs.storeErrorDirectory);
                            }
                            matchErrorLogDirectory = this.getMatchErrorLogDirectory();
                            if (!fs_1.existsSync(matchErrorLogDirectory)) {
                                fs_1.mkdirSync(matchErrorLogDirectory);
                            }
                        }
                        // this allows engine to be reused after it ran once
                        this.matchEngine.killOffSignal = false;
                        retrieveBotFilePromises_1 = [];
                        retrieveBotFileIndexes_1 = [];
                        if (this.dimension.hasStorage()) {
                            this.agentFiles.forEach(function (agentFile, index) {
                                if (agentFile.botkey && agentFile.file) {
                                    var useCachedBotFile = false;
                                    if (_this.configs.agentSpecificOptions[index] &&
                                        _this.configs.agentSpecificOptions[index].useCachedBotFile) {
                                        useCachedBotFile = true;
                                    }
                                    retrieveBotFilePromises_1.push(_this.retrieveBot(agentFile.botkey, agentFile.file, useCachedBotFile));
                                    retrieveBotFileIndexes_1.push(index);
                                }
                            });
                        }
                        return [4 /*yield*/, Promise.all(retrieveBotFilePromises_1)];
                    case 1:
                        retrievedBotFiles_1 = _a.sent();
                        retrieveBotFileIndexes_1.forEach(function (val, index) {
                            if (!(typeof _this.agentFiles[val] === 'string')) {
                                // eslint-disable-next-line @typescript-eslint/ban-ts-comment
                                // @ts-ignore
                                _this.agentFiles[val].file = retrievedBotFiles_1[index];
                                // push them as non local files so they can be removed when match is done
                                _this.nonLocalFiles.push(path_1.default.dirname(retrievedBotFiles_1[index]));
                            }
                        });
                        // Initialize agents with agent files
                        this.agents = Agent_1.Agent.generateAgents(this.agentFiles, this.configs.agentOptions, this.configs.languageSpecificAgentOptions);
                        this.agents.forEach(function (agent) {
                            _this.idToAgentsMap.set(agent.id, agent);
                            if (agent.tournamentID !== null) {
                                _this.mapAgentIDtoTournamentID.set(agent.id, agent.tournamentID);
                            }
                        });
                        if (!!this.configs.detached) return [3 /*break*/, 5];
                        if (!overrideOptions.active) return [3 /*break*/, 3];
                        this.log.detail('Match Arguments', overrideOptions.arguments);
                        return [4 /*yield*/, this.matchEngine.initializeCustom()];
                    case 2:
                        _a.sent();
                        return [3 /*break*/, 5];
                    case 3: 
                    // Initialize the matchEngine and get it ready to run and process I/O for agents
                    return [4 /*yield*/, this.matchEngine.initialize(this.agents, this)];
                    case 4:
                        // Initialize the matchEngine and get it ready to run and process I/O for agents
                        _a.sent();
                        _a.label = 5;
                    case 5: 
                    // by now all agents should up and running, all compiled and ready
                    // Initialize match according to `design` by delegating intialization task to the enforced `design`
                    return [4 /*yield*/, this.design.initialize(this)];
                    case 6:
                        // by now all agents should up and running, all compiled and ready
                        // Initialize match according to `design` by delegating intialization task to the enforced `design`
                        _a.sent();
                        // remove initialized status and set as READY
                        this.matchStatus = Match.Status.READY;
                        return [2 /*return*/, true];
                    case 7:
                        err_1 = _a.sent();
                        return [4 /*yield*/, this.handleLogFiles()];
                    case 8:
                        _a.sent();
                        // kill processes and clean up and then throw the error
                        return [4 /*yield*/, this.killAndCleanUp()];
                    case 9:
                        // kill processes and clean up and then throw the error
                        _a.sent();
                        if (err_1 instanceof DimensionError_1.AgentError) {
                            if (err_1 instanceof DimensionError_1.AgentCompileError ||
                                err_1 instanceof DimensionError_1.AgentInstallError) {
                                // mark agents with compile or install error as having crashed
                                // console.log(err, err.agentID);
                                this.agents[err_1.agentID].status = Agent_1.Agent.Status.CRASHED;
                            }
                        }
                        throw err_1;
                    case 10: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Retrieves a bot through its key and downloads it to a random generated folder. Returns the new file's path
     * @param botkey
     * @param file
     * @param useCached - if true, storage plugin will avoid redownloading data. If false, storage plugin will always
     * redownload data
     */
    Match.prototype.retrieveBot = function (botkey, file, useCached) {
        return __awaiter(this, void 0, void 0, function () {
            var dir, zipFile, actualZipFileLocation;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        dir = Station_1.BOT_DIR + '/anon-' + utils_1.genID(18);
                        fs_1.mkdirSync(dir);
                        zipFile = path_1.default.join(dir, 'bot.zip');
                        return [4 /*yield*/, this.dimension.storagePlugin.download(botkey, zipFile, useCached)];
                    case 1:
                        actualZipFileLocation = _a.sent();
                        return [4 /*yield*/, extract_zip_1.default(actualZipFileLocation, {
                                dir: dir,
                            })];
                    case 2:
                        _a.sent();
                        return [2 /*return*/, path_1.default.join(dir, path_1.default.basename(file))];
                }
            });
        });
    };
    /**
     * Runs this match to completion. Sets this.results to match results and resolves with the match results when done
     */
    Match.prototype.run = function () {
        var _this = this;
        // returning new promise explicitly here because we need to store reject
        // eslint-disable-next-line no-async-promise-executor
        return new Promise(function (resolve, reject) { return __awaiter(_this, void 0, void 0, function () {
            var status_1, overrideOptions, _a, _b, fileName, key, error_1;
            return __generator(this, function (_c) {
                switch (_c.label) {
                    case 0:
                        _c.trys.push([0, 19, , 20]);
                        this.runReject = reject;
                        this.matchStatus = Match.Status.RUNNING;
                        overrideOptions = this.design.getDesignOptions().override;
                        if (!overrideOptions.active) return [3 /*break*/, 3];
                        this.log.system('Running custom');
                        return [4 /*yield*/, this.matchEngine.runCustom(this)];
                    case 1:
                        _c.sent();
                        _a = this;
                        return [4 /*yield*/, this.getResults()];
                    case 2:
                        _a.results = _c.sent();
                        // process results with result handler if necessary
                        if (overrideOptions.resultHandler) {
                            this.results = overrideOptions.resultHandler(this.results);
                        }
                        return [3 /*break*/, 8];
                    case 3: return [4 /*yield*/, this.next()];
                    case 4:
                        status_1 = _c.sent();
                        _c.label = 5;
                    case 5:
                        if (status_1 != Match.Status.FINISHED) return [3 /*break*/, 3];
                        _c.label = 6;
                    case 6:
                        this.agents.forEach(function (agent) {
                            agent._clearTimer();
                        });
                        _b = this;
                        return [4 /*yield*/, this.getResults()];
                    case 7:
                        _b.results = _c.sent();
                        _c.label = 8;
                    case 8: 
                    // kill processes and clean up
                    return [4 /*yield*/, this.killAndCleanUp()];
                    case 9:
                        // kill processes and clean up
                        _c.sent();
                        if (!this.results.replayFile) return [3 /*break*/, 17];
                        if (!fs_1.existsSync(this.results.replayFile)) return [3 /*break*/, 16];
                        if (!!fs_1.statSync(this.results.replayFile).isDirectory()) return [3 /*break*/, 14];
                        if (!this.configs.storeReplay) return [3 /*break*/, 12];
                        this.replayFile = this.results.replayFile;
                        if (!this.dimension.hasStorage()) return [3 /*break*/, 11];
                        fileName = path_1.default.basename(this.results.replayFile);
                        return [4 /*yield*/, this.dimension.storagePlugin.upload(this.results.replayFile, "" + path_1.default.join(this.configs.storeReplayDirectory, fileName))];
                    case 10:
                        key = _c.sent();
                        this.replayFileKey = key;
                        // once uploaded and meta data stored, remove old file
                        System_1.removeFile(this.replayFile);
                        _c.label = 11;
                    case 11: return [3 /*break*/, 13];
                    case 12:
                        System_1.removeFile(this.results.replayFile);
                        _c.label = 13;
                    case 13: return [3 /*break*/, 15];
                    case 14:
                        reject(new DimensionError_1.MatchReplayFileError("Replay file provided " + this.results.replayFile + " is not a file"));
                        _c.label = 15;
                    case 15: return [3 /*break*/, 17];
                    case 16:
                        reject(new DimensionError_1.MatchReplayFileError("Replay file provided " + this.results.replayFile + " does not exist"));
                        _c.label = 17;
                    case 17: return [4 /*yield*/, this.handleLogFiles()];
                    case 18:
                        _c.sent();
                        this.finishDate = new Date();
                        resolve(this.results);
                        return [3 /*break*/, 20];
                    case 19:
                        error_1 = _c.sent();
                        reject(error_1);
                        return [3 /*break*/, 20];
                    case 20: return [2 /*return*/];
                }
            });
        }); });
    };
    /**
     * Handles log files and stores / uploads / deletes them as necessary
     */
    Match.prototype.handleLogFiles = function () {
        return __awaiter(this, void 0, void 0, function () {
            var uploadLogPromises, fileLogsToRemove, _loop_1, this_1, _i, _a, agent, logkeys;
            var _this = this;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        uploadLogPromises = [];
                        fileLogsToRemove = [];
                        // upload error logs if stored
                        if (this.configs.storeErrorLogs) {
                            _loop_1 = function (agent) {
                                var filepath = path_1.default.join(this_1.getMatchErrorLogDirectory(), agent.getAgentErrorLogFilename());
                                if (fs_1.existsSync(filepath)) {
                                    // check if replay file is empty
                                    if (agent._logsize === 0) {
                                        fileLogsToRemove.push(filepath);
                                    }
                                    else if (this_1.dimension.hasStorage()) {
                                        var uploadKeyPromise = this_1.dimension.storagePlugin
                                            .upload(filepath, filepath)
                                            .then(function (key) {
                                            return { key: key, agentID: agent.id };
                                        });
                                        uploadLogPromises.push(uploadKeyPromise);
                                        fileLogsToRemove.push(filepath);
                                    }
                                }
                                else {
                                    // this shouldn't happen
                                    this_1.log.error("Agent " + this_1.id + " log file at " + filepath + " does not exist");
                                }
                            };
                            this_1 = this;
                            // upload each agent error log
                            for (_i = 0, _a = this.agents; _i < _a.length; _i++) {
                                agent = _a[_i];
                                _loop_1(agent);
                            }
                        }
                        return [4 /*yield*/, Promise.all(uploadLogPromises)];
                    case 1:
                        logkeys = _b.sent();
                        logkeys.forEach(function (val) {
                            _this.idToAgentsMap.get(val.agentID).logkey = val.key;
                        });
                        if (fileLogsToRemove.length === this.agents.length) {
                            System_1.removeDirectory(this.getMatchErrorLogDirectory());
                        }
                        else {
                            fileLogsToRemove.forEach(function (logPath) {
                                System_1.removeFile(logPath);
                            });
                        }
                        return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Step forward the match by one timestep by sending commands individually.
     */
    Match.prototype.step = function (commands) {
        var _a;
        return __awaiter(this, void 0, void 0, function () {
            var engineOptions, status_2;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        engineOptions = this.matchEngine.getEngineOptions();
                        if (!(engineOptions.commandStreamType === COMMAND_STREAM_TYPE.SEQUENTIAL)) return [3 /*break*/, 2];
                        return [4 /*yield*/, this.design.update(this, commands)];
                    case 1:
                        status_2 = (_a = (_b.sent())) !== null && _a !== void 0 ? _a : Match.Status.RUNNING;
                        return [2 /*return*/, status_2];
                    case 2: throw new DimensionError_1.NotSupportedError('Only sequential streaming is allowed');
                }
            });
        });
    };
    /**
     * Next function. Moves match forward by one timestep. Resolves with the match status
     * This function should always used to advance forward a match unless a custom design is provided
     *
     * Gathers commands from agents via the {@link MatchEngine}
     *
     * Should not be called by user
     */
    Match.prototype.next = function () {
        return __awaiter(this, void 0, void 0, function () {
            var engineOptions, commands, status_3;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        engineOptions = this.matchEngine.getEngineOptions();
                        if (!(engineOptions.commandStreamType === COMMAND_STREAM_TYPE.SEQUENTIAL)) return [3 /*break*/, 5];
                        if (!(this.shouldStop == true)) return [3 /*break*/, 2];
                        // set status and stop the engine
                        this.matchStatus = Match.Status.STOPPED;
                        this.matchEngine.stop(this);
                        this.log.info('Stopped match');
                        this.resolveStopPromise();
                        return [4 /*yield*/, this.resumePromise];
                    case 1:
                        _a.sent();
                        this.matchEngine.resume(this);
                        this.log.info('Resumed match');
                        this.shouldStop = false;
                        _a.label = 2;
                    case 2:
                        // we reset each Agent for the next move
                        this.agents.forEach(function (agent) {
                            // continue agents again
                            agent.resume();
                            // setup the agent and its promises and get it ready for the next move
                            agent._setupMove();
                            // if timeout is set active and agent not already terminated
                            if (engineOptions.timeout.active && !agent.isTerminated()) {
                                agent._setTimeout(function () {
                                    // if agent times out, emit the timeout event
                                    agent.timeout();
                                }, engineOptions.timeout.max + MatchEngine_1.MatchEngine.timeoutBuffer);
                            }
                            // each of these steps can take ~2 ms
                        });
                        return [4 /*yield*/, this.matchEngine.getCommands(this)];
                    case 3:
                        commands = _a.sent();
                        this.log.system("Retrieved " + commands.length + " commands");
                        return [4 /*yield*/, this.design.update(this, commands)];
                    case 4:
                        status_3 = _a.sent();
                        // default status is running if no status returned
                        if (!status_3) {
                            this.matchStatus = Match.Status.RUNNING;
                        }
                        else {
                            this.matchStatus = status_3;
                        }
                        // update timestep now
                        this.timeStep += 1;
                        return [2 /*return*/, status_3];
                    case 5:
                        if (engineOptions.commandStreamType === COMMAND_STREAM_TYPE.PARALLEL) {
                            // with a parallel structure, the `Design` updates the match after each command sequence, delimited by \n
                            // this means agents end up sending commands using out of sync state information, so the `Design` would need to
                            // adhere to this. Possibilities include stateless designs, or heavily localized designs where out of
                            // sync states wouldn't matter much
                            throw new DimensionError_1.NotSupportedError('PARALLEL command streaming has not been implemented yet');
                        }
                        _a.label = 6;
                    case 6: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Stops the match. For non-custom designs, stops at the next nearest timestep possible. Otherwise attempts to stop
     * the match using the {@link MatchEngine} stopCustom function.
     *
     * Notes:
     * - If design uses a PARALLEL match engine, stopping behavior can be a little unpredictable
     * - If design uses a SEQUENTIAL match engine, a stop will result in ensuring all agents complete all their actions up
     *   to a coordinated stopping `timeStep`
     */
    Match.prototype.stop = function () {
        var _this = this;
        return new Promise(function (resolve, reject) {
            if (_this.matchStatus != Match.Status.RUNNING) {
                _this.log.warn("You can't stop a match that is not running");
                reject(new DimensionError_1.MatchWarn('You can\t stop a match that is not running'));
                return;
            }
            // if override is on, we stop using the matchEngine stop function
            if (_this.design.getDesignOptions().override.active) {
                _this.matchEngine
                    .stopCustom(_this)
                    .then(function () {
                    _this.matchStatus = Match.Status.STOPPED;
                    resolve();
                })
                    .catch(reject);
                return;
            }
            else {
                _this.resolveStopPromise = resolve;
                _this.log.info('Stopping match...');
                _this.resumePromise = new Promise(function (resolve) {
                    _this.resumeResolve = resolve;
                });
                _this.shouldStop = true;
            }
        });
    };
    /**
     * Resume the match if it was in the stopped state
     * @returns true if succesfully resumed
     */
    Match.prototype.resume = function () {
        var _this = this;
        return new Promise(function (resolve, reject) {
            if (_this.matchStatus != Match.Status.STOPPED) {
                _this.log.warn("You can't resume a match that is not stopped");
                reject(new DimensionError_1.MatchWarn("You can't resume a match that is not stopped"));
                return;
            }
            _this.log.info('Resuming match...');
            // if override is on, we resume using the matchEngine resume function
            if (_this.design.getDesignOptions().override.active) {
                _this.matchEngine
                    .resumeCustom(_this)
                    .then(function () {
                    _this.matchStatus = Match.Status.RUNNING;
                    resolve();
                })
                    .catch(reject);
            }
            else {
                // set back to running and resolve
                _this.matchStatus = Match.Status.RUNNING;
                _this.resumeResolve();
                resolve();
            }
        });
    };
    /**
     * Stop all agents through the match engine and clean up any other files and processes
     *
     * Used by custom and dimensions based designs
     */
    Match.prototype.killAndCleanUp = function () {
        return __awaiter(this, void 0, void 0, function () {
            var removeNonLocalFilesPromises;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.matchEngine.killAndClean(this)];
                    case 1:
                        _a.sent();
                        removeNonLocalFilesPromises = [];
                        this.nonLocalFiles.forEach(function (nonLocalFile) {
                            removeNonLocalFilesPromises.push(System_1.removeDirectory(nonLocalFile));
                        });
                        return [4 /*yield*/, Promise.all(removeNonLocalFilesPromises)];
                    case 2:
                        _a.sent();
                        return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Terminate an {@link Agent}, kill the process. Note, the agent is still stored in the Match, but you can't send or
     * receive messages from it anymore
     *
     * @param agent - id of agent or the Agent object to kill
     * @param reason - an optional reason string to provide for logging purposes
     */
    Match.prototype.kill = function (agent, reason) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                if (agent instanceof Agent_1.Agent) {
                    this.matchEngine.kill(agent, reason);
                }
                else {
                    this.matchEngine.kill(this.idToAgentsMap.get(agent), reason);
                }
                return [2 /*return*/];
            });
        });
    };
    /**
     * Retrieve results through delegating the task to {@link Design.getResults}
     */
    Match.prototype.getResults = function () {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.design.getResults(this)];
                    case 1: 
                    // Retrieve match results according to `design` by delegating storeResult task to the enforced `design`
                    return [2 /*return*/, _a.sent()];
                }
            });
        });
    };
    /**
     * Sends a message to the standard input of all agents in this match
     * @param message - the message to send to all agents available
     * @returns a promise resolving true/false if it was succesfully sent
     */
    Match.prototype.sendAll = function (message) {
        var _this = this;
        return new Promise(function (resolve) {
            var sendPromises = [];
            _this.agents.forEach(function (agent) {
                sendPromises.push(_this.send(message, agent));
            });
            Promise.all(sendPromises).then(function (sendStatus) {
                // if all promises resolve, we sent all messages
                resolve(sendStatus.every(function (v) { return v === true; }));
            });
        });
    };
    /**
     * Functional method for sending a message string to a particular {@link Agent}. Returns a promise that resolves true
     * if succesfully sent. Returns false if could not send message, meaning agent was also killed.
     * @param message - the string message to send
     * @param receiver - receiver of message can be specified by the {@link Agent} or it's {@link Agent.ID} (a number)
     */
    Match.prototype.send = function (message, receiver) {
        return __awaiter(this, void 0, void 0, function () {
            var err_2, err_3;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!(receiver instanceof Agent_1.Agent)) return [3 /*break*/, 6];
                        _a.label = 1;
                    case 1:
                        _a.trys.push([1, 3, , 5]);
                        return [4 /*yield*/, this.matchEngine.send(this, message, receiver.id)];
                    case 2:
                        _a.sent();
                        return [3 /*break*/, 5];
                    case 3:
                        err_2 = _a.sent();
                        this.log.error(err_2);
                        return [4 /*yield*/, this.kill(receiver, 'could not send message anymore')];
                    case 4:
                        _a.sent();
                        return [2 /*return*/, false];
                    case 5: return [3 /*break*/, 10];
                    case 6:
                        _a.trys.push([6, 8, , 10]);
                        return [4 /*yield*/, this.matchEngine.send(this, message, receiver)];
                    case 7:
                        _a.sent();
                        return [3 /*break*/, 10];
                    case 8:
                        err_3 = _a.sent();
                        this.log.error(err_3);
                        return [4 /*yield*/, this.kill(receiver, 'could not send message anymore')];
                    case 9:
                        _a.sent();
                        return [2 /*return*/, false];
                    case 10: return [2 /*return*/, true];
                }
            });
        });
    };
    /**
     * Throw an {@link FatalError}, {@link MatchError}, or {@link MatchWarn} within the Match. Indicates that the
     * {@link Agent} with id agentID caused this error/warning.
     *
     * Throwing MatchWarn will just log a warning level message and throwing a MatchError will just log it as an error
     * level message.
     *
     * Throwing FatalError will cause the match to automatically be destroyed. This is highly not recommended and it is
     * suggested to have some internal logic to handle moments when the match cannot continue.
     *
     *
     * Examples are misuse of an existing command or using incorrect commands or sending too many commands
     * @param agentID - the misbehaving agent's ID
     * @param error - The error
     */
    Match.prototype.throw = function (agentID, error) {
        return __awaiter(this, void 0, void 0, function () {
            var agent, msg, msg, msg;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        agent = this.idToAgentsMap.get(agentID);
                        if (!(error instanceof DimensionError_1.FatalError)) return [3 /*break*/, 2];
                        return [4 /*yield*/, this.destroy()];
                    case 1:
                        _a.sent();
                        msg = "FatalError: " + agent.name + " | " + error.message;
                        this.log.error(msg);
                        if (this.configs.storeMatchErrorLogs)
                            agent.writeToErrorLog(msg);
                        return [3 /*break*/, 3];
                    case 2:
                        if (error instanceof DimensionError_1.MatchWarn) {
                            msg = "ID: " + agentID + ", " + this.idToAgentsMap.get(agentID).name + " | " + error.message;
                            this.log.warn(msg);
                            if (this.configs.storeMatchErrorLogs)
                                agent.writeToErrorLog(msg);
                        }
                        else if (error instanceof DimensionError_1.MatchError) {
                            msg = "ID: " + agentID + ", " + this.idToAgentsMap.get(agentID).name + " | " + error.message;
                            this.log.error(msg);
                            if (this.configs.storeMatchErrorLogs)
                                agent.writeToErrorLog(msg);
                        }
                        else {
                            this.log.error('User tried throwing an error of type other than FatalError, MatchWarn, or MatchError');
                        }
                        _a.label = 3;
                    case 3: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Destroys this match and makes sure to remove any leftover processes
     */
    Match.prototype.destroy = function () {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        // reject the run promise first if it exists
                        if (this.runReject)
                            this.runReject(new DimensionError_1.MatchDestroyedError('Match was destroyed'));
                        // now actually stop and clean up
                        return [4 /*yield*/, this.killAndCleanUp()];
                    case 1:
                        // now actually stop and clean up
                        _a.sent(); // Theoretically this line is not needed for custom matches, but in here in case
                        return [4 /*yield*/, this.matchEngine.killAndCleanCustom(this)];
                    case 2:
                        _a.sent();
                        return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Generates a 12 character nanoID string for identifying matches
     */
    Match.genMatchID = function () {
        return utils_1.genID(12);
    };
    Match.prototype.getMatchErrorLogDirectory = function () {
        return path_1.default.join(this.configs.storeErrorDirectory, "match_" + this.id);
    };
    return Match;
}());
exports.Match = Match;
(function (Match) {
    var Status;
    (function (Status) {
        /** Match was created with new but initialize was not called */
        Status["UNINITIALIZED"] = "uninitialized";
        /**
         * If the match has been initialized and checks have been passed, the match is ready to run using {@link Match.run}
         */
        Status["READY"] = "ready";
        /**
         * If the match is running at the moment
         */
        Status["RUNNING"] = "running";
        /**
         * If the match is stopped
         */
        Status["STOPPED"] = "stopped";
        /**
         * If the match is completed
         */
        Status["FINISHED"] = "finished";
        /**
         * If fatal error occurs in Match, appears when match stops itself
         */
        Status["ERROR"] = "error";
    })(Status = Match.Status || (Match.Status = {}));
})(Match = exports.Match || (exports.Match = {}));
exports.Match = Match;
//# sourceMappingURL=index.js.map