import { Tournament } from '..';
/**
 * The Scheduler class with functions to help schedule tournament matches
 */
export declare class Scheduler {
    /**
     * Randomly picks enough players for a match and schedules a match with them.
     *
     * Returns the Scheduler function that can
     * be passed to the {@link Ladder.Configs.matchMake} field
     */
    static Random(configs?: Scheduler.RandomConfigs): (players: Array<Tournament.Ladder.PlayerStat>) => Array<Tournament.QueuedMatch>;
    /**
     * Randomly picks one player and randomly selects enough players within `configs.range` ranks of the first picked
     * player. If there are not enough players within `configs.range` ranks due to a player having a rank close to 1 or
     * the very bottom, it will be appropriately padded on the higher or lower ranking side. If there are still not enough
     * players to choose from, then algorithm selects from what is available.
     *
     * This is also the default algorithm used by the {@link Tournament.Ladder | Ladder Tournament}
     *
     * Returns the Scheduler function that can
     * be passed to the {@link Ladder.Configs.matchMake} field
     */
    static RankRangeRandom(configs?: Scheduler.RankRangeRandomConfigs): (players: Array<Tournament.Ladder.PlayerStat>) => Array<Tournament.QueuedMatch>;
    static _GenerateRankRangeRandom(configs: Scheduler.RankRangeRandomConfigs, rng: () => number, players: Array<Tournament.Ladder.PlayerStat>, i: number): Tournament.QueuedMatch;
    /**
     * Generates matchCount matches using variance of player rankings as weighting to decide which players get matches
     *
     * Uses RankRanged random to generate matches
     *
     */
    static TrueskillVarianceWeighted(configs?: Scheduler.TrueskillVarianceWeighted): (players: Array<Tournament.Ladder.PlayerStat>) => Array<Tournament.QueuedMatch>;
}
export declare namespace Scheduler {
    interface ConfigsBase {
        /**
         * array of possible number of agents/players that can be put in single match, e.g. [2, 4] means 2 or 4 agents can
         * compete together
         *
         * @default `[2]`
         */
        agentsPerMatch: Array<number>;
        /**
         * If true, scheduler will ensure every player will compete in the same number of matches as other players by
         * iterating each player and queueing a match with that player in it
         *
         * Otherwise the scheduler will randomly queue one appropriate match for a random player
         *
         * @default `true`
         */
        scheduleEvenly?: boolean;
        /**
         * If false, will not schedule matches with players that are disabled (manually by an admin or due to compile
         * errors etc.)
         *
         * @default `false`
         */
        allowDisabled?: boolean;
    }
    interface RandomConfigs extends ConfigsBase {
        /** an optional seed to seed the random number generator */
        seed?: any;
    }
    interface RankRangeRandomConfigs extends ConfigsBase {
        /** the range of rankings a player can be competing with */
        range: number;
        /** an optional seed to seed the random number generator */
        seed?: any;
    }
    interface TrueskillVarianceWeighted extends ConfigsBase {
        seed?: any;
        matchCount: number;
        range: number;
    }
}
