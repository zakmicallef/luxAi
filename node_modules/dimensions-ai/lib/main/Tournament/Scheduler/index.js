"use strict";
var __spreadArrays = (this && this.__spreadArrays) || function () {
    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
    for (var r = Array(s), k = 0, i = 0; i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
            r[k] = a[j];
    return r;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var seedrandom_1 = __importDefault(require("seedrandom"));
var utils_1 = require("./utils");
/**
 * The Scheduler class with functions to help schedule tournament matches
 */
var Scheduler = /** @class */ (function () {
    function Scheduler() {
    }
    /**
     * Randomly picks enough players for a match and schedules a match with them.
     *
     * Returns the Scheduler function that can
     * be passed to the {@link Ladder.Configs.matchMake} field
     */
    Scheduler.Random = function (configs) {
        if (configs === void 0) { configs = { agentsPerMatch: [2] }; }
        var rng = seedrandom_1.default(configs.seed);
        return function (origPlayers) {
            var players = origPlayers;
            if (configs.allowDisabled !== true) {
                players = origPlayers.filter(function (p) { return !p.player.disabled; });
            }
            var queue = [];
            if (configs.scheduleEvenly !== false) {
                var _loop_1 = function (i) {
                    var agentCount = configs.agentsPerMatch[Math.floor(rng() * configs.agentsPerMatch.length)];
                    // note: filter is faster than doing [...players.slice(0, i), ...players.slice(i+1)]
                    var chosen = utils_1.chooseKRandomElements(players.filter(function (_, j) { return j != i; }), agentCount - 1).map(function (p) { return p.player.tournamentID.id; });
                    chosen.push(players[i].player.tournamentID.id);
                    queue.push(chosen);
                };
                for (var i = 0; i < players.length; i++) {
                    _loop_1(i);
                }
            }
            else {
                var agentCount = configs.agentsPerMatch[Math.floor(rng() * configs.agentsPerMatch.length)];
                var chosen = utils_1.chooseKRandomElements(players, agentCount).map(function (p) { return p.player.tournamentID.id; });
                queue.push(chosen);
            }
            return queue;
        };
    };
    /**
     * Randomly picks one player and randomly selects enough players within `configs.range` ranks of the first picked
     * player. If there are not enough players within `configs.range` ranks due to a player having a rank close to 1 or
     * the very bottom, it will be appropriately padded on the higher or lower ranking side. If there are still not enough
     * players to choose from, then algorithm selects from what is available.
     *
     * This is also the default algorithm used by the {@link Tournament.Ladder | Ladder Tournament}
     *
     * Returns the Scheduler function that can
     * be passed to the {@link Ladder.Configs.matchMake} field
     */
    Scheduler.RankRangeRandom = function (configs) {
        var _this = this;
        if (configs === void 0) { configs = {
            agentsPerMatch: [2],
            range: 4,
            seed: 0,
        }; }
        var rng = seedrandom_1.default(configs.seed);
        return function (origPlayers) {
            var players = origPlayers;
            if (configs.allowDisabled !== true) {
                players = origPlayers.filter(function (p) { return !p.player.disabled; });
            }
            var queue = [];
            if (configs.scheduleEvenly !== false) {
                for (var i = 0; i < players.length; i++) {
                    queue.push(_this._GenerateRankRangeRandom(configs, rng, players, i));
                }
            }
            else {
                queue.push(_this._GenerateRankRangeRandom(configs, rng, players, Math.floor(Math.random() * players.length)));
            }
            return queue;
        };
    };
    Scheduler._GenerateRankRangeRandom = function (configs, rng, players, i) {
        var agentCount = configs.agentsPerMatch[Math.floor(rng() * configs.agentsPerMatch.length)];
        var left = i - configs.range;
        var right = i + configs.range + 1;
        if (left < 0) {
            // pad right
            right += 0 - left;
            left = 0;
        }
        else if (right > players.length) {
            // pad left
            left -= Math.max(0, right - players.length);
            left = Math.max(left, 0);
        }
        var chosen = utils_1.chooseKRandomElements(__spreadArrays(players.slice(left, i), players.slice(i + 1, right)), agentCount - 1).map(function (p) { return p.player.tournamentID.id; });
        chosen.push(players[i].player.tournamentID.id);
        return chosen;
    };
    /**
     * Generates matchCount matches using variance of player rankings as weighting to decide which players get matches
     *
     * Uses RankRanged random to generate matches
     *
     */
    Scheduler.TrueskillVarianceWeighted = function (configs) {
        var _this = this;
        if (configs === void 0) { configs = {
            agentsPerMatch: [2],
            matchCount: 10,
            seed: 0,
            range: 5,
        }; }
        var rng = seedrandom_1.default(configs.seed);
        return function (origPlayers) {
            var players = origPlayers;
            if (players.length === 0) {
                return [];
            }
            if (configs.allowDisabled !== true) {
                players = origPlayers.filter(function (p) { return !p.player.disabled; });
            }
            var weightedIntervals = [];
            var queue = [];
            var sum = 0;
            players.forEach(function (player, i) {
                var rs = player.rankState;
                if (i == 0) {
                    weightedIntervals.push(rs.rating.sigma);
                }
                else {
                    weightedIntervals.push(weightedIntervals[weightedIntervals.length - 1] + rs.rating.sigma);
                }
                sum += rs.rating.sigma;
            });
            // binary search for upper bound indices to find players to find matches for
            var matchMakePlayerIndices = [];
            for (var i = 0; i < configs.matchCount; i++) {
                var query = rng() * sum;
                var low = 0;
                var high = weightedIntervals.length - 1;
                while (low < high) {
                    var mid = Math.floor((low + high) / 2);
                    if (weightedIntervals[mid] < query) {
                        low = mid + 1;
                    }
                    else if (weightedIntervals[mid] >= query) {
                        high = mid;
                    }
                }
                matchMakePlayerIndices.push(high);
            }
            matchMakePlayerIndices.forEach(function (index) {
                queue.push(_this._GenerateRankRangeRandom(configs, rng, players, index));
            });
            return queue;
        };
    };
    return Scheduler;
}());
exports.Scheduler = Scheduler;
//# sourceMappingURL=index.js.map