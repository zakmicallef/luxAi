/// <reference types="node" />
import { EventEmitter } from 'events';
import { Match } from '../Match';
import { Design } from '../Design';
import { DeepPartial } from '../utils/DeepPartial';
import { Logger } from '../Logger';
import { RankSystem as _RankSystem } from './RankSystem';
import { Dimension, NanoID } from '../Dimension';
import { nanoid } from '..';
import { Database } from '../Plugin/Database';
import { TournamentStatus as _TournamentStatus } from './TournamentStatus';
import { TournamentType as _TOURNAMENT_TYPE } from './TournamentTypes';
/** @ignore */
/** @ignore */
/** @ignore */
/**
 * Player class that persists data for the same ephemereal agent across multiple matches. Used for {@link Tournament | Tournaments}
 */
export declare class Player {
    tournamentID: Tournament.ID;
    file: string;
    /**
     * Whether this player is anonymous and not tied to a user on the back end
     *
     * If this is ever false, then that means 1. we have a backend setup 2. there is an actual user entry
     */
    anonymous: boolean;
    /** Associated username if there is one */
    username: string;
    /**
     * Path to player's directory, not the file to be executed/used. Value is necessary if storage system is not used or
     * there is no bot key because the player is anonymous (locally stored). Used so tournament can clean up old bot
     * directory when a new bot is uploaded
     */
    botDirPath: string;
    /**
     * Key that references the player's bot file object if it exists
     */
    botkey: string;
    /**
     * Whether or not this player is disabled and won't be used in in the default match scheduling for
     * {@link Tournament.Ladder | Ladder Tournaments}. Is set to true if this player's bot throws an error during
     * the initialization stage of a {@link Match}.
     */
    disabled: boolean;
    /**
     * Path to the zip file for the bot. Used when no storage service is used. Used to allow api to send zipped bot file
     */
    zipFile: string;
    /**
     * The version of the bot associated with this player. Incremented whenever addPlayer is called
     */
    version: number;
    constructor(tournamentID: Tournament.ID, file: string, zipFile: string, botkey?: string);
    /**
     * Generates a 12 character player id string
     */
    static generatePlayerID(): string;
}
/**
 * The tournament class and module extended by all concrete Tournament Classes. Tournament Types available now are
 * {@link Ladder}, and {@link Elimination}. A tournament is composed of players, which can either be
 * all locally stored, or a split between locally stored anonymous players and database stored user owned players.
 * Ladder is the only tournament where it can be made distributed, other tournament types may only be run as a single
 * instance
 *
 * Notes: `this.competitors` map is used when no DB is used. When a DB is used, locally stored players are only in
 * `this.anonymousCompetitors` and other players are pulled from DB. Hence, a lot of code requires checking if database
 * exists and if so, pull from there and the anonymous competitors map, other wise use this.state or this.competitors
 */
export declare abstract class Tournament extends EventEmitter {
    protected design: Design;
    /** Tournament configs */
    abstract configs: Tournament.TournamentConfigsBase;
    /** Mapping match ids to active ongoing matches */
    matches: Map<NanoID, Match>;
    /** A queue whose elements are each arrays of players that are to compete against each other */
    matchQueue: Array<Tournament.QueuedMatch>;
    /** The current status of the tournament */
    status: Tournament.Status;
    /** Ongoing tournament state. Type dependent on Tournament Type chosen */
    abstract state: Tournament.TournamentTypeState;
    /** Logger */
    log: Logger;
    /** Registered competitors in this tournament */
    competitors: Map<NanoID, Player>;
    /**
     * All competitors that are anonymous, local (no user), competitors and not registered in database. Used only when
     * there is a DB
     */
    anonymousCompetitors: Map<NanoID, Player>;
    /** A reference to the dimension this tournament was spawned from */
    dimension: Dimension;
    /** This tournament's ID */
    id: NanoID;
    /**
     * This Tournament's name
     */
    name: string;
    /** Tournament Type */
    abstract type: Tournament.Type;
    /**
     * Promise array of which all resolves once every player added through constructor is finished adding
     */
    initialAddPlayerPromises: Array<Promise<any>>;
    /**
     * Map from player ids to a promise that resolves once it is unlocked from the function that initiated a promise
     */
    private lockedPlayers;
    /**
     * Map from player ids to the last version used in a match in this tournament instance
     *
     * TODO: This is not a good solution, it is effectively an in-memory cache used to invalidate past bot files. It has
     * low space overhead but it won't scale nicely.
     */
    private lastVersionUsed;
    constructor(design: Design, id: NanoID, tournamentConfigs: Tournament.TournamentConfigsBase, dimension: Dimension);
    /**
     * Add or update a player to the tournament
     *
     * If no existing ID is specified, this is treated as adding a completely new player.
     *
     * If existing ID is specified and that ID exists already, this will update the file for that player instead and
     * effectively update the player. First time a player is added, if there is existing stats in a DB they won't be
     * reset. Subsequent adds will change the stats.
     *
     * If the player is to exist beyond the tournament, an existingID must always be provided and generated somewhere else
     *
     * Resolves with the new player or updated player
     *
     * @param file - The file to the bot or an object with the file and a name for the player specified
     * @param existingID - The optional id of the player. Can also be provided in the first arg in a object
     * @param calledFromInitialization - Whether or not the player was called from initialization. If true, player
     * version does not increment
     *
     */
    addplayer(file: string | {
        file: string;
        name: string;
        zipFile?: string;
        botdir?: string;
        botkey?: string;
        existingID?: NanoID;
    }, existingID?: NanoID, calledFromInitialization?: boolean): Promise<Player>;
    /**
     * Function to be implemented by a tournament type that performs further tasks to integrate a new player
     * @param player
     */
    abstract internalAddPlayer(player: Player): Promise<void>;
    /**
     * Returns a new id for identifying a player in a tournament
     * Only used when adding a plyaer to a tournament is done without specifying an id to use.
     */
    generateNextTournamentIDString(): string;
    /**
     * Start the tournament
     * @param configs - the configs to use for the tournament
     * @param master - whether or not the instance calling stop was the first one, the "master" instance. Used only in
     * distributed scenarios
     */
    abstract run(configs?: DeepPartial<Tournament.TournamentConfigsBase>, master?: boolean): Promise<any>;
    /**
     * Stops the tournament while running
     * @param master - whether or not the instance calling stop was the first one, the "master" instance. Used only in
     * distributed scenarios
     */
    abstract stop(master?: boolean): Promise<any>;
    /**
     * Resumes the tournament
     * @param master - whether or not the instance calling stop was the first one, the "master" instance. Used only in
     * distributed scenarios
     */
    abstract resume(master?: boolean): Promise<any>;
    /**
     * Retrieve some form of rankings from the tournament's current state. The params offset and limit only apply to
     * {@link Tournament.Ladder | Ladder Tournaments}, used for scaling purposes.
     *
     * @param offset - the starting ranking to retrieve from
     * @param limit - the number of rankings to retrieve
     */
    abstract getRankings(offset?: number, limit?: number): any;
    /**
     * Update function that is called whenever an existing player is updated
     * @param player - the {@link Player} that was updated
     * @param oldname - the previous name for the player
     * @param oldfile - the previous file for the player
     */
    abstract updatePlayer(player: Player, oldname: string, oldfile: string): Promise<void>;
    /**
     * Disables the player with id playerID
     * @param playerID - the player's id to disable
     */
    disablePlayer(playerID: nanoid): Promise<void>;
    /**
     * Removes the competitor/player with id `playerID` (a {@link nanoid}). Resolves if succesful, otherwise rejects if
     * player doesn't exist or couldn't be removed
     *
     * @param playerID - ID of the player to remove
     */
    removePlayer(playerID: nanoid): Promise<void>;
    protected internalRemovePlayer(playerID: nanoid): Promise<void>;
    /**
     * Set configs for this tournament
     * @param configs the configs to deep merge with the current configs
     */
    abstract setConfigs(configs: DeepPartial<Tournament.TournamentConfigsBase>): void;
    /**
     * Set configs for this tournament
     * @param configs the configs to deep merge with the current configs
     */
    abstract getConfigs(): Tournament.TournamentConfigsBase;
    /**
     * Runs a match
     * @param players - the players to compete together
     * @returns a promise that resolves with the results and the associated match
     */
    protected runMatch(players: Array<Player>): Promise<{
        results: any;
        match: Match;
        err?: any;
    }>;
    /**
     * Return an Array of Players corresponding to the player ids stored in `queuedMatchInfo`
     * @param queuedMatchInfo
     */
    getMatchInfoFromQueuedMatch(queuedMatchInfo: Tournament.QueuedMatch): Promise<Array<Player>>;
    getLastVersionUsedOfPlayer(playerID: nanoid): Promise<number>;
    updateLastVersionUsedOfPlayer(playerID: nanoid, version: number): Promise<void>;
    /**
     * Removes a match by id. Returns true if deleted, false if nothing was deleted
     */
    removeMatch(matchID: NanoID): Promise<boolean>;
    /**
     * Destroy this tournament. Rejects if an error occured in trying to destroy it.
     */
    destroy(): Promise<void>;
    /**
     * Pre run function before generic destroy takes place
     */
    protected preInternalDestroy(): Promise<void>;
    /**
     * Post run function before generic destroy takes place
     */
    protected postInternalDestroy(): Promise<void>;
    /**
     * Generates a 6 character tournament ID identifying this tournament class instance. Not to be confused with
     * {@link Tournament.ID} which is the ID for competitors in the tournament
     */
    static genTournamentClassID(): string;
    /**
     * Returns the name of the tournament but formatted (no spaces)
     */
    getSafeName(): string;
    /**
     * Returns a key name to be used when storing a tournament by a combination of its name and id
     */
    getKeyName(): string;
    /**
     * Resolves with player stats if player with the id exists. Includes database user if db contains the player
     * Fields are null if they don't exist. If playerStat field is null, then this player does not exist
     *
     * @param id - id of player to get
     */
    getPlayerStat(id: nanoid): Promise<{
        user: Database.User;
        playerStat: Tournament.PlayerStatBase;
    }>;
}
import { Ladder as LadderTournament } from './Ladder';
/** @ignore */
import { Elimination as EliminationTournament } from './Elimination';
/** @ignore */
import { Scheduler as SchedulerClass } from './Scheduler';
/** @ignore */
export declare namespace Tournament {
    export import Ladder = LadderTournament;
    export import Elimination = EliminationTournament;
    export import Scheduler = SchedulerClass;
    export import Type = _TOURNAMENT_TYPE;
    export import Status = _TournamentStatus;
    export import RankSystem = _RankSystem;
    /**
     * Required and Optional Tournament configurations
     */
    interface TournamentConfigsBase {
        /**
         * The default match configurations to be applied throughout all tournament matches
         */
        defaultMatchConfigs?: DeepPartial<Match.Configs>;
        /**
         * The tournament type to run. See {@link Tournament.Type}
         */
        type: Type;
        /**
         * The ranking system to use for this tournament. Either a string or a class that extends RankSystem
         */
        rankSystem: RankSystem<any, any> | Tournament.RankSystemTypes;
        /**
         * The result handler for returning the appropriate results to the tournament for processing.
         *
         * To find what kind of result should be returned, find the Results interface for the rank system you are using.
         *
         * Example: For {@link Tournament.RankSystem.TRUESKILL}, go to {@link Tournament.RankSystem.TRUESKILL.Results}
         */
        resultHandler: (results: any) => any;
        /**
         * The configurations for a specified rank system. For example, see {@link RankSystem.WINS.Configs},
         * {@link RankSystem.TRUESKILL.Configs}
         */
        rankSystemConfigs?: any;
        /**
         * The tournament wide logging level to enforce
         */
        loggingLevel?: Logger.LEVEL;
        /**
         * The name of the tournament
         */
        name?: string;
        /**
         * Tournament configurations. Dependent on the type of tournament chosen
         * Example: For {@link Ladder}, go to {@link Ladder.Configs}
         */
        tournamentConfigs?: any;
        /**
         * An array of valid number of players that can compete in a match. For Rock Paper Scissors for example this would
         * be [2]
         * @default `[2]`
         */
        agentsPerMatch: Array<number>;
        /**
         * Whether or not to display a continuous console log of the current tournament as it runs
         * @default `true`
         */
        consoleDisplay?: boolean;
        /**
         * Set this ID to override the generated ID
         */
        id?: string;
    }
    /**
     * Queued match information, consisting of player IDs of players to compete
     */
    type QueuedMatch = Array<nanoid>;
    /**
     * Internally used type.
     */
    interface TournamentConfigs<ConfigType> extends TournamentConfigsBase {
        tournamentConfigs: ConfigType;
        rankSystemConfigs: any;
    }
    interface TournamentTypeConfig {
        /**
         * Whether or not to store past results using the specified option of the dimension (database or in memory)
         * @default `true`
         */
        storePastResults: boolean;
    }
    interface TournamentTypeState {
        /**
         * Past results stored. Each element is what is returned by {@link Design.getResults}
         */
        results: Array<any>;
        /**
         * Map from player ID to player stats
         */
        playerStats: Map<NanoID, PlayerStatBase>;
    }
    /**
     * Tournament.ID. Represents an identifier for players competing in a {@link Tournament}
     */
    interface ID {
        /** A string id. This should never change */
        readonly id: NanoID;
        /** A display name */
        name: string;
        /** Associated username if there is one. */
        username: string;
    }
    interface PlayerStatBase {
        player: Player;
        matchesPlayed: number;
    }
    enum Events {
        /**
         * Event is emitted when initialAddPlayerPromises resolves. This involves all players initialized to tournament
         * upon initialization of tournament instance
         */
        INITIAL_PLAYERS_INITIALIZED = "initial_players_initialized",
        /**
         * Event is emitted whenever a match runs
         */
        MATCH_RAN = "match_ran",
        /**
         * Event is emitted whenever a match runs AND the tournament is completely done handling it.
         */
        MATCH_HANDLED = "match_handled"
    }
    enum RankSystemTypes {
        /** Ranking by wins, ties and losses */
        WINS = "wins",
        /** Ranking by the ELO ranking system */
        ELO = "elo",
        /** Ranking by Microsoft's Trueskill */
        TRUESKILL = "trueskill"
    }
}
