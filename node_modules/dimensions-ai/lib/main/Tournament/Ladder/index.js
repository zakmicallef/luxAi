"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
var __1 = require("..");
var DeepMerge_1 = require("../../utils/DeepMerge");
var DimensionError_1 = require("../../DimensionError");
var Logger_1 = require("../../Logger");
var TournamentStatus_1 = require("../TournamentStatus");
var TournamentTypes_1 = require("../TournamentTypes");
var TrueSkillSystem_1 = require("../RankSystem/TrueSkillSystem");
var ELOSystem_1 = require("../RankSystem/ELOSystem");
var DeepCopy_1 = require("../../utils/DeepCopy");
var Scheduler_1 = require("../Scheduler");
var WinsSystem_1 = require("../RankSystem/WinsSystem");
var REFRESH_RATE = 10000;
/**
 * The Ladder Tournament class and namespace.
 */
var Ladder = /** @class */ (function (_super) {
    __extends(Ladder, _super);
    function Ladder(design, files, tournamentConfigs, id, dimension) {
        var _this = _super.call(this, design, id, tournamentConfigs, dimension) || this;
        _this.configs = {
            defaultMatchConfigs: {},
            type: TournamentTypes_1.TournamentType.LADDER,
            rankSystem: null,
            rankSystemConfigs: null,
            tournamentConfigs: {
                maxConcurrentMatches: 1,
                endDate: null,
                storePastResults: true,
                maxTotalMatches: null,
                matchMake: null,
                configSyncRefreshRate: 6000,
                syncConfigs: true,
                selfMatchMake: true,
            },
            resultHandler: null,
            agentsPerMatch: [2],
            consoleDisplay: true,
            id: 'z3plg',
        };
        _this.state = {
            playerStats: new Map(),
            currentRanks: [],
            results: [],
            statistics: {
                totalMatches: 0,
            },
        };
        _this.type = __1.Tournament.Type.LADDER;
        // lock matchqueue for concurrency
        _this.matchQueueLocked = false;
        /**
         * tournament runner interval, periodically calls tourneyRunner to start up new matches
         */
        _this.runInterval = null;
        /**
         * Configuration synchronization interval. Periodically makes a request to the DB if there is one and syncs configs
         */
        _this.configSyncInterval = null;
        /**
         * Last modification date of configs
         */
        _this.configLastModificationDate = new Date(0);
        // queue of the results to process
        _this.resultProcessingQueue = [];
        _this.configs = DeepMerge_1.deepMerge(_this.configs, tournamentConfigs, true);
        if (typeof _this.configs.rankSystem === 'string') {
            if (_this.configs.rankSystemConfigs === null) {
                _this.configs.rankSystemConfigs = {};
            }
            switch (_this.configs.rankSystem) {
                case __1.Tournament.RankSystemTypes.TRUESKILL:
                    _this.ranksystem = new TrueSkillSystem_1.TrueSkillSystem(_this.configs.rankSystemConfigs);
                    break;
                case __1.Tournament.RankSystemTypes.ELO:
                    _this.ranksystem = new ELOSystem_1.ELOSystem(_this.configs.rankSystemConfigs);
                    break;
                case __1.Tournament.RankSystemTypes.WINS:
                    _this.ranksystem = new WinsSystem_1.WinsSystem(_this.configs.rankSystemConfigs);
                    break;
                default:
                    throw new DimensionError_1.NotSupportedError('We currently do not support this rank system for ladder tournaments');
            }
        }
        else {
            _this.ranksystem = _this.configs.rankSystem;
        }
        if (_this.ranksystem === null) {
            throw new DimensionError_1.FatalError('Did not supply a rank system');
        }
        files.forEach(function (file) {
            if (typeof file === 'string') {
                _this.initialAddPlayerPromises.push(_this.addplayer(file, undefined, true));
            }
            else {
                _this.initialAddPlayerPromises.push(_this.addplayer(file, file.existingID, true));
            }
        });
        Promise.all(_this.initialAddPlayerPromises).then(function () {
            _this.emit(__1.Tournament.Events.INITIAL_PLAYERS_INITIALIZED);
        });
        _this.status = TournamentStatus_1.TournamentStatus.INITIALIZED;
        // setup config syncing if DB is enabled and store configs if not stored already
        if (_this.dimension.hasDatabase()) {
            if (_this.configs.tournamentConfigs.syncConfigs) {
                _this.syncConfigs();
                _this.setupConfigSyncInterval();
                _this.dimension.databasePlugin
                    .getTournamentConfigs(_this.id)
                    .then(function (data) {
                    if (!data) {
                        _this.configLastModificationDate = new Date();
                        // store tournament configs if no configs found
                        _this.dimension.databasePlugin
                            .storeTournamentConfigs(_this.id, _this.getConfigsStrippedOfFunctionFields(_this.configs), _this.status)
                            .then(function () {
                            _this.log.info('Storing initial tournament configuration data');
                        });
                    }
                });
            }
        }
        // setup matchmaking algorithm to default if not provided
        if (!_this.configs.tournamentConfigs.matchMake) {
            var max_1 = _this.configs.agentsPerMatch[0];
            _this.configs.agentsPerMatch.forEach(function (v) {
                max_1 = Math.max(max_1, v);
            });
            _this.configs.tournamentConfigs.matchMake = Scheduler_1.Scheduler.RankRangeRandom({
                agentsPerMatch: _this.configs.agentsPerMatch,
                range: Math.ceil(max_1 * 2.5),
            });
        }
        _this.log.info('Initialized Ladder Tournament');
        return _this;
    }
    Ladder.prototype.getConfigsStrippedOfFunctionFields = function (object) {
        var obj = DeepCopy_1.deepCopy(object);
        delete obj.resultHandler;
        delete obj.rankSystem;
        delete obj.tournamentConfigs.matchMake;
        return obj;
    };
    /**
     * Sync configs from DB
     */
    Ladder.prototype.syncConfigs = function () {
        return __awaiter(this, void 0, void 0, function () {
            var modDate, _a, configs, status_1;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0: return [4 /*yield*/, this.dimension.databasePlugin.getTournamentConfigsModificationDate(this.id)];
                    case 1:
                        modDate = _b.sent();
                        if (!(modDate &&
                            modDate.getTime() > this.configLastModificationDate.getTime())) return [3 /*break*/, 3];
                        return [4 /*yield*/, this.dimension.databasePlugin.getTournamentConfigs(this.id)];
                    case 2:
                        _a = _b.sent(), configs = _a.configs, status_1 = _a.status;
                        this.log.info("Received new configurations, mod date - " + modDate);
                        this.log.detail(configs);
                        this.configLastModificationDate = modDate;
                        this.configs = DeepMerge_1.deepMerge(this.configs, configs, true);
                        // update status and run/stop/resume tourney as needed
                        if (status_1 !== this.status) {
                            if (status_1 === __1.Tournament.Status.STOPPED) {
                                if (this.status === __1.Tournament.Status.RUNNING) {
                                    this.stop();
                                }
                            }
                            else if (status_1 === __1.Tournament.Status.RUNNING) {
                                if (this.status === __1.Tournament.Status.INITIALIZED) {
                                    this.run();
                                }
                                else if (this.status === __1.Tournament.Status.STOPPED) {
                                    this.resume();
                                }
                            }
                        }
                        _b.label = 3;
                    case 3: return [2 /*return*/];
                }
            });
        });
    };
    Ladder.prototype.setupConfigSyncInterval = function () {
        var _this = this;
        this.configSyncInterval = setInterval(function () {
            _this.syncConfigs();
        }, this.configs.tournamentConfigs.configSyncRefreshRate);
    };
    /**
     * Retrieves the local configurations
     */
    Ladder.prototype.getConfigs = function () {
        return this.configs;
    };
    /**
     * Set tournament status and updates DB / propagates the message to every other tournament instance
     */
    Ladder.prototype.setStatus = function (status) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!(this.dimension.hasDatabase() &&
                            this.configs.tournamentConfigs.syncConfigs)) return [3 /*break*/, 3];
                        return [4 /*yield*/, this.syncConfigs()];
                    case 1:
                        _a.sent();
                        return [4 /*yield*/, this.dimension.databasePlugin.storeTournamentConfigs(this.id, this.getConfigsStrippedOfFunctionFields(this.configs), status)];
                    case 2:
                        _a.sent();
                        this.status = status;
                        return [3 /*break*/, 4];
                    case 3:
                        this.status = status;
                        _a.label = 4;
                    case 4: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Sets configs and updates DB / propagates the message to every other tournament instance
     */
    Ladder.prototype.setConfigs = function (configs) {
        if (configs === void 0) { configs = {}; }
        return __awaiter(this, void 0, void 0, function () {
            var plugin_1;
            var _this = this;
            return __generator(this, function (_a) {
                if (configs.id) {
                    throw new DimensionError_1.TournamentError('You cannot change the tournament ID after constructing the tournament');
                }
                if (configs.rankSystem) {
                    throw new DimensionError_1.TournamentError('You cannot change the rank system after constructing the tournament');
                }
                if (this.dimension.hasDatabase() &&
                    this.configs.tournamentConfigs.syncConfigs) {
                    plugin_1 = this.dimension.databasePlugin;
                    // ensure configs are up to date first, then set configs
                    this.syncConfigs().then(function () {
                        var newconfigs = DeepMerge_1.deepMerge(DeepCopy_1.deepCopy(_this.configs), configs, true);
                        plugin_1
                            .storeTournamentConfigs(_this.id, _this.getConfigsStrippedOfFunctionFields(newconfigs), _this.status)
                            .then(function () {
                            // set configs locally as well if we succesfully store into DB
                            _this.configs = newconfigs;
                        });
                    });
                }
                else {
                    // if sync off or no database, edit configs in memory
                    this.configs = DeepMerge_1.deepMerge(this.configs, configs, true);
                }
                return [2 /*return*/];
            });
        });
    };
    /**
     * Gets all rankings with the given offset from rank 1 and limit. Note this it's not recommended to use this
     * function if there are many users. It is suggested to create your own (aggregation) query to get rankings directly
     * from the DB.
     * @param offset
     * @param limit
     */
    Ladder.prototype.getRankings = function (offset, limit) {
        if (offset === void 0) { offset = 0; }
        if (limit === void 0) { limit = -1; }
        return __awaiter(this, void 0, void 0, function () {
            var rankings, users, end;
            var _this = this;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        rankings = [];
                        if (!this.dimension.hasDatabase()) return [3 /*break*/, 2];
                        return [4 /*yield*/, this.dimension.databasePlugin.getUsersInTournament(this.getKeyName(), 0, -1)];
                    case 1:
                        users = _a.sent();
                        rankings = users.map(function (user) {
                            var stat = user.statistics[_this.getKeyName()];
                            var rankState = stat.rankState;
                            return {
                                player: stat.player,
                                matchesPlayed: stat.matchesPlayed,
                                rankState: rankState,
                            };
                        });
                        if (this.anonymousCompetitors.size > 0) {
                            this.anonymousCompetitors.forEach(function (player) {
                                var stat = _this.state.playerStats.get(player.tournamentID.id);
                                var rankState = stat.rankState;
                                rankings.push({
                                    player: stat.player,
                                    matchesPlayed: stat.matchesPlayed,
                                    rankState: rankState,
                                });
                            });
                        }
                        return [3 /*break*/, 3];
                    case 2:
                        this.state.playerStats.forEach(function (stat) {
                            rankings.push({
                                player: stat.player,
                                matchesPlayed: stat.matchesPlayed,
                                rankState: stat.rankState,
                            });
                        });
                        _a.label = 3;
                    case 3:
                        rankings.sort(function (a, b) {
                            return _this.ranksystem.rankComparator(a.rankState, b.rankState);
                        });
                        end = limit === -1 ? rankings.length : offset + limit;
                        return [2 /*return*/, rankings.slice(offset, end)];
                }
            });
        });
    };
    /**
     * Resets rankings of all competitors loaded to initial scores
     */
    Ladder.prototype.resetRankings = function () {
        return __awaiter(this, void 0, void 0, function () {
            var updatePromises, playerStatsList, userList;
            var _this = this;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        // TODO: Some instances of tournament might still be running once this one is stopped, and reset won't work
                        // correctly
                        if (this.status == TournamentStatus_1.TournamentStatus.RUNNING) {
                            throw new DimensionError_1.TournamentError('Cannot reset while tournament is running!');
                        }
                        updatePromises = [];
                        playerStatsList = [];
                        userList = [];
                        if (!this.dimension.hasDatabase()) return [3 /*break*/, 2];
                        return [4 /*yield*/, this.dimension.databasePlugin.getUsersInTournament(this.getKeyName(), 0, -1)];
                    case 1:
                        // get every user
                        userList = _a.sent();
                        playerStatsList = userList.map(function (user) { return user.statistics[_this.getKeyName()]; });
                        // add anonymous users
                        playerStatsList.push.apply(playerStatsList, Array.from(this.state.playerStats.values()));
                        return [3 /*break*/, 3];
                    case 2:
                        playerStatsList = Array.from(this.state.playerStats.values());
                        _a.label = 3;
                    case 3:
                        playerStatsList.forEach(function (stats, i) {
                            var resetPlayer = function () { return __awaiter(_this, void 0, void 0, function () {
                                return __generator(this, function (_a) {
                                    switch (_a.label) {
                                        case 0:
                                            stats.matchesPlayed = 0;
                                            stats.rankState = this.ranksystem.resetRank(stats.rankState);
                                            if (!this.dimension.hasDatabase()) return [3 /*break*/, 2];
                                            return [4 /*yield*/, this.updateDatabasePlayerStats(stats, userList[i])];
                                        case 1:
                                            _a.sent();
                                            _a.label = 2;
                                        case 2: return [2 /*return*/];
                                    }
                                });
                            }); };
                            updatePromises.push(resetPlayer());
                        });
                        return [4 /*yield*/, Promise.all(updatePromises)];
                    case 4:
                        _a.sent();
                        return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Stops the tournament if it was running.
     * @param primary - whether or not the instance calling stop was the first one, the "primary" instance
     */
    Ladder.prototype.stop = function (primary) {
        if (primary === void 0) { primary = false; }
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (this.status !== TournamentStatus_1.TournamentStatus.RUNNING) {
                            throw new DimensionError_1.TournamentError("Can't stop a tournament that isn't running");
                        }
                        this.log.info('Stopping Tournament...');
                        clearInterval(this.runInterval);
                        if (!primary) return [3 /*break*/, 2];
                        return [4 /*yield*/, this.setStatus(TournamentStatus_1.TournamentStatus.STOPPED)];
                    case 1:
                        _a.sent();
                        return [3 /*break*/, 3];
                    case 2:
                        this.status = TournamentStatus_1.TournamentStatus.STOPPED;
                        _a.label = 3;
                    case 3: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Resumes the tournament if it was stopped.
     * @param primary - whether or not the instance calling stop was the first one, the "primary" instance
     */
    Ladder.prototype.resume = function (primary) {
        if (primary === void 0) { primary = false; }
        return __awaiter(this, void 0, void 0, function () {
            var _this = this;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (this.status !== TournamentStatus_1.TournamentStatus.STOPPED) {
                            throw new DimensionError_1.TournamentError("Can't resume a tournament that isn't stopped");
                        }
                        this.log.info('Resuming Tournament...');
                        if (!primary) return [3 /*break*/, 2];
                        return [4 /*yield*/, this.setStatus(TournamentStatus_1.TournamentStatus.RUNNING)];
                    case 1:
                        _a.sent();
                        return [3 /*break*/, 3];
                    case 2:
                        this.status = TournamentStatus_1.TournamentStatus.RUNNING;
                        _a.label = 3;
                    case 3:
                        this.tourneyRunner();
                        this.runInterval = setInterval(function () {
                            _this.tourneyRunner();
                        }, REFRESH_RATE);
                        return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Begin the tournament. Resolves once the tournament is started
     * @param configs - tournament configurations to use
     * @param master - whether or not the instance calling stop was the first one, the "master" instance
     */
    Ladder.prototype.run = function (configs, master) {
        if (master === void 0) { master = false; }
        return __awaiter(this, void 0, void 0, function () {
            var _a;
            var _this = this;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        this.log.info('Running Tournament');
                        this.configs = DeepMerge_1.deepMerge(this.configs, configs, true);
                        return [4 /*yield*/, this.initialize()];
                    case 1:
                        _b.sent();
                        if (!this.configs.tournamentConfigs.selfMatchMake) return [3 /*break*/, 3];
                        return [4 /*yield*/, this.schedule()];
                    case 2:
                        _a = _b.sent();
                        return [3 /*break*/, 4];
                    case 3:
                        _a = this.log.info('Self match make turned off, tournament will only run matches stored in match queue');
                        _b.label = 4;
                    case 4:
                        _a;
                        if (master) {
                            this.setStatus(TournamentStatus_1.TournamentStatus.RUNNING);
                        }
                        else {
                            this.status = TournamentStatus_1.TournamentStatus.RUNNING;
                        }
                        this.tourneyRunner();
                        this.runInterval = setInterval(function () {
                            _this.tourneyRunner();
                        }, REFRESH_RATE);
                        return [2 /*return*/];
                }
            });
        });
    };
    Ladder.prototype.tourneyRunner = function () {
        return __awaiter(this, void 0, void 0, function () {
            var maxTotalMatches, currDate, matchPromises, i, matchInfo;
            var _this = this;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (this.matchQueueLocked) {
                            return [2 /*return*/];
                        }
                        this.matchQueueLocked = true;
                        if (this.matches.size >= this.configs.tournamentConfigs.maxConcurrentMatches) {
                            this.matchQueueLocked = false;
                            return [2 /*return*/];
                        }
                        maxTotalMatches = this.configs.tournamentConfigs.maxTotalMatches;
                        if (this.configs.tournamentConfigs.endDate) {
                            currDate = new Date();
                            if (currDate.getTime() > this.configs.tournamentConfigs.endDate.getTime()) {
                                this.log.info('Reached past Tournament marked End Date, shutting down tournament...');
                                // stop the tournament
                                this.stop();
                                return [2 /*return*/];
                            }
                        }
                        if (maxTotalMatches) {
                            if (this.state.statistics.totalMatches >= maxTotalMatches) {
                                this.log.info('Reached max matches, shutting down tournament...');
                                this.stop();
                                this.matchQueueLocked = false;
                                return [2 /*return*/];
                            }
                        }
                        matchPromises = [];
                        if (!(this.configs.tournamentConfigs.selfMatchMake &&
                            this.matchQueue.length <
                                this.configs.tournamentConfigs.maxConcurrentMatches * 2)) return [3 /*break*/, 2];
                        return [4 /*yield*/, this.schedule()];
                    case 1:
                        _a.sent();
                        _a.label = 2;
                    case 2:
                        // run as many matches as allowed by maxConcurrentMatches, maxTotalMatches, and how many matches left in queue allow
                        for (i = 0; i <
                            Math.min(this.matchQueue.length, this.configs.tournamentConfigs.maxConcurrentMatches - this.matches.size); i++) {
                            if (maxTotalMatches &&
                                maxTotalMatches -
                                    this.state.statistics.totalMatches -
                                    this.matches.size <=
                                    0) {
                                break;
                            }
                            matchInfo = this.matchQueue.shift();
                            matchPromises.push(this.handleMatch(matchInfo));
                        }
                        // as soon as one match finished, call it again
                        Promise.race(matchPromises)
                            .then(function () {
                            if (_this.status == TournamentStatus_1.TournamentStatus.RUNNING) {
                                _this.tourneyRunner();
                            }
                        })
                            .catch(function (error) {
                            _this.log.error(error);
                            if (error instanceof DimensionError_1.MatchDestroyedError) {
                                // keep running even if a match is destroyed and the tournament is marked as to keep running
                                if (_this.status == TournamentStatus_1.TournamentStatus.RUNNING) {
                                    _this.tourneyRunner();
                                }
                            }
                            else {
                                if (_this.status == TournamentStatus_1.TournamentStatus.RUNNING) {
                                    _this.tourneyRunner();
                                }
                            }
                        });
                        this.matchQueueLocked = false;
                        return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Updates database with new player stats
     *
     * If failure occurs, we ignore it and just log it as we will likely in the future perform an update operation
     * on the database again anyway
     */
    Ladder.prototype.updateDatabasePlayerStats = function (playerStat, user) {
        return __awaiter(this, void 0, void 0, function () {
            var player, keyName, update, plainPlayer_1, err_1;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        player = playerStat.player;
                        if (!!player.anonymous) return [3 /*break*/, 4];
                        keyName = this.getKeyName();
                        update = {
                            statistics: {},
                        };
                        // if there exists stats already, keep them
                        if (user && user.statistics) {
                            update.statistics = user.statistics;
                        }
                        plainPlayer_1 = {};
                        Object.entries(player).forEach(function (_a) {
                            var key = _a[0], value = _a[1];
                            plainPlayer_1[key] = value;
                        });
                        update.statistics[keyName] = __assign(__assign({}, playerStat), { player: plainPlayer_1 });
                        _a.label = 1;
                    case 1:
                        _a.trys.push([1, 3, , 4]);
                        return [4 /*yield*/, this.dimension.databasePlugin.updateUser(player.tournamentID.id, update)];
                    case 2:
                        _a.sent();
                        return [3 /*break*/, 4];
                    case 3:
                        err_1 = _a.sent();
                        this.log.error("Failed to update user with player stats", err_1);
                        return [3 /*break*/, 4];
                    case 4: return [2 /*return*/];
                }
            });
        });
    };
    Ladder.prototype.initializePlayerStats = function (player) {
        return __awaiter(this, void 0, void 0, function () {
            var playerStat, user, keyName;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        playerStat = null;
                        keyName = this.getKeyName();
                        if (!(!player.anonymous && this.dimension.hasDatabase())) return [3 /*break*/, 2];
                        return [4 /*yield*/, this.dimension.databasePlugin.getUser(player.tournamentID.id)];
                    case 1:
                        user = _a.sent();
                        if (user) {
                            // if there are stats
                            if (user.statistics) {
                                playerStat = user.statistics[keyName];
                                if (playerStat) {
                                    // if player stats exist already, we can return as we dont need to initialize anything and store to DB
                                    // we don't store anything locally because this is a user and we have DB
                                    return [2 /*return*/];
                                }
                            }
                        }
                        _a.label = 2;
                    case 2:
                        if (!!playerStat) return [3 /*break*/, 4];
                        playerStat = {
                            player: player,
                            matchesPlayed: 0,
                            rankState: this.ranksystem.initializeRankState(),
                        };
                        return [4 /*yield*/, this.updateDatabasePlayerStats(playerStat, user)];
                    case 3:
                        _a.sent();
                        _a.label = 4;
                    case 4:
                        // only store locally if not in DB
                        if (!user) {
                            this.state.playerStats.set(player.tournamentID.id, playerStat);
                        }
                        return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Initialize competition with given players, which can be local or stored in DB
     *
     * Does not read in any DB players, only uses those that are given at construction of tourney
     */
    Ladder.prototype.initialize = function () {
        return __awaiter(this, void 0, void 0, function () {
            var promises;
            var _this = this;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: 
                    // wait for all players to add in.
                    return [4 /*yield*/, Promise.all(this.initialAddPlayerPromises)];
                    case 1:
                        // wait for all players to add in.
                        _a.sent();
                        this.state.playerStats = new Map();
                        this.state.results = [];
                        promises = [];
                        this.competitors.forEach(function (player) {
                            promises.push(_this.initializePlayerStats(player));
                        });
                        return [4 /*yield*/, Promise.all(promises)];
                    case 2:
                        _a.sent();
                        if (!this.configs.consoleDisplay) return [3 /*break*/, 4];
                        return [4 /*yield*/, this.printTournamentStatus()];
                    case 3:
                        _a.sent();
                        _a.label = 4;
                    case 4: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Schedules matches to play. By default uses {@link Scheduler.RankRangeRandom}
     *
     * If a {@link Ladder.Configs.matchMake | matchMake} function is provided, that will be used instead of the default.
     *
     * For users who want to host larger scale competitions with 1000+ competitors, its recommended to turn self match
     * make off and setup a separate match scheduling server that tournament servers can pull queued matches from
     */
    Ladder.prototype.schedule = function () {
        return __awaiter(this, void 0, void 0, function () {
            var rankings, newMatches;
            var _a;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0: return [4 /*yield*/, this.getRankings(0, -1)];
                    case 1:
                        rankings = _b.sent();
                        if (this.configs.tournamentConfigs.matchMake) {
                            newMatches = this.configs.tournamentConfigs.matchMake(rankings);
                            (_a = this.matchQueue).push.apply(_a, newMatches);
                            return [2 /*return*/];
                        }
                        return [2 /*return*/];
                }
            });
        });
    };
    /** Schedule a match using match info */
    Ladder.prototype.scheduleMatches = function () {
        var _a;
        var matchInfos = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            matchInfos[_i] = arguments[_i];
        }
        (_a = this.matchQueue).push.apply(_a, matchInfos);
        // kick off the runner to process any matches
        this.tourneyRunner();
    };
    // called adding a new player
    Ladder.prototype.internalAddPlayer = function (player) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.initializePlayerStats(player)];
                    case 1:
                        _a.sent();
                        return [2 /*return*/];
                }
            });
        });
    };
    // should be called only for DB users
    Ladder.prototype.updatePlayer = function (player) {
        return __awaiter(this, void 0, void 0, function () {
            var _a, user, playerStat, playerStats;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0: return [4 /*yield*/, this.getPlayerStat(player.tournamentID.id)];
                    case 1:
                        _a = _b.sent(), user = _a.user, playerStat = _a.playerStat;
                        playerStats = playerStat;
                        playerStats.player = player;
                        playerStats.matchesPlayed = 0;
                        playerStats.rankState = this.ranksystem.onPlayerUpdate(playerStats.rankState);
                        if (!this.dimension.hasDatabase()) return [3 /*break*/, 3];
                        if (!!player.anonymous) return [3 /*break*/, 3];
                        return [4 /*yield*/, this.updateDatabasePlayerStats(playerStats, user)];
                    case 2:
                        _b.sent();
                        _b.label = 3;
                    case 3: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Removes player from tournament. Removes from state and stats from database
     * @param playerID
     */
    Ladder.prototype.internalRemovePlayer = function (playerID) {
        return __awaiter(this, void 0, void 0, function () {
            var _a, user, playerStat, keyName, update;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0: return [4 /*yield*/, this.getPlayerStat(playerID)];
                    case 1:
                        _a = _b.sent(), user = _a.user, playerStat = _a.playerStat;
                        if (!playerStat) return [3 /*break*/, 4];
                        this.state.playerStats.delete(playerID);
                        this.log.info('Removed player ' + playerID);
                        if (!this.dimension.hasDatabase()) return [3 /*break*/, 3];
                        if (!user) return [3 /*break*/, 3];
                        keyName = this.getKeyName();
                        update = {
                            statistics: {},
                        };
                        // if there exists stats already, keep them
                        if (user && user.statistics) {
                            update.statistics = user.statistics;
                        }
                        // delete stats for this tournament to remove player
                        delete update.statistics[keyName];
                        return [4 /*yield*/, this.dimension.databasePlugin.updateUser(playerID, update)];
                    case 2:
                        _b.sent();
                        this.log.info('Removed player ' + playerID + ' from DB');
                        _b.label = 3;
                    case 3: return [3 /*break*/, 5];
                    case 4: throw new DimensionError_1.TournamentPlayerDoesNotExistError("Could not find player with ID: " + playerID);
                    case 5: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Print tournament status to display
     */
    /* istanbul ignore next */
    Ladder.prototype.printTournamentStatus = function () {
        return __awaiter(this, void 0, void 0, function () {
            var ranks;
            var _this = this;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!(this.log.level > Logger_1.Logger.LEVEL.NONE)) return [3 /*break*/, 2];
                        return [4 /*yield*/, this.getRankings(0, -1)];
                    case 1:
                        ranks = _a.sent();
                        console.clear();
                        console.log(this.log.bar());
                        console.log("Tournament - ID: " + this.id + ", Name: " + this.name + " | Dimension - ID: " + this.dimension.id + ", Name: " + this.dimension.name + "\nStatus: " + this.status + " | Competitors: " + this.competitors.size + " | Rank System: " + this.configs.rankSystem + "\n");
                        console.log('Total Matches: ' +
                            this.state.statistics.totalMatches +
                            ' | Matches Queued: ' +
                            this.matchQueue.length);
                        console.log(this.ranksystem.getRankStatesHeaderString());
                        ranks.forEach(function (info) {
                            console.log(_this.ranksystem.getRankStateString(info.player, info.rankState, info.matchesPlayed));
                        });
                        console.log();
                        console.log('Current Matches: ' + this.matches.size);
                        this.matches.forEach(function (match) {
                            var names = [];
                            match.agents.forEach(function (agent) {
                                names.push(agent.name);
                            });
                            console.log(names);
                        });
                        _a.label = 2;
                    case 2: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Checks whether match can still be run
     *
     * If there are no stats, player was removed and match can't be run. If player is disabled, then it won't run
     */
    Ladder.prototype.checkMatchIntegrity = function (matchInfo) {
        return __awaiter(this, void 0, void 0, function () {
            var checkIntegrity, promises, i, player;
            var _this = this;
            return __generator(this, function (_a) {
                checkIntegrity = function (id) { return __awaiter(_this, void 0, void 0, function () {
                    var stat;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0: return [4 /*yield*/, this.getPlayerStat(id)];
                            case 1:
                                stat = _a.sent();
                                if (!stat.playerStat) {
                                    return [2 /*return*/, false];
                                }
                                else if (stat.playerStat.player.disabled) {
                                    return [2 /*return*/, false];
                                }
                                return [2 /*return*/, true];
                        }
                    });
                }); };
                promises = [];
                for (i = 0; i < matchInfo.length; i++) {
                    player = matchInfo[i];
                    promises.push(checkIntegrity(player.tournamentID.id));
                }
                return [2 /*return*/, Promise.all(promises).then(function (integritys) {
                        for (var i = 0; i < integritys.length; i++) {
                            if (integritys[i] === false)
                                return false;
                        }
                        return true;
                    })];
            });
        });
    };
    /**
     * Handles the start and end of a match, and updates state accrding to match results and the given result handler
     * @param matchInfo
     */
    Ladder.prototype.handleMatch = function (queuedMatchInfo) {
        return __awaiter(this, void 0, void 0, function () {
            var matchInfo, matchRes, tournamentID, tournamentID, resInfo;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.getMatchInfoFromQueuedMatch(queuedMatchInfo)];
                    case 1:
                        matchInfo = _a.sent();
                        return [4 /*yield*/, this.checkMatchIntegrity(matchInfo)];
                    case 2:
                        if (!(_a.sent())) {
                            // quit
                            this.log.detail('Match queued cannot be run anymore');
                            return [2 /*return*/];
                        }
                        if (!this.configs.consoleDisplay) return [3 /*break*/, 4];
                        return [4 /*yield*/, this.printTournamentStatus()];
                    case 3:
                        _a.sent();
                        _a.label = 4;
                    case 4:
                        this.log.detail('Running match - Competitors: ', matchInfo.map(function (player) {
                            return player.tournamentID.name;
                        }));
                        return [4 /*yield*/, this.runMatch(matchInfo)];
                    case 5:
                        matchRes = _a.sent();
                        if (!matchRes.err) return [3 /*break*/, 11];
                        if (!(matchRes.err instanceof DimensionError_1.AgentCompileError)) return [3 /*break*/, 7];
                        tournamentID = matchRes.match.mapAgentIDtoTournamentID.get(matchRes.err.agentID);
                        this.log.warn("Match couldn't run. Player " + tournamentID.id + " got a compile error");
                        return [4 /*yield*/, this.disablePlayer(tournamentID.id)];
                    case 6:
                        _a.sent();
                        return [3 /*break*/, 10];
                    case 7:
                        if (!(matchRes.err instanceof DimensionError_1.AgentInstallError)) return [3 /*break*/, 9];
                        tournamentID = matchRes.match.mapAgentIDtoTournamentID.get(matchRes.err.agentID);
                        this.log.warn("Match couldn't run. Player " + tournamentID.id + " got an install error");
                        return [4 /*yield*/, this.disablePlayer(tournamentID.id)];
                    case 8:
                        _a.sent();
                        return [3 /*break*/, 10];
                    case 9:
                        this.log.error("Match couldn't run, aborting... ", matchRes.err);
                        _a.label = 10;
                    case 10:
                        // remove the match from the active matches list
                        this.matches.delete(matchRes.match.id);
                        return [2 /*return*/];
                    case 11:
                        // update total matches
                        this.state.statistics.totalMatches++;
                        resInfo = this.configs.resultHandler(matchRes.results);
                        // push to result processing queue
                        this.resultProcessingQueue.push({
                            result: resInfo,
                            mapAgentIDtoTournamentID: matchRes.match.mapAgentIDtoTournamentID,
                        });
                        // make a call to handle match with trueskill to process the next result in the processing queue
                        this.handleMatchResults();
                        // store past results
                        if (this.configs.tournamentConfigs.storePastResults) {
                            if (!(this.dimension.hasDatabase() &&
                                this.dimension.databasePlugin.configs.saveTournamentMatches)) {
                                // if we have don't have a database that is set to actively store tournament matches we store locally
                                this.state.results.push(matchRes.results);
                            }
                        }
                        return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Update player stats for whoever stats owns this player stat. Determined by checking the player field of
     * {@link Ladder.PlayerStat}
     */
    Ladder.prototype.updatePlayerStat = function (currentStats) {
        return __awaiter(this, void 0, void 0, function () {
            var user, err_2;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!currentStats.player.anonymous) return [3 /*break*/, 1];
                        this.state.playerStats.set(currentStats.player.tournamentID.id, currentStats);
                        return [3 /*break*/, 6];
                    case 1:
                        _a.trys.push([1, 5, , 6]);
                        return [4 /*yield*/, this.dimension.databasePlugin.getUser(currentStats.player.tournamentID.id)];
                    case 2:
                        user = _a.sent();
                        if (!(user && user.statistics[this.getKeyName()])) return [3 /*break*/, 4];
                        return [4 /*yield*/, this.updateDatabasePlayerStats(currentStats, user)];
                    case 3:
                        _a.sent();
                        _a.label = 4;
                    case 4: return [3 /*break*/, 6];
                    case 5:
                        err_2 = _a.sent();
                        // don't stop tourney if this happens
                        this.log.error("Issue with using database", err_2);
                        return [3 /*break*/, 6];
                    case 6: return [2 /*return*/];
                }
            });
        });
    };
    Ladder.prototype.handleMatchResults = function () {
        return __awaiter(this, void 0, void 0, function () {
            var toProcess, mapAgentIDtoTournamentID, result, rankStatePromises, ranks, currentRankStates, tourneyIDs, err_3, newRankStates, updatePlayerStatsPromises;
            var _this = this;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        toProcess = this.resultProcessingQueue.shift();
                        mapAgentIDtoTournamentID = toProcess.mapAgentIDtoTournamentID;
                        result = toProcess.result;
                        // stop if no ranks provided, meaning match not successful and we throw result away
                        if (result.ranks.length === 0) {
                            this.emit(__1.Tournament.Events.MATCH_HANDLED);
                            return [2 /*return*/];
                        }
                        result.ranks.sort(function (a, b) { return a.rank - b.rank; });
                        rankStatePromises = [];
                        ranks = [];
                        currentRankStates = [];
                        tourneyIDs = [];
                        result.ranks.forEach(function (rankInfo) {
                            var fetchRankState = function () { return __awaiter(_this, void 0, void 0, function () {
                                var tournamentID, playerStat, currentplayerStats;
                                return __generator(this, function (_a) {
                                    switch (_a.label) {
                                        case 0:
                                            tournamentID = mapAgentIDtoTournamentID.get(rankInfo.agentID);
                                            return [4 /*yield*/, this.getPlayerStat(tournamentID.id)];
                                        case 1:
                                            playerStat = (_a.sent()).playerStat;
                                            if (!playerStat) {
                                                throw new DimensionError_1.TournamentPlayerDoesNotExistError("Player " + tournamentID.id + " doesn't exist anymore, likely was removed");
                                            }
                                            currentplayerStats = playerStat;
                                            currentplayerStats.matchesPlayed++;
                                            ranks.push(rankInfo.rank);
                                            tourneyIDs.push({ id: tournamentID, stats: currentplayerStats });
                                            currentRankStates.push(currentplayerStats.rankState);
                                            return [2 /*return*/];
                                    }
                                });
                            }); };
                            rankStatePromises.push(fetchRankState());
                        });
                        _a.label = 1;
                    case 1:
                        _a.trys.push([1, 3, , 4]);
                        return [4 /*yield*/, Promise.all(rankStatePromises)];
                    case 2:
                        _a.sent();
                        return [3 /*break*/, 4];
                    case 3:
                        err_3 = _a.sent();
                        this.log.error('Probably due to player being removed: ', err_3);
                        this.emit(__1.Tournament.Events.MATCH_HANDLED);
                        return [2 /*return*/];
                    case 4:
                        newRankStates = this.ranksystem.updateRanks(currentRankStates, ranks);
                        updatePlayerStatsPromises = [];
                        tourneyIDs.forEach(function (info, i) {
                            var updateStat = function () { return __awaiter(_this, void 0, void 0, function () {
                                var currentStats;
                                return __generator(this, function (_a) {
                                    switch (_a.label) {
                                        case 0:
                                            currentStats = info.stats;
                                            currentStats.rankState = newRankStates[i];
                                            return [4 /*yield*/, this.updatePlayerStat(currentStats)];
                                        case 1:
                                            _a.sent();
                                            return [2 /*return*/];
                                    }
                                });
                            }); };
                            updatePlayerStatsPromises.push(updateStat());
                        });
                        return [4 /*yield*/, Promise.all(updatePlayerStatsPromises)];
                    case 5:
                        _a.sent();
                        if (!this.configs.consoleDisplay) return [3 /*break*/, 7];
                        return [4 /*yield*/, this.printTournamentStatus()];
                    case 6:
                        _a.sent();
                        _a.label = 7;
                    case 7:
                        this.emit(__1.Tournament.Events.MATCH_HANDLED);
                        return [2 /*return*/];
                }
            });
        });
    };
    Ladder.prototype.preInternalDestroy = function () {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                if (this.runInterval)
                    clearInterval(this.runInterval);
                if (this.configSyncInterval)
                    clearInterval(this.configSyncInterval);
                return [2 /*return*/];
            });
        });
    };
    return Ladder;
}(__1.Tournament));
exports.Ladder = Ladder;
//# sourceMappingURL=index.js.map