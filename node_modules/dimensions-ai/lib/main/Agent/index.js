"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __spreadArrays = (this && this.__spreadArrays) || function () {
    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
    for (var r = Array(s), k = 0, i = 0; i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
            r[k] = a[j];
    return r;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var path_1 = __importDefault(require("path"));
var os_1 = __importDefault(require("os"));
var fs_1 = __importDefault(require("fs"));
var tree_kill_1 = __importDefault(require("tree-kill"));
var Logger_1 = require("../Logger");
var DimensionError_1 = require("../DimensionError");
var DeepMerge_1 = require("../utils/DeepMerge");
var System_1 = require("../utils/System");
var DeepCopy_1 = require("../utils/DeepCopy");
var stream_1 = require("stream");
var events_1 = require("events");
var TypeGuards_1 = require("../utils/TypeGuards");
var pidusage_1 = __importDefault(require("pidusage"));
var default_json_1 = __importDefault(require("../Security/seccomp/default.json"));
var utils_1 = require("../utils");
var cross_spawn_1 = __importDefault(require("cross-spawn"));
var process_exists_1 = __importDefault(require("process-exists"));
var DefaultSeccompProfileString = JSON.stringify(default_json_1.default);
var containerBotFolder = '/code';
/**
 * @class Agent
 * @classdesc The agent is what participates in a match and contains details on the files powering the agent, the
 * process associated and many other details.
 *
 * Reads in a file source for the code and copies the bot folder to a temporary directory in secure modes
 * and creates an `Agent` for use in the {@link MatchEngine} and {@link Match}
 *
 * This is a class that should not be broken. If something goes wrong, this should always throw a error. It is
 * expected that agents are used knowing beforehand that the file given is validated
 */
var Agent = /** @class */ (function (_super) {
    __extends(Agent, _super);
    function Agent(file, options, languageSpecificOptions) {
        if (languageSpecificOptions === void 0) { languageSpecificOptions = {}; }
        var _this = _super.call(this) || this;
        /**
         * This agent's ID in a match. It is always a non-negative integer and agents in a match are always numbered
         * `0, 1, 2, ...n` where there are `n` agents.
         */
        _this.id = 0;
        /**
         * A tournmanet ID if Agent is generated from within a {@link Tournament}
         */
        _this.tournamentID = null;
        /** The command used to run the file */
        _this.cmd = null;
        /**
         * The agent's options
         */
        _this.options = DeepCopy_1.deepCopy(Agent.OptionDefaults);
        /** internal buffer to store stdout from an agent that has yet to be delimited / used */
        _this._buffer = [];
        /** Interval that periodically watches the memory usage of the process associated with this agent */
        _this.memoryWatchInterval = null;
        /**
         * The associated process running the Agent
         */
        _this.process = null;
        /**
         * Associated docker container running the agent
         */
        _this.container = null;
        /**
         * Streams associated with the agent
         */
        _this.streams = {
            in: null,
            out: null,
            err: null,
        };
        /**
         * Current status of the agent
         */
        _this.status = Agent.Status.UNINITIALIZED;
        /** The commands collected so far for the current move */
        _this.currentMoveCommands = [];
        /* istanbul ignore next */
        _this._currentMoveResolve = utils_1.noop; // set as a dummy function
        /** A number that counts the number of times the agent has essentially interacted with the {@link MatchEngine} */
        _this.agentTimeStep = 0;
        /** Clears out the timer associated with the agent during a match */
        _this._clearTimer = utils_1.noop;
        _this.errorLogWriteStream = null;
        _this.log = new Logger_1.Logger();
        /**
         * Key used to retrieve the error logs of this agent
         */
        _this.logkey = null;
        /** whether agent is allowed to send commands. Used to help ignore extra output from agents */
        _this.allowedToSendCommands = true;
        /** Agent version, used by tournament */
        _this.version = 0;
        /** Size of agent's logs so far */
        _this._logsize = 0;
        _this._trimmed = false;
        /** List of all messages written to this agent are directly pushed to here when in detached mode */
        _this.messages = [];
        _this.creationDate = new Date();
        _this.options = DeepMerge_1.deepMerge(_this.options, DeepCopy_1.deepCopy(options));
        _this.log.level = _this.options.loggingLevel;
        if (!_this.options.detached) {
            _this.ext = path_1.default.extname(file);
            if (languageSpecificOptions[_this.ext]) {
                _this.options = DeepMerge_1.deepMerge(_this.options, DeepCopy_1.deepCopy(languageSpecificOptions[_this.ext]));
            }
            _this.cwd = path_1.default.dirname(file);
            _this.src = path_1.default.basename(file);
            _this.srcNoExt = _this.src.slice(0, -_this.ext.length);
            // check if folder is valid
            if (!fs_1.default.existsSync(_this.cwd)) {
                throw new DimensionError_1.AgentDirectoryError(_this.cwd + " directory does not exist, check if directory provided through the file is correct", _this.id);
            }
            // check if file exists
            if (!fs_1.default.existsSync(file)) {
                throw new DimensionError_1.AgentFileError(file + " does not exist, check if file path provided is correct", _this.id);
            }
            _this.file = file;
            switch (_this.ext) {
                case '.py':
                    _this.cmd = 'python';
                    break;
                case '.js':
                case '.ts':
                    _this.cmd = 'node';
                    break;
                case '.java':
                    _this.cmd = 'java';
                    break;
                case '.php':
                    _this.cmd = 'php';
                    break;
                case '.c':
                case '.cpp':
                case '.go':
                    _this.cmd = '';
                    break;
                default:
            }
        }
        if (_this.options.id !== null) {
            _this.id = options.id;
        }
        else {
            throw new DimensionError_1.AgentMissingIDError("No id provided for agent using " + file, _this.id);
        }
        if (_this.options.name) {
            _this.name = _this.options.name;
        }
        else {
            _this.name = "agent_" + _this.id;
        }
        if (_this.options.tournamentID) {
            _this.tournamentID = options.tournamentID;
            _this.name = _this.tournamentID.name;
        }
        _this.log.system("Created agent: " + _this.name);
        // set agent as ready
        _this.status = Agent.Status.READY;
        return _this;
    }
    Agent.prototype.setupContainer = function (name, docker, engineOptions) {
        return __awaiter(this, void 0, void 0, function () {
            var HostConfig, container;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        HostConfig = {
                            // apply seccomp profile for security
                            SecurityOpt: ["seccomp=" + DefaultSeccompProfileString],
                        };
                        if (engineOptions.memory.active) {
                            HostConfig.Memory = engineOptions.memory.limit;
                        }
                        return [4 /*yield*/, docker.createContainer({
                                Image: this.options.image,
                                name: name,
                                OpenStdin: true,
                                StdinOnce: true,
                                HostConfig: HostConfig,
                            })];
                    case 1:
                        container = _a.sent();
                        this.log.system("Created container " + name);
                        // store container
                        this.container = container;
                        return [4 /*yield*/, container.start()];
                    case 2:
                        _a.sent();
                        this.log.system("Started container " + name);
                        // copy bot directory into container
                        return [4 /*yield*/, System_1.dockerCopy(this.cwd + '/.', name, '/code')];
                    case 3:
                        // copy bot directory into container
                        _a.sent();
                        this.log.system("Copied bot into container " + name);
                        return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Install whatever is needed through a `install.sh` file in the root of the bot folder
     */
    Agent.prototype._install = function (stderrWritestream, stdoutWritestream, engineOptions) {
        var _this = this;
        // eslint-disable-next-line no-async-promise-executor
        return new Promise(function (resolve, reject) { return __awaiter(_this, void 0, void 0, function () {
            var stdout, stderr, installTimer_1, chunks_1, handleClose_1, handleError_1, exec, data_1, err_1, p;
            var _this = this;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!fs_1.default.existsSync(path_1.default.join(this.cwd, 'install.sh'))) return [3 /*break*/, 9];
                        stdout = void 0;
                        stderr = void 0;
                        installTimer_1 = setTimeout(function () {
                            var msg = 'Agent went over install time during the install stage\n';
                            _this.writeToErrorLog(msg);
                            reject(new DimensionError_1.AgentInstallTimeoutError(msg, _this.id));
                        }, this.options.maxInstallTime);
                        chunks_1 = [];
                        handleClose_1 = function (code) {
                            clearTimeout(installTimer_1);
                            if (code === 0) {
                                resolve();
                            }
                            else {
                                var msg = "A install time error occured. Install step for agent " + _this.id + " exited with code: " + code + "; Installing " + path_1.default.join(_this.cwd, 'install.sh') + "; Install Output:\n" + chunks_1.join('');
                                if (code === 137) {
                                    msg += "\nAgent likely ran out of memory, exceeded " + engineOptions.memory.limit / 1000000 + " MB";
                                }
                                _this.writeToErrorLog(msg + '\n');
                                reject(new DimensionError_1.AgentInstallError(msg, _this.id));
                            }
                        };
                        handleError_1 = function (err) {
                            clearTimeout(installTimer_1);
                            reject(err);
                        };
                        if (!this.options.secureMode) return [3 /*break*/, 7];
                        _a.label = 1;
                    case 1:
                        _a.trys.push([1, 5, , 6]);
                        return [4 /*yield*/, this.container.exec({
                                Cmd: ['/bin/sh', '-c', 'chmod u+x install.sh'],
                                WorkingDir: containerBotFolder,
                            })];
                    case 2:
                        exec = _a.sent();
                        return [4 /*yield*/, exec.start({})];
                    case 3:
                        _a.sent();
                        return [4 /*yield*/, this.containerSpawn(path_1.default.join(containerBotFolder, 'install.sh'))];
                    case 4:
                        data_1 = _a.sent();
                        stderr = data_1.err;
                        stdout = data_1.out;
                        data_1.stream.on('end', function () { return __awaiter(_this, void 0, void 0, function () {
                            var endRes;
                            return __generator(this, function (_a) {
                                switch (_a.label) {
                                    case 0: return [4 /*yield*/, data_1.exec.inspect()];
                                    case 1:
                                        endRes = _a.sent();
                                        handleClose_1(endRes.ExitCode);
                                        return [2 /*return*/];
                                }
                            });
                        }); });
                        data_1.stream.on('error', function (err) {
                            handleError_1(err);
                        });
                        return [3 /*break*/, 6];
                    case 5:
                        err_1 = _a.sent();
                        handleError_1(err_1);
                        return [2 /*return*/];
                    case 6: return [3 /*break*/, 8];
                    case 7:
                        p = cross_spawn_1.default('sh', ['install.sh'], {
                            cwd: this.cwd,
                        });
                        p.on('error', function (err) {
                            handleError_1(err);
                        });
                        p.on('close', function (code) {
                            handleClose_1(code);
                        });
                        stderr = p.stderr;
                        stdout = p.stdout;
                        _a.label = 8;
                    case 8:
                        stdout.on('data', function (chunk) {
                            chunks_1.push(chunk);
                        });
                        stderr.on('data', function (chunk) {
                            chunks_1.push(chunk);
                        });
                        if (stderrWritestream) {
                            stderr.pipe(stderrWritestream, {
                                end: false,
                            });
                        }
                        if (stdoutWritestream) {
                            stdout.pipe(stdoutWritestream, {
                                end: false,
                            });
                        }
                        return [3 /*break*/, 10];
                    case 9:
                        resolve();
                        _a.label = 10;
                    case 10: return [2 /*return*/];
                }
            });
        }); });
    };
    /**
     * Compile whatever is needed and validate files. Called by {@link MatchEngine} and has a timer set by the
     * maxCompileTime option in {@link Agent.Options}
     */
    Agent.prototype._compile = function (stderrWritestream, stdoutWritestream, engineOptions) {
        return __awaiter(this, void 0, void 0, function () {
            var _this = this;
            return __generator(this, function (_a) {
                // eslint-disable-next-line no-async-promise-executor
                return [2 /*return*/, new Promise(function (resolve, reject) { return __awaiter(_this, void 0, void 0, function () {
                        var p, stdout, stderr, compileTimer, cmd1, restofCmds, _a, chunks, handleClose, handleError, containerExec_1;
                        var _this = this;
                        return __generator(this, function (_b) {
                            switch (_b.label) {
                                case 0:
                                    compileTimer = setTimeout(function () {
                                        var msg = 'Agent went over compile time during the compile stage\n';
                                        _this.writeToErrorLog(msg);
                                        reject(new DimensionError_1.AgentCompileTimeoutError(msg, _this.id));
                                    }, this.options.maxCompileTime);
                                    if (!this.options.compileCommands[this.ext]) return [3 /*break*/, 2];
                                    cmd1 = this.options.compileCommands[this.ext][0];
                                    restofCmds = this.options.compileCommands[this.ext].slice(1);
                                    return [4 /*yield*/, this._spawnCompileProcess(cmd1, __spreadArrays(restofCmds, [this.src]))];
                                case 1:
                                    p = _b.sent();
                                    return [3 /*break*/, 15];
                                case 2:
                                    _a = this.ext;
                                    switch (_a) {
                                        case '.py': return [3 /*break*/, 3];
                                        case '.php': return [3 /*break*/, 3];
                                        case '.js': return [3 /*break*/, 3];
                                        case '.ts': return [3 /*break*/, 4];
                                        case '.go': return [3 /*break*/, 6];
                                        case '.cpp': return [3 /*break*/, 8];
                                        case '.c': return [3 /*break*/, 10];
                                        case '.java': return [3 /*break*/, 12];
                                    }
                                    return [3 /*break*/, 14];
                                case 3:
                                    clearTimeout(compileTimer);
                                    resolve();
                                    return [2 /*return*/];
                                case 4: return [4 /*yield*/, this._spawnCompileProcess('tsc', [])];
                                case 5:
                                    // expect user to provide a tsconfig.json
                                    p = _b.sent();
                                    return [3 /*break*/, 15];
                                case 6: return [4 /*yield*/, this._spawnCompileProcess('go', [
                                        'build',
                                        '-o',
                                        this.srcNoExt + ".out",
                                        this.src,
                                    ])];
                                case 7:
                                    p = _b.sent();
                                    return [3 /*break*/, 15];
                                case 8: return [4 /*yield*/, this._spawnCompileProcess('g++', [
                                        '-std=c++11',
                                        '-O3',
                                        '-o',
                                        this.srcNoExt + ".out",
                                        this.src,
                                    ])];
                                case 9:
                                    p = _b.sent();
                                    return [3 /*break*/, 15];
                                case 10: return [4 /*yield*/, this._spawnCompileProcess('gcc', [
                                        '-O3',
                                        '-o',
                                        this.srcNoExt + ".out",
                                        this.src,
                                    ])];
                                case 11:
                                    p = _b.sent();
                                    return [3 /*break*/, 15];
                                case 12: return [4 /*yield*/, this._spawnCompileProcess('javac', [this.src])];
                                case 13:
                                    p = _b.sent();
                                    return [3 /*break*/, 15];
                                case 14:
                                    this.log.system(this.ext + " not recognized, skipping compilation");
                                    // reject(
                                    //   new NotSupportedError(
                                    //     `Language with extension ${this.ext} is not supported at the moment`
                                    //   )
                                    // );
                                    clearTimeout(compileTimer);
                                    resolve();
                                    return [2 /*return*/];
                                case 15:
                                    chunks = [];
                                    handleClose = function (code) {
                                        clearTimeout(compileTimer);
                                        if (code === 0) {
                                            resolve();
                                        }
                                        else {
                                            var msg = "A compile time error occured. Compile step for agent " + _this.id + " exited with code: " + code + "; Compiling " + _this.file + "; Compile Output:\n" + chunks.join('');
                                            if (code === 137) {
                                                msg += "\nAgent likely ran out of memory, exceeded " + engineOptions.memory.limit / 1000000 + " MB";
                                            }
                                            _this.writeToErrorLog(msg + '\n');
                                            reject(new DimensionError_1.AgentCompileError(msg, _this.id));
                                        }
                                    };
                                    handleError = function (err) {
                                        clearTimeout(compileTimer);
                                        reject(err);
                                    };
                                    if (TypeGuards_1.isChildProcess(p)) {
                                        stdout = p.stdout;
                                        stderr = p.stderr;
                                        p.on('error', function (err) {
                                            handleError(err);
                                        });
                                        p.on('close', function (code) {
                                            handleClose(code);
                                        });
                                    }
                                    else {
                                        stdout = p.out;
                                        stderr = p.err;
                                        containerExec_1 = p.exec;
                                        p.stream.on('error', function (err) {
                                            handleError(err);
                                        });
                                        p.stream.on('end', function () { return __awaiter(_this, void 0, void 0, function () {
                                            var endRes;
                                            return __generator(this, function (_a) {
                                                switch (_a.label) {
                                                    case 0: return [4 /*yield*/, containerExec_1.inspect()];
                                                    case 1:
                                                        endRes = _a.sent();
                                                        handleClose(endRes.ExitCode);
                                                        return [2 /*return*/];
                                                }
                                            });
                                        }); });
                                    }
                                    stdout.on('data', function (chunk) {
                                        chunks.push(chunk);
                                    });
                                    stderr.on('data', function (chunk) {
                                        chunks.push(chunk);
                                    });
                                    if (stderrWritestream) {
                                        stderr.pipe(stderrWritestream, {
                                            end: false,
                                        });
                                    }
                                    if (stdoutWritestream) {
                                        stdout.pipe(stdoutWritestream, {
                                            end: false,
                                        });
                                    }
                                    return [2 /*return*/];
                            }
                        });
                    }); })];
            });
        });
    };
    /**
     * Spawns the compilation process
     * @param command - command to compile with
     * @param args - argument for the compilation
     */
    Agent.prototype._spawnCompileProcess = function (command, args) {
        return __awaiter(this, void 0, void 0, function () {
            var _this = this;
            return __generator(this, function (_a) {
                return [2 /*return*/, new Promise(function (resolve, reject) {
                        if (_this.options.secureMode) {
                            _this.containerSpawn(command + " " + args.join(' '), containerBotFolder)
                                .then(resolve)
                                .catch(reject);
                        }
                        else {
                            var p = cross_spawn_1.default(command, __spreadArrays(args), {
                                cwd: _this.cwd,
                            }).on('error', function (err) {
                                reject(err);
                            });
                            resolve(p);
                        }
                    })];
            });
        });
    };
    /**
     * Executes the given command string in the agent's container and attaches stdin, stdout, and stderr accordingly
     * @param command - the command to execute in the container
     */
    Agent.prototype.containerSpawn = function (command, workingDir) {
        if (workingDir === void 0) { workingDir = '/'; }
        return __awaiter(this, void 0, void 0, function () {
            var exec, stream, instream, outstream, errstream;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.container.exec({
                            Cmd: ['/bin/sh', '-c', command],
                            AttachStdin: true,
                            AttachStdout: true,
                            AttachStderr: true,
                            WorkingDir: workingDir,
                        })];
                    case 1:
                        exec = _a.sent();
                        return [4 /*yield*/, exec.start({ stdin: true, hijack: true })];
                    case 2:
                        stream = _a.sent();
                        instream = new stream_1.Stream.PassThrough();
                        outstream = new stream_1.Stream.PassThrough();
                        errstream = new stream_1.Stream.PassThrough();
                        instream.pipe(stream);
                        this.container.modem.demuxStream(stream, outstream, errstream);
                        return [2 /*return*/, {
                                in: instream,
                                out: outstream,
                                err: errstream,
                                stream: stream,
                                exec: exec,
                            }];
                }
            });
        });
    };
    /**
     * Spawn the process and return the process
     */
    Agent.prototype._spawn = function () {
        return __awaiter(this, void 0, void 0, function () {
            var p;
            return __generator(this, function (_a) {
                if (this.options.runCommands[this.ext]) {
                    return [2 /*return*/, this._spawnProcess(this.options.runCommands[this.ext][0], __spreadArrays(this.options.runCommands[this.ext].slice(1), [
                            this.src,
                        ]))];
                }
                else {
                    switch (this.ext) {
                        case '.py':
                        case '.js':
                        case '.php': {
                            p = this._spawnProcess(this.cmd, [this.src]);
                            return [2 /*return*/, p];
                        }
                        case '.ts':
                            return [2 /*return*/, this._spawnProcess(this.cmd, [this.srcNoExt + '.js'])];
                        case '.java':
                            return [2 /*return*/, this._spawnProcess(this.cmd, [this.srcNoExt])];
                        case '.c':
                        case '.cpp':
                        case '.go':
                            return [2 /*return*/, this._spawnProcess('./' + this.srcNoExt + '.out', [])];
                        default:
                            this.log.system(this.ext + " not recognized, directly executing file");
                            return [2 /*return*/, this._spawnProcess('./' + this.src, [])];
                        // throw new NotSupportedError(
                        //   `Language with extension ${this.ext} is not supported yet`
                        // );
                    }
                }
                return [2 /*return*/];
            });
        });
    };
    /**
     * Spawns process in this.cwd accordingly and uses the configs accordingly.
     * Resolves with the process if spawned succesfully
     *
     * Note, we are spawning detached so we can kill off all sub processes if they are made. See {@link _terminate} for
     * explanation
     */
    Agent.prototype._spawnProcess = function (command, args) {
        var _this = this;
        return new Promise(function (resolve, reject) {
            if (_this.options.secureMode) {
                _this.containerSpawn(command + " " + args.join(' '), containerBotFolder)
                    .then(resolve)
                    .catch(reject);
            }
            else {
                var p = cross_spawn_1.default(command, args, {
                    cwd: _this.cwd,
                    detached: false,
                }).on('error', function (err) {
                    reject(err);
                });
                resolve(p);
            }
        });
    };
    /**
     * Stop an agent provided it is not terminated. To terminate it, see {@link _terminate};
     */
    Agent.prototype.stop = function () {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!!this.isTerminated()) return [3 /*break*/, 4];
                        if (!this.options.secureMode) return [3 /*break*/, 2];
                        return [4 /*yield*/, this.container.pause()];
                    case 1:
                        _a.sent();
                        return [3 /*break*/, 3];
                    case 2:
                        if (os_1.default.platform() !== 'win32') {
                            this.process.kill('SIGSTOP');
                        }
                        _a.label = 3;
                    case 3:
                        this.status = Agent.Status.STOPPED;
                        _a.label = 4;
                    case 4: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Resume an agent as long it is not terminated already
     */
    Agent.prototype.resume = function () {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                if (!this.isTerminated()) {
                    this._allowCommands();
                    if (this.options.secureMode) {
                        // await this.container.unpause();
                    }
                    else {
                        if (os_1.default.platform() !== 'win32') {
                            this.process.kill('SIGCONT');
                        }
                    }
                    this.status = Agent.Status.RUNNING;
                }
                return [2 /*return*/];
            });
        });
    };
    /**
     * timeout the agent
     */
    Agent.prototype.timeout = function () {
        var msg = 'Agent timed out';
        this.writeToErrorLog(msg);
        this.emit(Agent.AGENT_EVENTS.TIMEOUT);
    };
    /**
     * call out agent for exceeding memory limit
     */
    Agent.prototype.overMemory = function () {
        var msg = 'Agent exceeded memory limit';
        this.writeToErrorLog(msg);
        this.emit(Agent.AGENT_EVENTS.EXCEED_MEMORY_LIMIT);
    };
    /**
     * Whether or not input is destroyed
     */
    Agent.prototype.inputDestroyed = function () {
        return this.streams.in.destroyed;
    };
    /**
     * Write to stdin of the process associated with the agent
     * @param message - the message
     * @param callback - callback function
     *
     * returns true if written, false if highWaterMark reached
     */
    Agent.prototype.write = function (message, callback) {
        // in detached mode, simply keep track of messages sent.
        if (this.options.detached) {
            this.messages.push(message);
            process.nextTick(callback);
            return true;
        }
        /**
         * the following few lines are based on the suggestion at
         * https://nodejs.org/api/stream.html#stream_writable_write_chunk_encoding_callback
         */
        if (!this.streams.in.write(message)) {
            return false;
        }
        else {
            process.nextTick(callback);
        }
        return true;
    };
    Agent.prototype.writeToErrorLog = function (message) {
        if (this.errorLogWriteStream) {
            this._logsize += message.length;
            this.errorLogWriteStream.write(message);
        }
    };
    /**
     * Get process of agent
     */
    Agent.prototype._getProcess = function () {
        return this.process;
    };
    /**
     * Store process for agent
     * @param p - process to store
     */
    Agent.prototype._storeProcess = function (p) {
        this.process = p;
    };
    /**
     * Returns true if this agent was terminated and no longer send or receive emssages
     */
    Agent.prototype.isTerminated = function () {
        return this.status === Agent.Status.KILLED;
    };
    /**
     * Terminates this agent by stopping all related processes and remove any temporary directory. this is the only function allowed to
     * set the status value to killed.
     */
    Agent.prototype._terminate = function () {
        var _this = this;
        this.status = Agent.Status.KILLED;
        // eslint-disable-next-line no-async-promise-executor
        return new Promise(function (resolve, reject) { return __awaiter(_this, void 0, void 0, function () {
            var ins, err_2, exists;
            var _this = this;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!this.options.secureMode) return [3 /*break*/, 10];
                        if (!this.container) return [3 /*break*/, 8];
                        _a.label = 1;
                    case 1:
                        _a.trys.push([1, 6, , 7]);
                        return [4 /*yield*/, this.container.inspect()];
                    case 2:
                        ins = _a.sent();
                        this._clearTimer();
                        clearInterval(this.memoryWatchInterval);
                        if (!ins.State.Running) return [3 /*break*/, 5];
                        return [4 /*yield*/, this.container.kill()];
                    case 3:
                        _a.sent();
                        return [4 /*yield*/, this.container.remove()];
                    case 4:
                        _a.sent();
                        _a.label = 5;
                    case 5:
                        resolve();
                        return [3 /*break*/, 7];
                    case 6:
                        err_2 = _a.sent();
                        if (err_2.statusCode !== 409 && err_2.reason !== 'no such container') {
                            reject(err_2);
                        }
                        else {
                            resolve();
                        }
                        return [3 /*break*/, 7];
                    case 7: return [3 /*break*/, 9];
                    case 8:
                        resolve();
                        _a.label = 9;
                    case 9: return [3 /*break*/, 14];
                    case 10:
                        if (!this.process) return [3 /*break*/, 13];
                        exists = true;
                        if (!(os_1.default.platform() === 'win32')) return [3 /*break*/, 12];
                        return [4 /*yield*/, process_exists_1.default(this.process.pid)];
                    case 11:
                        // fix bug where on windows, would throw error when treekill fails
                        exists = _a.sent();
                        _a.label = 12;
                    case 12:
                        if (exists) {
                            tree_kill_1.default(this.process.pid, 'SIGKILL', function (err) {
                                _this._clearTimer();
                                clearInterval(_this.memoryWatchInterval);
                                if (err) {
                                    reject(err);
                                }
                                else {
                                    resolve();
                                }
                            });
                        }
                        return [3 /*break*/, 14];
                    case 13:
                        resolve();
                        _a.label = 14;
                    case 14: return [2 /*return*/];
                }
            });
        }); });
    };
    /**
     * Disallow an agent from sending more commands
     */
    Agent.prototype._disallowCommands = function () {
        this.allowedToSendCommands = false;
    };
    /**
     * Allow agent to send commands again
     */
    Agent.prototype._allowCommands = function () {
        this.allowedToSendCommands = true;
    };
    /**
     * Check if agent is set to be allowed to send commands. The {@link EngineOptions} affect when this is flipped
     */
    Agent.prototype.isAllowedToSendCommands = function () {
        return this.allowedToSendCommands;
    };
    /**
     * Setup the agent timer clear out method
     */
    Agent.prototype._setTimeout = function (fn, delay) {
        var args = [];
        for (var _i = 2; _i < arguments.length; _i++) {
            args[_i - 2] = arguments[_i];
        }
        var timer = setTimeout(function () {
            fn.apply(void 0, args);
        }, delay);
        this._clearTimer = function () {
            clearTimeout(timer);
        };
    };
    /**
     * Stop this agent from more outputs and mark it as done for now and awaiting for updates. Effectively force agent to sync with match
     */
    Agent.prototype._finishMove = function () {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                this._clearTimer();
                // Resolve move and tell engine in `getCommands` this agent is done outputting commands and awaits input
                this._currentMoveResolve();
                // stop the process for now from sending more output and disallow commmands to ignore rest of output
                if (this.options.secureMode) {
                    // TODO: Implement
                    // await this.container.pause();
                }
                else {
                    if (os_1.default.platform() !== 'win32') {
                        this.process.kill('SIGSTOP');
                    }
                }
                this._disallowCommands();
                return [2 /*return*/];
            });
        });
    };
    // Start an Agent's move and setup the promise structures
    Agent.prototype._setupMove = function () {
        var _this = this;
        // allows agent to send commands; increment time; clear past commands; reset the promise structure
        this.allowedToSendCommands = true;
        this.agentTimeStep++;
        this.currentMoveCommands = [];
        this._currentMovePromise = new Promise(function (resolve, reject) {
            _this._currentMoveResolve = resolve;
            _this._currentMoveReject = reject;
        });
    };
    /**
     * Used by {@link MatchEngine} only. Setups the memory watcher if docker is not used.
     * @param engineOptions - engine options to configure the agent with
     */
    Agent.prototype._setupMemoryWatcher = function (engineOptions) {
        var _this = this;
        var checkAgentMemoryUsage = function () {
            // setting { maxage: 0 } because otherwise pidusage leaves interval "memory leaks" and process doesn't exit fast
            if (os_1.default.platform() !== 'win32' && System_1.processIsRunning(_this.process.pid)) {
                pidusage_1.default(_this.process.pid, {
                    maxage: 0,
                    usePs: engineOptions.memory.usePs,
                })
                    .then(function (stat) {
                    if (stat.memory > engineOptions.memory.limit) {
                        _this.overMemory();
                    }
                })
                    .catch(function (err) {
                    _this.log.system(err);
                });
            }
        };
        checkAgentMemoryUsage();
        this.memoryWatchInterval = setInterval(checkAgentMemoryUsage, engineOptions.memory.checkRate);
    };
    /**
     * Generates a list of agents for use
     * @param files List of files to use to make agents or a list of objects with a file key for the file path to the bot
     *              and a name key for the name of the agent
     * @param options - Options to first override with for all agents
     * @param languageSpecificOptions - Options to second overrided with for agents depending on language
     * @param agentSpecificOptions - Options to lastly override with depending on agent's index
     */
    Agent.generateAgents = function (files, options, languageSpecificOptions, agentSpecificOptions) {
        if (languageSpecificOptions === void 0) { languageSpecificOptions = {}; }
        if (agentSpecificOptions === void 0) { agentSpecificOptions = []; }
        if (files.length === 0) {
            throw new DimensionError_1.AgentFileError('No files provided to generate agents with!', -1);
        }
        var agents = [];
        if (TypeGuards_1.AgentClassTypeGuards.isGenerationMetaData_FilesOnly(files)) {
            files.forEach(function (file, index) {
                var configs = DeepCopy_1.deepCopy(options);
                configs = DeepMerge_1.deepMerge(configs, DeepCopy_1.deepCopy(agentSpecificOptions[index] ? agentSpecificOptions[index] : {}));
                configs.id = index;
                agents.push(new Agent(file, configs, languageSpecificOptions));
            });
        }
        else if (TypeGuards_1.AgentClassTypeGuards.isGenerationMetaData_CreateMatch(files)) {
            files.forEach(function (info, index) {
                var configs = DeepCopy_1.deepCopy(options);
                configs = DeepMerge_1.deepMerge(configs, DeepCopy_1.deepCopy(agentSpecificOptions[index] ? agentSpecificOptions[index] : {}));
                configs.id = index;
                configs.name = info.name;
                agents.push(new Agent(info.file, configs, languageSpecificOptions));
            });
        }
        else {
            files.forEach(function (info, index) {
                var configs = DeepCopy_1.deepCopy(options);
                configs = DeepMerge_1.deepMerge(configs, DeepCopy_1.deepCopy(agentSpecificOptions[index] ? agentSpecificOptions[index] : {}));
                configs.id = index;
                configs.tournamentID = info.tournamentID;
                var newAgent = new Agent(info.file, configs, languageSpecificOptions);
                newAgent.version = info.version;
                agents.push(newAgent);
            });
        }
        return agents;
    };
    Agent.prototype.getAgentErrorLogFilename = function () {
        return "agent_" + this.id + ".log";
    };
    return Agent;
}(events_1.EventEmitter));
exports.Agent = Agent;
(function (Agent) {
    /**
     * Status enums for an Agent
     */
    var Status;
    (function (Status) {
        /** When agent is just created */
        Status["UNINITIALIZED"] = "uninitialized";
        /** Agent is ready too be used by the {@link MatchEngine} in a {@link Match} */
        Status["READY"] = "ready";
        /** Agent is currently running */
        Status["RUNNING"] = "running";
        /** Agent crashed somehow */
        Status["CRASHED"] = "crashed";
        /** Agent is finished and no longer in use after {@link Match} ended or was prematurely killed */
        Status["KILLED"] = "killed";
        /** Agent is currently not running */
        Status["STOPPED"] = "stopped";
    })(Status = Agent.Status || (Agent.Status = {}));
    /**
     * Agent events
     */
    var AGENT_EVENTS;
    (function (AGENT_EVENTS) {
        /**
         * Event emitted by process of {@link Agent} when memory limit is exceeded
         */
        AGENT_EVENTS["EXCEED_MEMORY_LIMIT"] = "exceedMemoryLimit";
        /**
         * Event emitted by process of {@link Agent} when it times out.
         */
        AGENT_EVENTS["TIMEOUT"] = "timeout";
        /**
         * event emitted when associated process or container for agent closes and agent effectively is terminated
         */
        AGENT_EVENTS["CLOSE"] = "close";
    })(AGENT_EVENTS = Agent.AGENT_EVENTS || (Agent.AGENT_EVENTS = {}));
    /**
     * Default Agent options
     */
    Agent.OptionDefaults = {
        secureMode: false,
        loggingLevel: Logger_1.Logger.LEVEL.INFO,
        id: null,
        tournamentID: null,
        name: null,
        maxInstallTime: 300000,
        maxCompileTime: 60000,
        runCommands: {},
        compileCommands: {},
        image: 'docker.io/stonezt2000/dimensions_langs',
        useCachedBotFile: false,
        logLimit: 1e5,
        detached: false,
    };
})(Agent = exports.Agent || (exports.Agent = {}));
exports.Agent = Agent;
//# sourceMappingURL=index.js.map